<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inyecci√≥n de Dependencias en Android: Dagger y Hilt para Expertos - ArceApps Blog</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-left">
        <div class="nav-logo">
          <h3><a href="../index.html">ArceApps</a></h3>
        </div>
      </div>
      <div class="nav-right">
        <ul class="nav-menu" id="nav-menu">
          <li class="nav-item">
            <a href="../index.html" class="nav-link">Inicio</a>
          </li>
          <li class="nav-item">
            <a href="../about.html" class="nav-link">About</a>
          </li>
          <li class="nav-item">
            <a href="../portfolio.html" class="nav-link">Portfolio</a>
          </li>
          <li class="nav-item">
            <a href="../blog.html" class="nav-link active">Blog</a>
          </li>
        </ul>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
          <div class="theme-toggle-circle">
            <span class="theme-icon">üåô</span>
          </div>
        </button>
        <div class="nav-toggle" id="nav-toggle">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </div>
      </div>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">20 de enero de 2026</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>Inyecci√≥n de Dependencias en Android: Dagger y Hilt para Expertos</h1>
        <p class="article-subtitle">Domina la inyecci√≥n de dependencias desde los fundamentos hasta implementaciones avanzadas con Dagger y Hilt. Descubre m√≥dulos, componentes, subcomponentes y scopes para crear grafos de dependencias robustos y escalables.</p>
        <div class="article-image">
          <img src="../images/placeholder-article-dependency-injection.svg" alt="Inyecci√≥n de Dependencias Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>üéØ ¬øQu√© es la Inyecci√≥n de Dependencias y por qu√© necesitas dominarla?</h2>
        <p>Imagina que est√°s construyendo una aplicaci√≥n de chat como WhatsApp. Tu <code>ChatViewModel</code> necesita un repositorio de mensajes, un servicio de autenticaci√≥n, un cliente de red, y un manejador de notificaciones. Si creas estas dependencias manualmente, tu c√≥digo se convierte en una <strong>pesadilla de acoplamiento</strong> üîó que es imposible de testear y mantener.</p>

        <p><strong>La Inyecci√≥n de Dependencias (DI)</strong> es el patr√≥n que resuelve este problema: en lugar de que tus clases creen sus propias dependencias, se las <strong>"inyectas" desde el exterior</strong>. Es como tener un mayordomo personal que te trae exactamente lo que necesitas, cuando lo necesitas, sin que tengas que preocuparte de d√≥nde vienen las cosas.</p>

        <div class="dependency-injection-benefits">
          <h3>üöÄ ¬øPor qu√© la DI es tu superpoder secreto?</h3>
          <div class="benefits-grid">
            <div class="benefit-card">
              <div class="benefit-icon">üß™</div>
              <h4>Testing Sin Dolor</h4>
              <p>Mockea cualquier dependencia f√°cilmente para tests unitarios</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üîÑ</div>
              <h4>Flexibilidad Total</h4>
              <p>Cambia implementaciones sin modificar el c√≥digo cliente</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üèóÔ∏è</div>
              <h4>Construcci√≥n Autom√°tica</h4>
              <p>El framework resuelve autom√°ticamente las dependencias</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">‚ôªÔ∏è</div>
              <h4>Reutilizaci√≥n Inteligente</h4>
              <p>Comparte instancias seg√∫n el scope configurado</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üîç</div>
              <h4>Depuraci√≥n Simple</h4>
              <p>Visualiza y debuggea el grafo de dependencias f√°cilmente</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üì¶</div>
              <h4>Modularizaci√≥n Perfecta</h4>
              <p>Organiza dependencias por m√≥dulos y caracter√≠sticas</p>
            </div>
          </div>
        </div>

        <h2>üó°Ô∏è Dagger vs Hilt: La Batalla de los Titanes</h2>
        <p>Antes de sumergirnos en el c√≥digo, entendamos la diferencia entre estas dos herramientas y cu√°ndo usar cada una:</p>

        <div class="comparison-section">
          <div class="comparison-card dagger">
            <div class="comparison-header">
              <h3>‚öîÔ∏è Dagger</h3>
              <span class="comparison-subtitle">El veterano poderoso</span>
            </div>
            <div class="comparison-content">
              <h4>‚úÖ Ventajas:</h4>
              <ul>
                <li><strong>Control total:</strong> Configuraci√≥n completa del grafo</li>
                <li><strong>Sin magic:</strong> Todo expl√≠cito y transparente</li>
                <li><strong>Rendimiento:</strong> Generaci√≥n de c√≥digo en compile-time</li>
                <li><strong>Flexibilidad:</strong> Para casos de uso muy espec√≠ficos</li>
              </ul>
              <h4>‚ùå Desventajas:</h4>
              <ul>
                <li>Curva de aprendizaje empinada</li>
                <li>Mucho boilerplate code</li>
                <li>Configuraci√≥n compleja para Android</li>
              </ul>
            </div>
          </div>

          <div class="comparison-card hilt">
            <div class="comparison-header">
              <h3>üó°Ô∏è Hilt</h3>
              <span class="comparison-subtitle">El elegido moderno</span>
            </div>
            <div class="comparison-content">
              <h4>‚úÖ Ventajas:</h4>
              <ul>
                <li><strong>Simplicidad:</strong> Configuraci√≥n m√≠nima para Android</li>
                <li><strong>Best practices:</strong> Scopes predefinidos optimizados</li>
                <li><strong>Integration:</strong> Perfecto para Architecture Components</li>
                <li><strong>Less boilerplate:</strong> Menos c√≥digo, m√°s productividad</li>
              </ul>
              <h4>‚ùå Desventajas:</h4>
              <ul>
                <li>Menos control granular que Dagger puro</li>
                <li>Espec√≠fico para Android (no Java puro)</li>
                <li>Dependiente del ecosystem de Jetpack</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="decision-guide">
          <h3>üéØ ¬øCu√°l elegir para tu proyecto?</h3>
          <div class="decision-options">
            <div class="decision-option">
              <h4>üó°Ô∏è Elige Hilt si:</h4>
              <ul>
                <li>Est√°s creando una app Android moderna</li>
                <li>Usas Architecture Components (ViewModel, Room, etc.)</li>
                <li>Quieres productive development con menos c√≥digo</li>
                <li>Tu equipo es nuevo en DI</li>
              </ul>
            </div>
            <div class="decision-option">
              <h4>‚öîÔ∏è Elige Dagger si:</h4>
              <ul>
                <li>Necesitas control total del grafo de dependencias</li>
                <li>Trabajas con m√≥dulos Java puros</li>
                <li>Tienes configuraciones muy espec√≠ficas</li>
                <li>Migras desde un sistema Dagger existente</li>
              </ul>
            </div>
          </div>
        </div>

        <h2>üèóÔ∏è Hilt en Acci√≥n: Construyendo ChatFlow</h2>
        <p>Vamos a implementar <strong>ChatFlow</strong>, una aplicaci√≥n de mensajer√≠a que demuestra todos los conceptos avanzados de inyecci√≥n de dependencias. Desde configuraci√≥n b√°sica hasta scopes customizados.</p>

        <h3>üì± Configuraci√≥n Inicial: El Foundation</h3>
        <p>Comenzamos configurando Hilt en nuestro proyecto. Esta es la base sobre la que construiremos todo:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">build.gradle (app)</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">plugins {
    id 'kotlin-kapt'
    id 'dagger.hilt.android.plugin'
}

dependencies {
    // Hilt dependencies
    implementation "com.google.dagger:hilt-android:2.48"
    kapt "com.google.dagger:hilt-compiler:2.48"
    
    // Hilt ViewModel integration
    implementation "androidx.hilt:hilt-lifecycle-viewmodel:1.0.0-alpha03"
    kapt "androidx.hilt:hilt-compiler:1.0.0"
    
    // Hilt Testing
    testImplementation "com.google.dagger:hilt-android-testing:2.48"
    kaptTest "com.google.dagger:hilt-compiler:2.48"
}</code></pre>
        </div>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">ChatFlowApplication.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@HiltAndroidApp
class ChatFlowApplication : Application() {
    
    override fun onCreate() {
        super.onCreate()
        // Hilt maneja autom√°ticamente la inicializaci√≥n del grafo
        setupTimber() // Logging
        setupNotificationChannels()
    }
    
    private fun setupTimber() {
        if (BuildConfig.DEBUG) {
            Timber.plant(Timber.DebugTree())
        }
    }
}</code></pre>
        </div>

        <h3>üîß M√≥dulos: Los Bloques de Construcci√≥n</h3>
        <p>Los m√≥dulos son donde definimos <strong>c√≥mo crear las dependencias</strong>. Cada m√≥dulo tiene una responsabilidad espec√≠fica:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">NetworkModule.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .addInterceptor(AuthInterceptor())
            .addInterceptor(LoggingInterceptor())
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideRetrofit(okHttpClient: OkHttpClient): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BuildConfig.API_BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .addCallAdapterFactory(RxJava3CallAdapterFactory.create())
            .build()
    }
    
    @Provides
    @Singleton
    fun provideChatApiService(retrofit: Retrofit): ChatApiService {
        return retrofit.create(ChatApiService::class.java)
    }
}</code></pre>
        </div>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">DatabaseModule.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    
    @Provides
    @Singleton
    fun provideChatDatabase(@ApplicationContext context: Context): ChatDatabase {
        return Room.databaseBuilder(
            context,
            ChatDatabase::class.java,
            "chat_database"
        )
        .addMigrations(*getAllMigrations())
        .fallbackToDestructiveMigration()
        .build()
    }
    
    @Provides
    fun provideMessageDao(database: ChatDatabase): MessageDao = database.messageDao()
    
    @Provides
    fun provideChatDao(database: ChatDatabase): ChatDao = database.chatDao()
    
    @Provides
    fun provideUserDao(database: ChatDatabase): UserDao = database.userDao()
}</code></pre>
        </div>

        <h3>üèõÔ∏è Repository Pattern con DI</h3>
        <p>Los repositorios se vuelven s√∫per limpios con inyecci√≥n de dependencias:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">RepositoryModule.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Module
@InstallIn(SingletonComponent::class)
abstract class RepositoryModule {
    
    @Binds
    abstract fun bindChatRepository(
        chatRepositoryImpl: ChatRepositoryImpl
    ): ChatRepository
    
    @Binds
    abstract fun bindMessageRepository(
        messageRepositoryImpl: MessageRepositoryImpl
    ): MessageRepository
    
    @Binds
    abstract fun bindUserRepository(
        userRepositoryImpl: UserRepositoryImpl
    ): UserRepository
    
    @Binds
    abstract fun bindAuthRepository(
        authRepositoryImpl: AuthRepositoryImpl
    ): AuthRepository
}</code></pre>
        </div>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">ChatRepositoryImpl.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Singleton
class ChatRepositoryImpl @Inject constructor(
    private val chatApiService: ChatApiService,
    private val chatDao: ChatDao,
    private val messageDao: MessageDao,
    private val userPreferences: UserPreferences,
    @IoDispatcher private val ioDispatcher: CoroutineDispatcher
) : ChatRepository {
    
    override suspend fun getChats(): Flow<List<Chat>> = withContext(ioDispatcher) {
        // Implementaci√≥n que combina datos locales y remotos
        combine(
            chatDao.getAllChats(),
            getChatsFromNetwork()
        ) { localChats, networkChats ->
            mergeChats(localChats, networkChats)
        }
    }
    
    override suspend fun sendMessage(chatId: String, message: String): Result<Message> {
        return withContext(ioDispatcher) {
            try {
                val result = chatApiService.sendMessage(
                    SendMessageRequest(chatId, message, userPreferences.userId)
                )
                messageDao.insertMessage(result.toLocalMessage())
                Result.success(result.toDomainMessage())
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
}</code></pre>
        </div>

        <h2>üéØ Scopes: Controlando el Ciclo de Vida</h2>
        <p>Los scopes determinan <strong>cu√°nto tiempo vive una instancia</strong>. Hilt proporciona scopes optimizados para Android:</p>

        <div class="scopes-section">
          <div class="scope-card singleton">
            <div class="scope-header">
              <h3>üè∞ @Singleton</h3>
              <span class="scope-subtitle">Una instancia para toda la app</span>
            </div>
            <div class="scope-content">
              <h4>Cu√°ndo usar:</h4>
              <ul>
                <li>Repositories que manejan estado global</li>
                <li>Clientes de red (Retrofit, OkHttp)</li>
                <li>Bases de datos</li>
                <li>Preferencias de usuario</li>
              </ul>
              <h4>‚ö†Ô∏è Cuidado con:</h4>
              <ul>
                <li>Memory leaks si referencian Context</li>
                <li>Estado mutable compartido</li>
                <li>Dependencias pesadas innecesarias</li>
              </ul>
            </div>
          </div>

          <div class="scope-card activity">
            <div class="scope-header">
              <h3>üì± @ActivityScoped</h3>
              <span class="scope-subtitle">Vive durante toda la Activity</span>
            </div>
            <div class="scope-content">
              <h4>Cu√°ndo usar:</h4>
              <ul>
                <li>Estado espec√≠fico de la Activity</li>
                <li>Coordinadores de navegaci√≥n</li>
                <li>Manejadores de permisos</li>
                <li>Analytics trackers por pantalla</li>
              </ul>
              <h4>Perfecto para:</h4>
              <ul>
                <li>Chat screen con estado de typing</li>
                <li>Camera controllers</li>
                <li>Audio players por activity</li>
              </ul>
            </div>
          </div>

          <div class="scope-card viewmodel">
            <div class="scope-header">
              <h3>üß† @ViewModelScoped</h3>
              <span class="scope-subtitle">Ligado al ciclo de vida del ViewModel</span>
            </div>
            <div class="scope-content">
              <h4>Cu√°ndo usar:</h4>
              <ul>
                <li>Use cases espec√≠ficos del ViewModel</li>
                <li>Estado temporal de pantalla</li>
                <li>Validadores de formularios</li>
                <li>Transformadores de datos de UI</li>
              </ul>
              <h4>Ventajas:</h4>
              <ul>
                <li>Sobrevive a configuration changes</li>
                <li>Se limpia autom√°ticamente</li>
                <li>Perfecto para state management</li>
              </ul>
            </div>
          </div>
        </div>

        <h3>üîß Scopes Customizados: Tu Propia L√≥gica</h3>
        <p>Puedes crear tus propios scopes para casos espec√≠ficos:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">CustomScopes.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">// Scope personalizado para features
@Scope
@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
annotation class FeatureScoped

// Componente personalizado para chat feature
@FeatureScoped
@DefineComponent(parent = SingletonComponent::class)
interface ChatFeatureComponent {
    
    @DefineComponent.Builder
    interface Builder {
        fun setChatId(@BindsInstance chatId: String): Builder
        fun build(): ChatFeatureComponent
    }
}

// M√≥dulo que usa el scope personalizado
@Module
@InstallIn(ChatFeatureComponent::class)
object ChatFeatureModule {
    
    @Provides
    @FeatureScoped
    fun provideChatStateMachine(chatId: String): ChatStateMachine {
        return ChatStateMachine(chatId)
    }
}</code></pre>
        </div>

        <h2>üß™ Testing con Dependencias Inyectadas</h2>
        <p>La verdadera magia de DI se ve en testing. Puedes mockear cualquier dependencia f√°cilmente:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">ChatViewModelTest.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@HiltAndroidTest
class ChatViewModelTest {
    
    @get:Rule
    var hiltRule = HiltAndroidRule(this)
    
    @BindValue
    @JvmField
    val mockChatRepository: ChatRepository = mockk()
    
    @BindValue
    @JvmField  
    val mockMessageRepository: MessageRepository = mockk()
    
    private lateinit var viewModel: ChatViewModel
    
    @Before
    fun setup() {
        hiltRule.inject()
        
        // Configurar mocks
        every { mockChatRepository.getChatById(any()) } returns flowOf(sampleChat)
        every { mockMessageRepository.getMessages(any()) } returns flowOf(sampleMessages)
        
        viewModel = ChatViewModel(mockChatRepository, mockMessageRepository)
    }
    
    @Test
    fun `when sending message then repository is called with correct params`() = runTest {
        // Given
        val message = "Hello World!"
        val chatId = "chat_123"
        
        // When
        viewModel.sendMessage(chatId, message)
        advanceUntilIdle()
        
        // Then
        verify { mockMessageRepository.sendMessage(chatId, message) }
        assertThat(viewModel.uiState.value.isSending).isFalse()
    }
}</code></pre>
        </div>

        <h2>üîç Alternativas: Koin y Manual DI</h2>
        <p>Aunque Hilt es incre√≠ble, vale la pena conocer las alternativas:</p>

        <div class="alternatives-section">
          <div class="alternative-card koin">
            <div class="alternative-header">
              <h3>ü•ù Koin</h3>
              <span class="alternative-subtitle">DI ligero y pragm√°tico</span>
            </div>
            <div class="alternative-content">
              <h4>‚úÖ Pros:</h4>
              <ul>
                <li><strong>Simplicidad extrema:</strong> DSL muy intuitivo</li>
                <li><strong>Kotlin-first:</strong> Dise√±ado espec√≠ficamente para Kotlin</li>
                <li><strong>Runtime resolution:</strong> Flexibilidad m√°xima</li>
                <li><strong>Curva de aprendizaje suave:</strong> F√°cil de entender</li>
              </ul>
              <h4>‚ùå Contras:</h4>
              <ul>
                <li>Runtime errors vs compile-time en Dagger</li>
                <li>Performance ligeramente inferior</li>
                <li>Menos tooling y debugging</li>
              </ul>
            </div>
          </div>

          <div class="alternative-card manual">
            <div class="alternative-header">
              <h3>üõ†Ô∏è Manual DI</h3>
              <span class="alternative-subtitle">Control total, responsabilidad total</span>
            </div>
            <div class="alternative-content">
              <h4>‚úÖ Cu√°ndo considerar:</h4>
              <ul>
                <li>Apps muy peque√±as con pocas dependencias</li>
                <li>Proyectos educativos para entender DI</li>
                <li>Control total sobre la construcci√≥n</li>
                <li>Sin dependencies adicionales</li>
              </ul>
              <h4>‚ùå Problem√°tico para:</h4>
              <ul>
                <li>Apps complejas con muchas dependencias</li>
                <li>Equipos grandes</li>
                <li>Testing extensivo</li>
                <li>Mantenimiento a largo plazo</li>
              </ul>
            </div>
          </div>
        </div>

        <h3>ü•ù Ejemplo R√°pido con Koin</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">KoinModule.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">val networkModule = module {
    single { 
        OkHttpClient.Builder()
            .addInterceptor(get<AuthInterceptor>())
            .build() 
    }
    
    single { 
        Retrofit.Builder()
            .baseUrl(BuildConfig.API_URL)
            .client(get())
            .build() 
    }
    
    single { get<Retrofit>().create<ChatApiService>() }
}

val repositoryModule = module {
    single<ChatRepository> { ChatRepositoryImpl(get(), get()) }
}

val viewModelModule = module {
    viewModel { ChatViewModel(get()) }
}

// En Application
class ChatApp : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidContext(this@ChatApp)
            modules(networkModule, repositoryModule, viewModelModule)
        }
    }
}</code></pre>
        </div>

        <h2>üöÄ Arquitectura Avanzada: Dagger Puro para Casos Complejos</h2>
        <p>Para proyectos enterprise que necesitan control granular, Dagger puro sigue siendo el rey:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">AppComponent.kt - Dagger Puro</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Singleton
@Component(modules = [
    AppModule::class,
    NetworkModule::class,
    DatabaseModule::class,
    RepositoryModule::class
])
interface AppComponent {
    
    fun inject(application: ChatApplication)
    
    // Factory para subcomponentes
    fun chatComponentBuilder(): ChatComponent.Builder
    
    @Component.Factory
    interface Factory {
        fun create(@BindsInstance context: Context): AppComponent
    }
}

// Subcomponente para feature espec√≠fico
@ChatFeatureScope
@Subcomponent(modules = [ChatModule::class])
interface ChatComponent {
    
    fun inject(chatActivity: ChatActivity)
    fun inject(chatFragment: ChatFragment)
    
    @Subcomponent.Builder
    interface Builder {
        @BindsInstance
        fun chatId(chatId: String): Builder
        
        fun build(): ChatComponent
    }
}</code></pre>
        </div>

        <h2>üéØ Best Practices: Convi√©rtete en un DI Ninja</h2>
        
        <div class="best-practices-section">
          <div class="practice-card">
            <h3>üé™ 1. Organizaci√≥n de M√≥dulos</h3>
            <div class="practice-content">
              <h4>Por Responsabilidad:</h4>
              <pre><code>üìÅ di/
‚îú‚îÄ‚îÄ üìÑ NetworkModule.kt       # Retrofit, OkHttp
‚îú‚îÄ‚îÄ üìÑ DatabaseModule.kt      # Room, DAOs  
‚îú‚îÄ‚îÄ üìÑ RepositoryModule.kt    # Repository bindings
‚îú‚îÄ‚îÄ üìÑ UseCaseModule.kt       # Business logic
‚îî‚îÄ‚îÄ üìÑ ViewModelModule.kt     # ViewModel factories</code></pre>
            </div>
          </div>

          <div class="practice-card">
            <h3>üè∑Ô∏è 2. Qualifiers Inteligentes</h3>
            <div class="practice-content">
              <div class="code-block">
                <pre><code class="language-kotlin">@Qualifier
@Retention(AnnotationRetention.BINARY)
annotation class AuthRetrofit

@Qualifier  
@Retention(AnnotationRetention.BINARY)
annotation class ChatRetrofit

// Uso
@Provides
@AuthRetrofit
fun provideAuthRetrofit(): Retrofit = ...

@Provides
@ChatRetrofit  
fun provideChatRetrofit(): Retrofit = ...</code></pre>
              </div>
            </div>
          </div>

          <div class="practice-card">
            <h3>‚ö° 3. Lazy Injection</h3>
            <div class="practice-content">
              <div class="code-block">
                <pre><code class="language-kotlin">class ChatRepository @Inject constructor(
    private val apiService: ChatApiService,
    private val database: Lazy<ChatDatabase>, // ‚ö° Lazy loading
    @IoDispatcher private val dispatcher: CoroutineDispatcher
) {
    
    private val chatDao by lazy { database.get().chatDao() }
}</code></pre>
              </div>
            </div>
          </div>

          <div class="practice-card">
            <h3>üîç 4. Provider Pattern</h3>
            <div class="practice-content">
              <div class="code-block">
                <pre><code class="language-kotlin">class ChatViewModel @Inject constructor(
    private val chatRepositoryProvider: Provider<ChatRepository>
) {
    
    fun switchToPrivateMode() {
        // Obtener nueva instancia cuando sea necesario
        val privateRepo = chatRepositoryProvider.get()
        // ...
    }
}</code></pre>
              </div>
            </div>
          </div>
        </div>

        <h2>üèÉ‚Äç‚ôÄÔ∏è Migraci√≥n: De Manual a Hilt paso a paso</h2>
        <p>Si tienes un proyecto existente, aqu√≠ tienes una estrategia de migraci√≥n gradual:</p>

        <div class="migration-steps">
          <div class="migration-step">
            <div class="step-number">1</div>
            <div class="step-content">
              <h4>Prepara la Base</h4>
              <ul>
                <li>A√±ade dependencias de Hilt</li>
                <li>Anota tu Application con @HiltAndroidApp</li>
                <li>Identifica dependencies actuales</li>
              </ul>
            </div>
          </div>

          <div class="migration-step">
            <div class="step-number">2</div>
            <div class="step-content">
              <h4>Migra Capa por Capa</h4>
              <ul>
                <li>Comienza con Repositories (menos dependencias)</li>
                <li>Luego Use Cases</li>
                <li>Finalmente ViewModels</li>
              </ul>
            </div>
          </div>

          <div class="migration-step">
            <div class="step-number">3</div>
            <div class="step-content">
              <h4>Reemplaza Factory Manual</h4>
              <ul>
                <li>Elimina factory classes custom</li>
                <li>Usa @Inject constructors</li>
                <li>Convierte singletons manuales</li>
              </ul>
            </div>
          </div>

          <div class="migration-step">
            <div class="step-number">4</div>
            <div class="step-content">
              <h4>Optimiza y Limpia</h4>
              <ul>
                <li>Revisa scopes para optimizar memoria</li>
                <li>Elimina c√≥digo deprecated</li>
                <li>A√±ade testing con @HiltAndroidTest</li>
              </ul>
            </div>
          </div>
        </div>

        <h2>üöÄ Pr√≥ximos Pasos: Tu Roadmap hacia la Maestr√≠a en DI</h2>
        
        <div class="roadmap-section">
          <h3>üìö Para dominar completamente la Inyecci√≥n de Dependencias</h3>
          <ol class="roadmap-list">
            <li><strong>Practica con proyectos reales:</strong> Refactoriza una app existente migrando a Hilt gradualmente</li>
            <li><strong>Explora Dagger avanzado:</strong> Aprende subcomponentes, multibinding y custom scopes</li>
            <li><strong>Domina el testing:</strong> Crea tests exhaustivos usando @HiltAndroidTest y mocking</li>
            <li><strong>Optimizaci√≥n de performance:</strong> Analiza el grafo de dependencias para optimizar memoria</li>
            <li><strong>Arquitecturas multi-m√≥dulo:</strong> Implementa DI en proyectos con m√∫ltiples m√≥dulos Gradle</li>
            <li><strong>Casos edge:</strong> Maneja dependencias circulares, lazy loading y provider patterns</li>
          </ol>
        </div>

        <div class="conclusion-box">
          <h3>üéØ Conclusi√≥n: Tu Superpoder de Desarrollo</h3>
          <p>La inyecci√≥n de dependencias no es solo un patr√≥n t√©cnico, es tu <strong>superpoder secreto</strong> para escribir c√≥digo Android de nivel enterprise. Con Hilt tienes la productividad, con Dagger tienes el control total, y con el conocimiento de ambos, tienes <strong>flexibilidad infinita</strong>.</p>
          
          <p>Recuerda: empieza simple con Hilt para la mayor√≠a de casos, pero ten Dagger en tu toolkit para cuando necesites el poder absoluto. <strong>Tu futuro yo te agradecer√°</strong> cuando tengas que mantener c√≥digo en producci√≥n con millones de usuarios. üöÄ</p>
        </div>

        <div class="article-footer">
          <div class="tags">
            <span class="tag">Android</span>
            <span class="tag">Kotlin</span>
            <span class="tag">Dagger</span>
            <span class="tag">Hilt</span>
            <span class="tag">Dependency Injection</span>
            <span class="tag">Architecture</span>
            <span class="tag">Testing</span>
            <span class="tag">Modules</span>
            <span class="tag">Scopes</span>
            <span class="tag">Clean Code</span>
          </div>
          
          <div class="article-navigation">
            <a href="blog-clean-architecture.html" class="nav-button">‚Üê Clean Architecture</a>
            <a href="blog-mvvm-architecture.html" class="nav-button">Siguiente: MVVM Architecture ‚Üí</a>
          </div>
          
          <div class="share-section">
            <h4>¬øTe gust√≥ este art√≠culo?</h4>
            <p>Comp√°rtelo con otros desarrolladores Android</p>
            <div class="share-buttons">
              <button class="share-btn twitter">üê¶ Twitter</button>
              <button class="share-btn linkedin">üíº LinkedIn</button>
              <button class="share-btn whatsapp">üí¨ WhatsApp</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </article>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-section">
          <h3>ArceApps</h3>
          <p>Desarrollando el futuro de las aplicaciones m√≥viles con c√≥digo limpio y arquitecturas s√≥lidas.</p>
        </div>
        <div class="footer-section">
          <h4>Enlaces R√°pidos</h4>
          <ul>
            <li><a href="../index.html">Inicio</a></li>
            <li><a href="../about.html">About</a></li>
            <li><a href="../portfolio.html">Portfolio</a></li>
            <li><a href="../blog.html">Blog</a></li>
          </ul>
        </div>
        <div class="footer-section">
          <h4>Categor√≠as</h4>
          <ul>
            <li><a href="../blog.html#android">Desarrollo Android</a></li>
            <li><a href="../blog.html#devops">DevOps Mobile</a></li>
            <li><a href="../blog.html#architecture">Arquitectura</a></li>
          </ul>
        </div>
      </div>
      <div class="footer-bottom">
        <p>&copy; 2025 ArceApps. Todos los derechos reservados.</p>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>