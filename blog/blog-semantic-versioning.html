<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Versionado Sem√°ntico en Android - ArceApps Blog</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-logo">
        <h3><a href="../index.html">ArceApps</a></h3>
      </div>
      <div class="nav-toggle" id="nav-toggle">
        <span class="bar"></span>
        <span class="bar"></span>
        <span class="bar"></span>
      </div>
      <ul class="nav-menu" id="nav-menu">
        <li class="nav-item">
          <a href="../index.html" class="nav-link">Inicio</a>
        </li>
        <li class="nav-item">
          <a href="../about.html" class="nav-link">About</a>
        </li>
        <li class="nav-item">
          <a href="../portfolio.html" class="nav-link">Portfolio</a>
        </li>
        <li class="nav-item">
          <a href="../blog.html" class="nav-link active">Blog</a>
        </li>
        <li class="nav-item">
          <a href="../privacy-policy-en.html" class="nav-link">Pol√≠tica de privacidad</a>
        </li>
      </ul>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">25 de agosto de 2025</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>Versionado Sem√°ntico en Android: Mejores Pr√°cticas para Desarrolladores</h1>
        <p class="article-subtitle">Una gu√≠a completa sobre c√≥mo implementar versionado sem√°ntico en aplicaciones Android, desde versionCode hasta Google Play Store</p>
        <div class="article-image">
          <img src="../images/placeholder-article-versioning.svg" alt="Versionado Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>üéØ Introducci√≥n al Versionado Sem√°ntico</h2>
        <p>El <strong>versionado sem√°ntico (Semantic Versioning o SemVer)</strong> es mucho m√°s que simplemente asignar n√∫meros a las releases de tu aplicaci√≥n. Es un contrato de comunicaci√≥n entre desarrolladores y usuarios, una promesa de estabilidad y una herramienta fundamental para gestionar la evoluci√≥n del software de manera predecible y profesional.</p>

        <p>En el desarrollo moderno de software, especialmente en Android donde millones de usuarios dependen de la estabilidad de sus aplicaciones, el versionado sem√°ntico se ha convertido en el <strong>est√°ndar de facto</strong> de la industria. Fue creado por Tom Preston-Werner (co-fundador de GitHub) en 2013 y desde entonces ha sido adoptado por proyectos de todos los tama√±os, desde peque√±as startups hasta gigantes tecnol√≥gicos como Google, Facebook y Microsoft.</p>

        <div class="info-box">
          <h3>üìö ¬øQu√© es el Versionado Sem√°ntico?</h3>
          <p>El versionado sem√°ntico es una especificaci√≥n formal que define c√≥mo deben numerarse y incrementarse las versiones del software. Utiliza un formato de tres n√∫meros separados por puntos: <code>MAJOR.MINOR.PATCH</code>, donde cada n√∫mero tiene un significado espec√≠fico y bien definido:</p>
          <ul>
            <li><strong>MAJOR (X.0.0)</strong>: Se incrementa cuando realizas cambios incompatibles en la API o funcionalidad que rompen la compatibilidad hacia atr√°s</li>
            <li><strong>MINOR (0.X.0)</strong>: Se incrementa cuando a√±ades funcionalidad nueva de manera compatible con versiones anteriores</li>
            <li><strong>PATCH (0.0.X)</strong>: Se incrementa cuando realizas correcciones de bugs compatibles hacia atr√°s</li>
          </ul>
        </div>

        <h3>üèõÔ∏è Historia y Contexto del Versionado</h3>
        <p>Antes del versionado sem√°ntico, cada proyecto segu√≠a sus propias convenciones arbitrarias, creando confusi√≥n y dificultad para gestionar dependencias. Algunos usaban fechas (2025.01.15), otros n√∫meros secuenciales simples (v1, v2, v3), y otros sistemas completamente aleatorios. Esta falta de est√°ndares llevaba a problemas conocidos como "dependency hell" (infierno de dependencias), donde actualizar una librer√≠a pod√≠a romper toda tu aplicaci√≥n sin previo aviso.</p>

        <p>El versionado sem√°ntico resolvi√≥ estos problemas estableciendo un conjunto claro de reglas que permiten a los desarrolladores comunicar el impacto de sus cambios a trav√©s de los n√∫meros de versi√≥n. Hoy en d√≠a, pr√°cticamente todas las librer√≠as y frameworks modernos utilizan SemVer, incluyendo Android Jetpack, Kotlin, y la mayor√≠a de dependencias que usas en tu <code>build.gradle</code>.</p>

        <h3>üéØ ¬øPor qu√© es Crucial en Android?</h3>
        <p>En el ecosistema Android, el versionado sem√°ntico cobra una importancia especial debido a m√∫ltiples factores √∫nicos de la plataforma m√≥vil:</p>

        <div class="android-versioning-challenges">
          <h4>Desaf√≠os √önicos de Android:</h4>
          
          <div class="challenge-card">
            <h5>1. üåç Distribuci√≥n Global y Fragmentaci√≥n</h5>
            <p>Tu aplicaci√≥n puede estar instalada en millones de dispositivos con diferentes versiones de Android, distintas capacidades de hardware, y diversos niveles de actualizaci√≥n. Un sistema de versionado claro ayuda a:</p>
            <ul>
              <li>Gestionar la compatibilidad con diferentes versiones de Android (desde API 21 hasta 34+)</li>
              <li>Comunicar claramente qu√© dispositivos soporta cada versi√≥n</li>
              <li>Planificar la obsolescencia de versiones antiguas de manera transparente</li>
            </ul>
          </div>

          <div class="challenge-card">
            <h5>2. üì± Actualizaciones Progresivas</h5>
            <p>Google Play Store permite lanzamientos escalonados (staged rollouts) donde una nueva versi√≥n se libera gradualmente al 5%, 10%, 50% o 100% de usuarios. Un versionado claro permite:</p>
            <ul>
              <li>Identificar r√°pidamente qu√© usuarios tienen qu√© versi√≥n</li>
              <li>Realizar rollbacks efectivos si se detectan problemas</li>
              <li>Analizar m√©tricas y crashes por versi√≥n espec√≠fica</li>
              <li>Mantener m√∫ltiples versiones activas simult√°neamente</li>
            </ul>
          </div>

          <div class="challenge-card">
            <h5>3. üîÑ Sistema Dual de Versionado</h5>
            <p>Android maneja dos tipos de versiones diferentes que deben coordinarse cuidadosamente:</p>
            <ul>
              <li><strong>versionName (String)</strong>: Es la versi√≥n legible que ven los usuarios en Google Play Store (ej: "2.1.3"). Debe seguir SemVer para comunicar claramente los cambios.</li>
              <li><strong>versionCode (Integer)</strong>: Es un n√∫mero entero interno y monot√≥nicamente creciente que Google Play usa para determinar qu√© versi√≥n es m√°s reciente. Debe incrementarse en cada release.</li>
            </ul>
            <p>La relaci√≥n entre estos dos n√∫meros es crucial: un <code>versionCode</code> mal configurado puede impedir que los usuarios reciban actualizaciones, mientras que un <code>versionName</code> confuso puede llevar a los usuarios a no entender qu√© ha cambiado.</p>
          </div>

          <div class="challenge-card">
            <h5>4. üíæ Persistencia de Datos y Migraciones</h5>
            <p>Las aplicaciones Android almacenan datos localmente (Room, SharedPreferences, archivos). El versionado es esencial para:</p>
            <ul>
              <li>Gestionar migraciones de base de datos entre versiones</li>
              <li>Mantener compatibilidad con datos guardados en versiones antiguas</li>
              <li>Planificar la limpieza de c√≥digo legacy bas√°ndose en adoption rates</li>
            </ul>
          </div>

          <div class="challenge-card">
            <h5>5. üìä Analytics y Debugging</h5>
            <p>Herramientas como Firebase Crashlytics, Analytics y Play Console organizan datos por versi√≥n. Un sistema claro permite:</p>
            <ul>
              <li>Identificar bugs espec√≠ficos de una versi√≥n</li>
              <li>Comparar m√©tricas entre versiones (crash rates, retention, engagement)</li>
              <li>Tomar decisiones basadas en datos sobre cu√°ndo deprecar versiones antiguas</li>
            </ul>
          </div>
        </div>

        <h3>üîç El Sistema Dual: versionName vs versionCode</h3>
        <p>Entender la diferencia entre estos dos conceptos es fundamental para cualquier desarrollador Android:</p>

        <div class="version-comparison">
          <div class="version-type">
            <h4>versionName (Usuario-facing)</h4>
            <ul>
              <li><strong>Tipo:</strong> String</li>
              <li><strong>Prop√≥sito:</strong> Comunicaci√≥n con usuarios</li>
              <li><strong>Formato:</strong> "MAJOR.MINOR.PATCH" (SemVer)</li>
              <li><strong>Ejemplo:</strong> "2.3.1"</li>
              <li><strong>Visible en:</strong> Google Play Store, About screen</li>
              <li><strong>Puede decrecer:</strong> T√©cnicamente s√≠, pero no recomendado</li>
              <li><strong>Impacto en updates:</strong> Ninguno, solo informativo</li>
            </ul>
          </div>

          <div class="version-type">
            <h4>versionCode (Sistema interno)</h4>
            <ul>
              <li><strong>Tipo:</strong> Integer positivo</li>
              <li><strong>Prop√≥sito:</strong> Control de actualizaciones del sistema</li>
              <li><strong>Formato:</strong> N√∫mero entero secuencial</li>
              <li><strong>Ejemplo:</strong> 20301</li>
              <li><strong>Visible en:</strong> Solo para desarrolladores</li>
              <li><strong>Debe ser monot√≥nico:</strong> Siempre creciente</li>
              <li><strong>Impacto en updates:</strong> CR√çTICO - determina si hay actualizaci√≥n disponible</li>
            </ul>
          </div>
        </div>

        <div class="warning-box">
          <h4>‚ö†Ô∏è Advertencia Importante</h4>
          <p>Un error com√∫n es publicar una nueva versi√≥n con un <code>versionCode</code> menor o igual al anterior. Esto har√° que Google Play Store <strong>rechace la subida</strong> o que los usuarios existentes <strong>no vean la actualizaci√≥n</strong>. El versionCode debe incrementarse siempre, sin excepciones.</p>
        </div>

        <h2>‚öôÔ∏è Configuraci√≥n Detallada en build.gradle</h2>
        <p>La configuraci√≥n del versionado en Android se realiza en el archivo <code>build.gradle</code> (o <code>build.gradle.kts</code> para Kotlin DSL) dentro del m√≥dulo de la aplicaci√≥n. Esta configuraci√≥n es el coraz√≥n del sistema de versionado y debe establecerse cuidadosamente desde el inicio del proyecto.</p>

        <h3>Configuraci√≥n B√°sica</h3>
        <div class="code-block">
          <pre><code>// app/build.gradle
android {
    compileSdk 34
    
    defaultConfig {
        applicationId "com.arceapps.miapp"
        minSdk 24
        targetSdk 34
        
        // Versi√≥n num√©rica interna para Google Play
        versionCode 10203  // Formato: MMmmpp (Major Minor Patch)
        
        // Versi√≥n legible para usuarios
        versionName "1.2.3"  // Formato SemVer: MAJOR.MINOR.PATCH
        
        // Opcional: Informaci√≥n adicional de build
        buildConfigField "String", "BUILD_TIME", "\"${buildTime()}\""
        buildConfigField "String", "GIT_SHA", "\"${gitSha()}\""
    }
}</code></pre>
        </div>

        <h3>üéØ Estrategias de versionCode: An√°lisis Completo</h3>
        <p>El <code>versionCode</code> es cr√≠tico porque Google Play lo usa para determinar qu√© APK/AAB es m√°s reciente. Existen varias estrategias probadas en la industria, cada una con sus ventajas y desventajas:</p>

        <div class="strategies-comparison">
          <h4>1. Estrategia Simple Secuencial</h4>
          <p>La m√°s b√°sica: simplemente incrementa el n√∫mero en 1 con cada release.</p>
          <div class="code-block">
            <pre><code>versionCode 1  // Primera release
versionCode 2  // Segunda release
versionCode 3  // Tercera release
// etc...</code></pre>
          </div>
          <div class="pros-cons">
            <div class="pros">
              <h5>‚úÖ Ventajas:</h5>
              <ul>
                <li>Extremadamente simple</li>
                <li>No hay riesgo de colisiones</li>
                <li>F√°cil de automatizar</li>
              </ul>
            </div>
            <div class="cons">
              <h5>‚ùå Desventajas:</h5>
              <ul>
                <li>No hay correlaci√≥n con versionName</li>
                <li>Imposible saber la versi√≥n sem√°ntica desde el c√≥digo</li>
                <li>Dif√≠cil gestionar releases paralelas (m√∫ltiples flavors/ABIs)</li>
              </ul>
            </div>
          </div>

          <h4>2. Estrategia Derivada de SemVer (MMmmpp)</h4>
          <p>Codifica directamente el versionName en el versionCode usando un formato de 6 d√≠gitos.</p>
          <div class="code-block">
            <pre><code>// Para versionName "1.2.3"
versionCode = 10203  // 01-02-03

// Para versionName "2.15.42"
versionCode = 21542  // 02-15-42

// F√≥rmula:
versionCode = (MAJOR * 10000) + (MINOR * 100) + PATCH</code></pre>
          </div>
          <div class="pros-cons">
            <div class="pros">
              <h5>‚úÖ Ventajas:</h5>
              <ul>
                <li>Correlaci√≥n directa con versionName</li>
                <li>F√°cil saber la versi√≥n sem√°ntica desde logs</li>
                <li>Intuitivo para el equipo de desarrollo</li>
              </ul>
            </div>
            <div class="cons">
              <h5>‚ùå Desventajas:</h5>
              <ul>
                <li>Limitado a 99 para cada componente</li>
                <li>No soporta m√∫ltiples ABIs/flavors sin modificaci√≥n</li>
                <li>Puede quedarse sin espacio en proyectos longevos</li>
              </ul>
            </div>
          </div>

          <h4>3. Estrategia con Timestamp</h4>
          <p>Usa el tiempo de build como versionCode, garantizando unicidad autom√°tica.</p>
          <div class="code-block">
            <pre><code>// Usar timestamp de Unix en segundos (√∫ltimos 9 d√≠gitos)
def timestamp = (System.currentTimeMillis() / 1000).toInteger()
versionCode = timestamp % 1000000000  // √öltimos 9 d√≠gitos

// Ejemplo: 1640995200 -> 640995200</code></pre>
          </div>
          <div class="pros-cons">
            <div class="pros">
              <h5>‚úÖ Ventajas:</h5>
              <ul>
                <li>Autom√°tico, no requiere gesti√≥n manual</li>
                <li>Garantiza unicidad absoluta</li>
                <li>√ötil para builds frecuentes en CI/CD</li>
              </ul>
            </div>
            <div class="cons">
              <h5>‚ùå Desventajas:</h5>
              <ul>
                <li>Sin correlaci√≥n con versi√≥n sem√°ntica</li>
                <li>N√∫meros muy grandes, dif√≠ciles de recordar</li>
                <li>Puede causar problemas con l√≠mites de 32-bit Integer</li>
              </ul>
            </div>
          </div>

          <h4>4. Estrategia H√≠brida (Recomendada para Producci√≥n)</h4>
          <p>Combina versionado sem√°ntico con espacio para variantes (ABI, flavor, etc.)</p>
          <div class="code-block">
            <pre><code>// Formato: MMmmppXY
// MM: Major (2 d√≠gitos)
// mm: Minor (2 d√≠gitos)  
// pp: Patch (2 d√≠gitos)
// X: Flavor (1 d√≠gito: 0=free, 1=pro, etc.)
// Y: ABI (1 d√≠gito: 0=universal, 1=armeabi-v7a, 2=arm64-v8a, etc.)

// Ejemplo para version "2.3.1" flavor pro, ABI arm64-v8a:
versionCode = 2030112  // 02-03-01-1-2

// F√≥rmula completa:
def major = 2
def minor = 3
def patch = 1
def flavor = 1  // pro
def abi = 2     // arm64-v8a

versionCode = (major * 100000) + (minor * 1000) + (patch * 10) + (flavor * 1) + abi</code></pre>
          </div>
          <div class="pros-cons">
            <div class="pros">
              <h5>‚úÖ Ventajas:</h5>
              <ul>
                <li>Soporta m√∫ltiples variantes simult√°neamente</li>
                <li>Mantiene correlaci√≥n con versionName</li>
                <li>Escalable para proyectos grandes</li>
                <li>Compatible con App Bundles y APK splits</li>
              </ul>
            </div>
            <div class="cons">
              <h5>‚ùå Desventajas:</h5>
              <ul>
                <li>M√°s complejo de implementar</li>
                <li>Requiere documentaci√≥n clara del formato</li>
                <li>Limitaciones en el tama√±o de cada componente</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="best-practice-box">
          <h4>üí° Recomendaci√≥n para tu Proyecto</h4>
          <p><strong>Proyectos peque√±os/medianos (1-2 flavors):</strong> Usa la estrategia MMmmpp (opci√≥n 2). Es simple, intuitiva y suficiente para la mayor√≠a de casos.</p>
          <p><strong>Proyectos grandes con m√∫ltiples variantes:</strong> Implementa la estrategia h√≠brida (opci√≥n 4) desde el inicio. Te ahorrar√° dolores de cabeza cuando necesites gestionar m√∫ltiples ABIs o flavors.</p>
          <p><strong>Builds de desarrollo/testing:</strong> Considera usar timestamps para builds internos, pero siempre mant√©n el versionado sem√°ntico para producci√≥n.</p>
        </div>

        <h2>ü§ñ Automatizaci√≥n Avanzada con Gradle</h2>
        <p>La automatizaci√≥n del versionado es crucial para mantener la consistencia y reducir errores humanos. Gradle nos proporciona un sistema poderoso y flexible para gestionar versiones autom√°ticamente.</p>

        <h3>M√©todo 1: Archivo de Propiedades (Simple y Efectivo)</h3>
        <p>Este es el m√©todo m√°s simple y recomendado para la mayor√≠a de proyectos. Mantiene las versiones en un archivo separado que es f√°cil de leer, modificar y automatizar.</p>
        
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">version.properties</span>
          </div>
          <pre><code># Semantic Version Components
VERSION_MAJOR=2
VERSION_MINOR=3
VERSION_PATCH=1

# Build metadata (opcional)
BUILD_NUMBER=0
VERSION_SUFFIX=</code></pre>
        </div>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">app/build.gradle</span>
          </div>
          <pre><code>// Cargar propiedades de versi√≥n
def versionPropsFile = file('../version.properties')
if (!versionPropsFile.canRead()) {
    throw new GradleException("No se puede leer version.properties")
}

def versionProps = new Properties()
versionProps.load(new FileInputStream(versionPropsFile))

// Extraer componentes de versi√≥n
def vMajor = versionProps['VERSION_MAJOR'].toInteger()
def vMinor = versionProps['VERSION_MINOR'].toInteger()
def vPatch = versionProps['VERSION_PATCH'].toInteger()
def vBuild = versionProps['BUILD_NUMBER']?.toInteger() ?: 0
def vSuffix = versionProps['VERSION_SUFFIX'] ?: ''

// Calcular versionCode (formato MMmmpp)
def calculatedVersionCode = (vMajor * 10000) + (vMinor * 100) + vPatch

// Construir versionName
def calculatedVersionName = "${vMajor}.${vMinor}.${vPatch}"
if (vSuffix) {
    calculatedVersionName += "-${vSuffix}"
}

android {
    defaultConfig {
        versionCode calculatedVersionCode
        versionName calculatedVersionName
        
        // A√±adir informaci√≥n de build a BuildConfig
        buildConfigField "int", "VERSION_MAJOR", "$vMajor"
        buildConfigField "int", "VERSION_MINOR", "$vMinor"
        buildConfigField "int", "VERSION_PATCH", "$vPatch"
        buildConfigField "String", "VERSION_NAME_FULL", "\"${calculatedVersionName}\""
    }
}</code></pre>
        </div>

        <h3>M√©todo 2: Gradle Tasks para Incrementar Versiones</h3>
        <p>Crea tasks personalizadas de Gradle para incrementar autom√°ticamente cada componente de la versi√≥n:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">app/build.gradle - Tasks de Versionado</span>
          </div>
          <pre><code>// Task para incrementar PATCH version
task incrementPatch {
    doLast {
        def versionPropsFile = file('../version.properties')
        def versionProps = new Properties()
        versionProps.load(new FileInputStream(versionPropsFile))
        
        def patch = versionProps['VERSION_PATCH'].toInteger() + 1
        versionProps['VERSION_PATCH'] = patch.toString()
        
        versionProps.store(versionPropsFile.newWriter(), null)
        println "Version patch incremented to ${patch}"
    }
}

// Task para incrementar MINOR version (resetea PATCH a 0)
task incrementMinor {
    doLast {
        def versionPropsFile = file('../version.properties')
        def versionProps = new Properties()
        versionProps.load(new FileInputStream(versionPropsFile))
        
        def minor = versionProps['VERSION_MINOR'].toInteger() + 1
        versionProps['VERSION_MINOR'] = minor.toString()
        versionProps['VERSION_PATCH'] = '0'
        
        versionProps.store(versionPropsFile.newWriter(), null)
        println "Version minor incremented to ${minor}, patch reset to 0"
    }
}

// Task para incrementar MAJOR version (resetea MINOR y PATCH a 0)
task incrementMajor {
    doLast {
        def versionPropsFile = file('../version.properties')
        def versionProps = new Properties()
        versionProps.load(new FileInputStream(versionPropsFile))
        
        def major = versionProps['VERSION_MAJOR'].toInteger() + 1
        versionProps['VERSION_MAJOR'] = major.toString()
        versionProps['VERSION_MINOR'] = '0'
        versionProps['VERSION_PATCH'] = '0'
        
        versionProps.store(versionPropsFile.newWriter(), null)
        println "Version major incremented to ${major}, minor and patch reset to 0"
    }
}

// Task para establecer suffix de versi√≥n (alpha, beta, rc, etc.)
task setVersionSuffix {
    doLast {
        def suffix = project.hasProperty('suffix') ? project.suffix : ''
        def versionPropsFile = file('../version.properties')
        def versionProps = new Properties()
        versionProps.load(new FileInputStream(versionPropsFile))
        
        versionProps['VERSION_SUFFIX'] = suffix
        
        versionProps.store(versionPropsFile.newWriter(), null)
        println "Version suffix set to '${suffix}'"
    }
}

// Task para mostrar versi√≥n actual
task printVersion {
    doLast {
        println "Current version: ${android.defaultConfig.versionName} (${android.defaultConfig.versionCode})"
    }
}</code></pre>
        </div>

        <div class="usage-examples">
          <h4>üìù Uso de los Tasks:</h4>
          <div class="code-block">
            <pre><code># Incrementar patch (1.2.3 -> 1.2.4)
./gradlew incrementPatch

# Incrementar minor (1.2.3 -> 1.3.0)
./gradlew incrementMinor

# Incrementar major (1.2.3 -> 2.0.0)
./gradlew incrementMajor

# Establecer suffix para beta
./gradlew setVersionSuffix -Psuffix=beta  # Resultado: 1.2.3-beta

# Remover suffix
./gradlew setVersionSuffix -Psuffix=  # Resultado: 1.2.3

# Ver versi√≥n actual
./gradlew printVersion

# Build despu√©s de incrementar
./gradlew incrementPatch assembleRelease</code></pre>
          </div>
        </div>

        <h3>M√©todo 3: Integraci√≥n con Git Tags</h3>
        <p>Una estrategia avanzada es derivar la versi√≥n directamente de los tags de Git, asegurando que el c√≥digo y la versi√≥n est√©n siempre sincronizados:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">app/build.gradle - Versionado basado en Git</span>
          </div>
          <pre><code>import org.gradle.api.GradleException

// Funci√≥n para obtener el √∫ltimo tag de git
def getGitTag() {
    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'describe', '--tags', '--abbrev=0'
            standardOutput = stdout
        }
        return stdout.toString().trim()
    } catch (Exception e) {
        return "0.0.0"
    }
}

// Funci√≥n para obtener el commit count desde el √∫ltimo tag
def getCommitCount() {
    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-list', '--count', 'HEAD'
            standardOutput = stdout
        }
        return stdout.toString().trim().toInteger()
    } catch (Exception e) {
        return 0
    }
}

// Funci√≥n para obtener el SHA corto del commit actual
def getGitSha() {
    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'rev-parse', '--short', 'HEAD'
            standardOutput = stdout
        }
        return stdout.toString().trim()
    } catch (Exception e) {
        return "unknown"
    }
}

// Funci√≥n para verificar si hay cambios sin commitear
def hasUncommittedChanges() {
    try {
        def stdout = new ByteArrayOutputStream()
        exec {
            commandLine 'git', 'status', '--porcelain'
            standardOutput = stdout
        }
        return !stdout.toString().trim().isEmpty()
    } catch (Exception e) {
        return false
    }
}

// Parsear el tag de git
def gitTag = getGitTag()
def versionPattern = /v?(\d+)\.(\d+)\.(\d+)/
def matcher = (gitTag =~ versionPattern)

def vMajor = 0
def vMinor = 0
def vPatch = 0

if (matcher.find()) {
    vMajor = matcher.group(1).toInteger()
    vMinor = matcher.group(2).toInteger()
    vPatch = matcher.group(3).toInteger()
}

// Calcular version code y name
def commitCount = getCommitCount()
def gitSha = getGitSha()
def isDirty = hasUncommittedChanges()

def versionCode = (vMajor * 10000) + (vMinor * 100) + vPatch
def versionName = "${vMajor}.${vMinor}.${vPatch}"

// Si estamos en un commit que no es el tag, a√±adir informaci√≥n adicional
if (commitCount > 0) {
    versionName += "-dev.${commitCount}+${gitSha}"
}
if (isDirty) {
    versionName += ".dirty"
}

android {
    defaultConfig {
        versionCode versionCode
        versionName versionName
        
        buildConfigField "String", "GIT_SHA", "\"${gitSha}\""
        buildConfigField "boolean", "IS_DIRTY_BUILD", "${isDirty}"
    }
}

// Task para crear un nuevo tag
task createVersionTag {
    doLast {
        def newVersion = project.hasProperty('version') ? project.version : null
        if (newVersion == null) {
            throw new GradleException("Version not specified. Use: ./gradlew createVersionTag -Pversion=1.2.3")
        }
        
        if (hasUncommittedChanges()) {
            throw new GradleException("Cannot create tag: You have uncommitted changes")
        }
        
        exec {
            commandLine 'git', 'tag', "-a", "v${newVersion}", "-m", "Version ${newVersion}"
        }
        println "Created tag: v${newVersion}"
        println "Don't forget to push the tag: git push origin v${newVersion}"
    }
}</code></pre>
        </div>

        <div class="workflow-example">
          <h4>üîÑ Workflow Completo con Git Tags:</h4>
          <div class="code-block">
            <pre><code># 1. Desarrollar features en branches
git checkout -b feature/new-login
# ... hacer cambios ...
git commit -m "feat: implement new login screen"

# 2. Merge a main/develop
git checkout main
git merge feature/new-login

# 3. Crear tag para nueva versi√≥n
./gradlew createVersionTag -Pversion=2.1.0

# 4. Push del tag
git push origin v2.1.0

# 5. Build autom√°tico usar√° la versi√≥n del tag
./gradlew assembleRelease
# Output: app-2.1.0-release.apk

# 6. Entre tags, la versi√≥n incluye info de desarrollo
# Ejemplo: 2.1.0-dev.5+a3f9c21 (5 commits despu√©s del tag v2.1.0)</code></pre>
          </div>
        </div>

        <div class="best-practice-box">
          <h4>‚úÖ Ventajas del Versionado con Git Tags:</h4>
          <ul>
            <li><strong>Single Source of Truth:</strong> El repositorio de Git es la √∫nica fuente de verdad para las versiones</li>
            <li><strong>Trazabilidad perfecta:</strong> Cada versi√≥n est√° vinculada a un commit espec√≠fico</li>
            <li><strong>Automatizaci√≥n completa:</strong> CI/CD puede derivar versiones autom√°ticamente</li>
            <li><strong>Rollback f√°cil:</strong> Checkout a cualquier tag para recompilar una versi√≥n antigua</li>
            <li><strong>Historial claro:</strong> <code>git tag</code> muestra todas las versiones lanzadas</li>
          </ul>
        </div>

        <h2>üì± Consideraciones Avanzadas para Google Play Store</h2>
        <p>Google Play Store tiene un conjunto complejo de requisitos y caracter√≠sticas relacionadas con el versionado que todo desarrollador Android debe dominar. Comprender estas reglas es crucial para evitar rechazos y aprovechar al m√°ximo las capacidades de la plataforma.</p>

        <h3>üîÑ Android App Bundle vs APK: Impacto en el Versionado</h3>
        <p>El formato Android App Bundle (AAB) ha cambiado fundamentalmente c√≥mo Google Play maneja las versiones:</p>

        <div class="app-bundle-explanation">
          <h4>Con APKs Tradicionales (Obsoleto desde Agosto 2021)</h4>
          <p>Anteriormente, los desarrolladores sub√≠an m√∫ltiples APKs con diferentes configuraciones:</p>
          <ul>
            <li>Un APK para cada ABI (armeabi-v7a, arm64-v8a, x86, x86_64)</li>
            <li>Un APK para cada densidad de pantalla</li>
            <li>Un APK para cada nivel de API m√≠nimo</li>
          </ul>
          <p>Cada APK requer√≠a un versionCode √∫nico y creciente, lo que complicaba enormemente la gesti√≥n.</p>

          <h4>Con Android App Bundle (AAB) - M√©todo Actual</h4>
          <p>Google Play genera autom√°ticamente APKs optimizados desde tu AAB:</p>
          <ul>
            <li><strong>Un solo versionCode</strong> para todo el App Bundle</li>
            <li>Google genera internamente m√∫ltiples APKs con versionCodes derivados</li>
            <li>Los usuarios descargan solo el APK optimizado para su dispositivo</li>
            <li>Menor tama√±o de descarga (hasta 35% de reducci√≥n)</li>
          </ul>

          <div class="code-block">
            <div class="code-header">
              <span class="code-title">build.gradle - Configuraci√≥n para AAB</span>
            </div>
            <pre><code>android {
    bundle {
        // Configuraci√≥n de App Bundle
        language {
            // Habilitar split por idioma
            enableSplit = true
        }
        density {
            // Habilitar split por densidad
            enableSplit = true
        }
        abi {
            // Habilitar split por ABI
            enableSplit = true
        }
    }
    
    defaultConfig {
        // Un solo versionCode para el App Bundle
        versionCode 20301  // 2.3.1
        versionName "2.3.1"
    }
}

// Task para generar App Bundle
// ./gradlew bundleRelease</code></pre>
          </div>
        </div>

        <div class="warning-box">
          <h4>‚ö†Ô∏è Advertencia Importante sobre Rollbacks</h4>
          <p>Google Play NO permite subir una versi√≥n con un versionCode menor que cualquier versi√≥n anterior en CUALQUIER track (incluso tracks cerrados). Esto significa:</p>
          <ul>
            <li>Si subes versionCode 100 a beta y falla, NO puedes subir versionCode 99 a producci√≥n</li>
            <li>Planifica tus versionCodes con margen para hotfixes</li>
            <li>Considera usar gaps en versionCodes entre releases mayores</li>
          </ul>
        </div>

        <h3>üöÄ Canales de Distribuci√≥n (Release Tracks)</h3>
        <p>Google Play ofrece cuatro tracks de distribuci√≥n, cada uno con prop√≥sitos espec√≠ficos en el ciclo de vida del desarrollo:</p>

        <div class="tracks-detailed">
          <div class="track-card">
            <h4>1. üî¨ Internal Testing (Pruebas Internas)</h4>
            <p><strong>Prop√≥sito:</strong> Validaci√≥n r√°pida con equipo interno antes de QA formal</p>
            <div class="track-features">
              <h5>Caracter√≠sticas:</h5>
              <ul>
                <li>Hasta 100 testers</li>
                <li>Aprobaci√≥n autom√°tica (disponible en minutos)</li>
                <li>Ideal para daily builds o feature branches</li>
                <li>Sin revisi√≥n de Google Play</li>
              </ul>
              <h5>Estrategia de Versionado:</h5>
              <ul>
                <li>Usa sufijos: "2.3.1-internal.5"</li>
                <li>versionCode incremental por build: 203010, 203011, 203012...</li>
                <li>Automatiza completamente con CI/CD</li>
              </ul>
              <h5>Caso de Uso:</h5>
              <p>"Acabo de hacer merge de un PR, quiero que el equipo pruebe en dispositivos reales antes del sprint review"</p>
            </div>
          </div>

          <div class="track-card">
            <h4>2. üß™ Alpha Testing (Pruebas Cerradas)</h4>
            <p><strong>Prop√≥sito:</strong> QA formal y early adopters de confianza</p>
            <div class="track-features">
              <h5>Caracter√≠sticas:</h5>
              <ul>
                <li>Hasta 100,000 testers (m√∫ltiples listas posibles)</li>
                <li>Revisi√≥n ligera de Google (horas, no d√≠as)</li>
                <li>Feedback directo de testers</li>
                <li>M√©tricas detalladas en Play Console</li>
              </ul>
              <h5>Estrategia de Versionado:</h5>
              <ul>
                <li>Usa sufijos: "2.3.1-alpha"</li>
                <li>versionCode con gaps para hotfixes: 203100</li>
                <li>Requiere cambios en changelog</li>
              </ul>
              <h5>Caso de Uso:</h5>
              <p>"Release candidate para el pr√≥ximo sprint, necesito feedback de QA y power users"</p>
            </div>
          </div>

          <div class="track-card">
            <h4>3. üîì Beta Testing (Pruebas Abiertas)</h4>
            <p><strong>Prop√≥sito:</strong> Validaci√≥n a escala con usuarios reales antes de producci√≥n</p>
            <div class="track-features">
              <h5>Caracter√≠sticas:</h5>
              <ul>
                <li>Ilimitado n√∫mero de testers</li>
                <li>Puede ser open beta (cualquiera se une) o closed beta</li>
                <li>Revisi√≥n est√°ndar de Google Play</li>
                <li>Visible en Play Store para testers</li>
                <li>Staged rollouts disponibles</li>
              </ul>
              <h5>Estrategia de Versionado:</h5>
              <ul>
                <li>Usa sufijos: "2.3.1-beta" o "2.4.0-beta"</li>
                <li>versionCode con margen: 204000 (deja 203900-203999 para hotfixes en prod)</li>
                <li>Pre-release para validar features mayores</li>
              </ul>
              <h5>Caso de Uso:</h5>
              <p>"Nueva funcionalidad mayor lista, queremos validar con 10,000+ usuarios antes de lanzar a todos"</p>
            </div>
          </div>

          <div class="track-card">
            <h4>4. üåç Production (Producci√≥n)</h4>
            <p><strong>Prop√≥sito:</strong> Release estable para todos los usuarios</p>
            <div class="track-features">
              <h5>Caracter√≠sticas:</h5>
              <ul>
                <li>Todos los usuarios pueden instalarlo</li>
                <li>Revisi√≥n completa de Google Play (2-7 d√≠as t√≠picamente)</li>
                <li>Staged rollouts recomendados (5% -> 10% -> 50% -> 100%)</li>
                <li>Rollback disponible a versi√≥n anterior</li>
                <li>Impacta m√©tricas principales (ratings, reviews)</li>
              </ul>
              <h5>Estrategia de Versionado:</h5>
              <ul>
                <li>Sin sufijos: "2.3.1" (SemVer limpio)</li>
                <li>versionCode redondos: 203100, 203200, 204000</li>
                <li>Changelog detallado y profesional requerido</li>
              </ul>
              <h5>Caso de Uso:</h5>
              <p>"Release final validado en beta, listo para todos los usuarios"</p>
            </div>
          </div>
        </div>

        <h3>üéöÔ∏è Staged Rollouts (Lanzamientos Progresivos)</h3>
        <p>Una de las caracter√≠sticas m√°s poderosas de Google Play es la capacidad de lanzar actualizaciones gradualmente, minimizando el impacto de bugs cr√≠ticos:</p>

        <div class="staged-rollout-strategy">
          <h4>Estrategia Recomendada de Rollout:</h4>
          <div class="rollout-phases">
            <div class="phase">
              <h5>Fase 1: 5% de usuarios (D√≠a 1)</h5>
              <ul>
                <li>Monitorea crash rates en tiempo real</li>
                <li>Revisa reviews y ratings nuevos</li>
                <li>Verifica m√©tricas de rendimiento</li>
                <li>Si todo est√° bien, procede en 24-48h</li>
              </ul>
            </div>
            <div class="phase">
              <h5>Fase 2: 10% de usuarios (D√≠a 2-3)</h5>
              <ul>
                <li>Valida con muestra estad√≠sticamente significativa</li>
                <li>Analiza edge cases no detectados en testing</li>
                <li>Compara con versi√≥n anterior</li>
              </ul>
            </div>
            <div class="phase">
              <h5>Fase 3: 50% de usuarios (D√≠a 4-5)</h5>
              <ul>
                <li>Confirma estabilidad a escala media</li>
                <li>Revisa feedback de diferentes segmentos</li>
                <li>√öltima oportunidad para halt antes de mayor√≠a</li>
              </ul>
            </div>
            <div class="phase">
              <h5>Fase 4: 100% de usuarios (D√≠a 6-7)</h5>
              <ul>
                <li>Release completo a todos los usuarios</li>
                <li>Mant√©n monitoreo activo por 48h adicionales</li>
                <li>Prepara hotfix si es necesario</li>
              </ul>
            </div>
          </div>
        </div>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">Automatizaci√≥n de Staged Rollout con Google Play Publisher API</span>
          </div>
          <pre><code>// Ejemplo usando Fastlane
lane :deploy_staged do
  # Upload to Google Play
  upload_to_play_store(
    track: 'production',
    rollout: '0.05',  # 5% inicial
    apk: 'app/build/outputs/bundle/release/app-release.aab',
    skip_upload_apk: true,
    skip_upload_screenshots: true,
    skip_upload_images: true
  )
  
  # Notificar al equipo
  slack(
    message: "üöÄ Version 2.3.1 deployed to 5% of users. Monitoring for 24h.",
    channel: "#releases"
  )
end

lane :increase_rollout do |options|
  percentage = options[:percentage] || 0.1
  
  supply(
    track: 'production',
    rollout: percentage.to_s
  )
  
  slack(
    message: "üìà Rollout increased to #{(percentage * 100).to_i}%",
    channel: "#releases"
  )
end</code></pre>
        </div>

        <h3>üîß Gesti√≥n de M√∫ltiples Flavors y Variantes</h3>
        <p>Cuando tu app tiene m√∫ltiples flavors (free/pro, diferentes brands), el versionado se complica:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">build.gradle - M√∫ltiples Flavors con Versionado Independiente</span>
          </div>
          <pre><code>android {
    flavorDimensions "tier", "brand"
    
    productFlavors {
        free {
            dimension "tier"
            applicationIdSuffix ".free"
            
            // Versi√≥n espec√≠fica para Free
            versionCode 203110  // 2.3.1, tier=1, variant=0
            versionName "2.3.1-free"
        }
        
        pro {
            dimension "tier"
            applicationIdSuffix ".pro"
            
            // Versi√≥n espec√≠fica para Pro
            versionCode 203120  // 2.3.1, tier=2, variant=0
            versionName "2.3.1-pro"
        }
        
        brandA {
            dimension "brand"
            applicationIdSuffix ".brandA"
        }
        
        brandB {
            dimension "brand"
            applicationIdSuffix ".brandB"
        }
    }
    
    // Customizar versionCode por variante
    applicationVariants.all { variant ->
        def flavorName = variant.flavorName
        def buildType = variant.buildType.name
        
        // Calcular versionCode din√°micamente
        def baseVersionCode = 203100
        def tierCode = 0
        def brandCode = 0
        
        if (flavorName.contains("pro")) tierCode = 1
        if (flavorName.contains("brandB")) brandCode = 1
        
        def finalVersionCode = baseVersionCode + (tierCode * 10) + brandCode
        
        variant.outputs.each { output ->
            output.versionCodeOverride = finalVersionCode
        }
        
        println "Variant: ${flavorName} (${buildType}) -> versionCode: ${finalVersionCode}"
    }
}</code></pre>
        </div>

        <h2>üîÑ Integraci√≥n Completa con CI/CD</h2>
        <p>La automatizaci√≥n del versionado en pipelines de CI/CD es esencial para mantener consistencia, reducir errores humanos y acelerar el tiempo de entrega. Una estrategia bien dise√±ada puede transformar completamente tu workflow de releases.</p>

        <h3>üéØ Estrategia de Versionado en CI/CD</h3>
        <p>El objetivo es lograr un pipeline completamente automatizado donde:</p>
        <ul>
          <li>Los commits a branches espec√≠ficos triggean builds autom√°ticos</li>
          <li>Las versiones se derivan autom√°ticamente del estado del repositorio</li>
          <li>Los changelogs se generan desde commits y PRs</li>
          <li>Las releases a diferentes tracks son autom√°ticas basadas en el branch</li>
        </ul>

        <h3>Implementaci√≥n con GitHub Actions (Completa)</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">.github/workflows/release.yml</span>
          </div>
          <pre><code>name: Build and Release
on:
  push:
    branches:
      - main
      - develop
      - 'release/**'
    tags:
      - 'v*'
  pull_request:
    branches:
      - main
      - develop

env:
  JAVA_VERSION: '17'
  
jobs:
  # ==========================================
  # Job 1: Calcular versi√≥n autom√°ticamente
  # ==========================================
  calculate-version:
    name: Calculate Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version-code: ${{ steps.version.outputs.version-code }}
      version-name: ${{ steps.version.outputs.version-name }}
      is-release: ${{ steps.version.outputs.is-release }}
      track: ${{ steps.version.outputs.track }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Necesario para git describe
      
      - name: Calculate version from Git
        id: version
        run: |
          # Obtener el √∫ltimo tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          
          # Parsear el tag (formato: v1.2.3)
          VERSION=${LATEST_TAG#v}
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          
          # Calcular versionCode (formato MMmmpp)
          VERSION_CODE=$((MAJOR * 10000 + MINOR * 100 + PATCH))
          
          # Determinar si es un release tag
          IS_RELEASE="false"
          TRACK="internal"
          
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            IS_RELEASE="true"
            VERSION_NAME="$VERSION"
            
            # Determinar track basado en el tag
            if [[ "$VERSION" == *-alpha* ]]; then
              TRACK="alpha"
            elif [[ "$VERSION" == *-beta* ]]; then
              TRACK="beta"
            else
              TRACK="production"
            fi
          else
            # Para branches, a√±adir metadata
            BRANCH_NAME=$(echo "${GITHUB_REF#refs/heads/}" | sed 's/\//-/g')
            COMMIT_COUNT=$(git rev-list --count HEAD ^${LATEST_TAG} 2>/dev/null || echo "0")
            SHORT_SHA=$(git rev-parse --short HEAD)
            
            VERSION_NAME="${VERSION}-${BRANCH_NAME}.${COMMIT_COUNT}+${SHORT_SHA}"
            VERSION_CODE=$((VERSION_CODE + COMMIT_COUNT))
            
            # Determinar track basado en branch
            if [[ "$BRANCH_NAME" == "main" ]]; then
              TRACK="beta"
            elif [[ "$BRANCH_NAME" == "develop" ]]; then
              TRACK="alpha"
            else
              TRACK="internal"
            fi
          fi
          
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version-code=$VERSION_CODE" >> $GITHUB_OUTPUT
          echo "version-name=$VERSION_NAME" >> $GITHUB_OUTPUT
          echo "is-release=$IS_RELEASE" >> $GITHUB_OUTPUT
          echo "track=$TRACK" >> $GITHUB_OUTPUT
          
          echo "Calculated version: $VERSION_NAME (code: $VERSION_CODE, track: $TRACK)"

  # ==========================================
  # Job 2: Build and Test
  # ==========================================
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: calculate-version
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'gradle'
      
      - name: Update version in version.properties
        run: |
          VERSION="${{ needs.calculate-version.outputs.version }}"
          MAJOR=$(echo $VERSION | cut -d. -f1)
          MINOR=$(echo $VERSION | cut -d. -f2)
          PATCH=$(echo $VERSION | cut -d. -f3)
          
          cat > version.properties << EOF
          VERSION_MAJOR=$MAJOR
          VERSION_MINOR=$MINOR
          VERSION_PATCH=$PATCH
          BUILD_NUMBER=${{ github.run_number }}
          VERSION_SUFFIX=
          EOF
          
          cat version.properties
      
      - name: Run tests
        run: ./gradlew test lint
      
      - name: Build Release AAB
        run: ./gradlew bundleRelease
        env:
          KEYSTORE_PASSWORD: ${{ secrets.KEYSTORE_PASSWORD }}
          KEY_ALIAS: ${{ secrets.KEY_ALIAS }}
          KEY_PASSWORD: ${{ secrets.KEY_PASSWORD }}
      
      - name: Upload AAB artifact
        uses: actions/upload-artifact@v3
        with:
          name: app-release-aab
          path: app/build/outputs/bundle/release/app-release.aab
      
      - name: Upload mapping files
        uses: actions/upload-artifact@v3
        with:
          name: mapping-files
          path: app/build/outputs/mapping/release/

  # ==========================================
  # Job 3: Generate Changelog
  # ==========================================
  changelog:
    name: Generate Changelog
    runs-on: ubuntu-latest
    needs: calculate-version
    if: needs.calculate-version.outputs.is-release == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Generate Changelog
        id: changelog
        uses: mikepenz/release-changelog-builder-action@v4
        with:
          configuration: ".github/changelog-config.json"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Create Release Notes
        run: |
          cat > release-notes.txt << 'EOF'
          ${{ steps.changelog.outputs.changelog }}
          EOF
      
      - name: Upload Release Notes
        uses: actions/upload-artifact@v3
        with:
          name: release-notes
          path: release-notes.txt

  # ==========================================
  # Job 4: Deploy to Google Play
  # ==========================================
  deploy:
    name: Deploy to Play Store
    runs-on: ubuntu-latest
    needs: [calculate-version, build, changelog]
    if: needs.calculate-version.outputs.is-release == 'true'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Download AAB
        uses: actions/download-artifact@v3
        with:
          name: app-release-aab
          path: app/build/outputs/bundle/release/
      
      - name: Download Release Notes
        uses: actions/download-artifact@v3
        with:
          name: release-notes
          path: ./
        if: needs.calculate-version.outputs.track == 'production'
      
      - name: Deploy to Play Store
        uses: r0adkll/upload-google-play@v1
        with:
          serviceAccountJsonPlainText: ${{ secrets.PLAY_SERVICE_ACCOUNT_JSON }}
          packageName: com.arceapps.miapp
          releaseFiles: app/build/outputs/bundle/release/app-release.aab
          track: ${{ needs.calculate-version.outputs.track }}
          inAppUpdatePriority: 2
          status: completed
          whatsNewDirectory: ./whatsnew/
          mappingFile: app/build/outputs/mapping/release/mapping.txt
      
      - name: Create GitHub Release
        if: needs.calculate-version.outputs.track == 'production'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ needs.calculate-version.outputs.version }}
          release_name: Release ${{ needs.calculate-version.outputs.version }}
          body_path: release-notes.txt
          draft: false
          prerelease: false
      
      - name: Notify team
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: |
            üöÄ Version ${{ needs.calculate-version.outputs.version-name }} 
            üì± Deployed to ${{ needs.calculate-version.outputs.track }}
            üî¢ Version Code: ${{ needs.calculate-version.outputs.version-code }}
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
        if: always()</code></pre>
        </div>

        <h3>Configuraci√≥n del Changelog Autom√°tico</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">.github/changelog-config.json</span>
          </div>
          <pre><code>{
  "categories": [
    {
      "title": "## üöÄ Features",
      "labels": ["feature", "enhancement"]
    },
    {
      "title": "## üêõ Bug Fixes",
      "labels": ["bug", "bugfix"]
    },
    {
      "title": "## üîß Improvements",
      "labels": ["improvement", "refactor"]
    },
    {
      "title": "## üìö Documentation",
      "labels": ["documentation"]
    },
    {
      "title": "## üîê Security",
      "labels": ["security"]
    }
  ],
  "ignore_labels": [
    "ignore",
    "duplicate",
    "wontfix"
  ],
  "sort": "ASC",
  "template": "#{{CHANGELOG}}\n\n**Full Changelog**: #{{RELEASE_DIFF}}",
  "pr_template": "- #{{TITLE}} by @#{{AUTHOR}} in ##{{NUMBER}}",
  "empty_template": "No changes in this release",
  "label_extractor": [
    {
      "pattern": "feat(.*)",
      "target": "feature"
    },
    {
      "pattern": "fix(.*)",
      "target": "bug"
    }
  ]
}</code></pre>
        </div>

        <h3>üîê Manejo de Secretos y Signing</h3>
        <p>Para firmar APKs autom√°ticamente en CI/CD, necesitas configurar correctamente los secretos:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">app/build.gradle - Release Signing Config</span>
          </div>
          <pre><code>android {
    signingConfigs {
        release {
            // Leer desde environment variables en CI, o desde local.properties en desarrollo
            def keystorePropertiesFile = rootProject.file("keystore.properties")
            def keystoreProperties = new Properties()
            
            if (keystorePropertiesFile.exists()) {
                keystoreProperties.load(new FileInputStream(keystorePropertiesFile))
                storeFile file(keystoreProperties['storeFile'])
                storePassword keystoreProperties['storePassword']
                keyAlias keystoreProperties['keyAlias']
                keyPassword keystoreProperties['keyPassword']
            } else {
                // En CI/CD, usar environment variables
                storeFile file(System.getenv("KEYSTORE_FILE") ?: "release-keystore.jks")
                storePassword System.getenv("KEYSTORE_PASSWORD")
                keyAlias System.getenv("KEY_ALIAS")
                keyPassword System.getenv("KEY_PASSWORD")
            }
        }
    }
    
    buildTypes {
        release {
            signingConfig signingConfigs.release
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}</code></pre>
        </div>

        <div class="secrets-setup">
          <h4>Configurar Secretos en GitHub:</h4>
          <ol>
            <li>Convertir keystore a base64:
              <div class="code-block">
                <pre><code>base64 -i release-keystore.jks | pbcopy  # macOS
base64 -w 0 release-keystore.jks | xclip  # Linux</code></pre>
              </div>
            </li>
            <li>Ir a GitHub repository ‚Üí Settings ‚Üí Secrets and variables ‚Üí Actions</li>
            <li>A√±adir los siguientes secretos:
              <ul>
                <li><code>KEYSTORE_BASE64</code>: El keystore en base64</li>
                <li><code>KEYSTORE_PASSWORD</code>: Password del keystore</li>
                <li><code>KEY_ALIAS</code>: Alias de la key</li>
                <li><code>KEY_PASSWORD</code>: Password de la key</li>
                <li><code>PLAY_SERVICE_ACCOUNT_JSON</code>: JSON del service account de Google Play</li>
              </ul>
            </li>
            <li>En el workflow, decodificar el keystore:
              <div class="code-block">
                <pre><code>- name: Decode Keystore
  run: |
    echo "${{ secrets.KEYSTORE_BASE64 }}" | base64 --decode > release-keystore.jks</code></pre>
              </div>
            </li>
          </ol>
        </div>

        <h2>‚úÖ Mejores Pr√°cticas Avanzadas</h2>
        <p>Despu√©s de a√±os de experiencia y lecciones aprendidas en proyectos de todos los tama√±os, estas son las mejores pr√°cticas que todo equipo deber√≠a adoptar:</p>
        
        <h3>1. üìã Consistencia en el Equipo: Establecer Reglas Claras</h3>
        <p>El versionado sem√°ntico solo funciona si todo el equipo sigue las mismas reglas. Documenta claramente cu√°ndo incrementar cada componente:</p>
        
        <div class="versioning-rules">
          <div class="rule-card">
            <h4>üî¥ MAJOR (X.0.0) - Cambios Incompatibles</h4>
            <p><strong>Incrementa cuando:</strong></p>
            <ul>
              <li>Eliminas o renombras caracter√≠sticas p√∫blicas</li>
              <li>Cambias el comportamiento de funcionalidades existentes de manera incompatible</li>
              <li>Actualizas versiones m√≠nimas de Android (minSdk) significativamente</li>
              <li>Redise√±as completamente la UI/UX</li>
              <li>Cambias el modelo de datos sin migraci√≥n autom√°tica</li>
              <li>Eliminas soporte para versiones antiguas de la app</li>
            </ul>
            <p><strong>Ejemplos concretos en Android:</strong></p>
            <ul>
              <li>"Migraci√≥n de Room 2.x a Room 3.x con cambios de API"</li>
              <li>"Cambio de minSdk de 21 a 26, eliminando soporte para Android 5.x"</li>
              <li>"Reescritura completa de Views a Jetpack Compose"</li>
              <li>"Cambio de arquitectura MVC a MVVM"</li>
            </ul>
            <div class="warning-box">
              <p>‚ö†Ô∏è Considera hacer un MAJOR release cuando m√°s del 20% de tu c√≥digo cambia</p>
            </div>
          </div>

          <div class="rule-card">
            <h4>üü° MINOR (0.X.0) - Nuevas Funcionalidades</h4>
            <p><strong>Incrementa cuando:</strong></p>
            <ul>
              <li>A√±ades nuevas pantallas o features</li>
              <li>Implementas nueva funcionalidad visible al usuario</li>
              <li>A√±ades nuevos permisos requeridos</li>
              <li>Integras nuevas librer√≠as o SDKs</li>
              <li>A√±ades soporte para nuevas versiones de Android</li>
              <li>Deprecas (pero no eliminas) funcionalidad antigua</li>
            </ul>
            <p><strong>Ejemplos concretos en Android:</strong></p>
            <ul>
              <li>"A√±adida pantalla de estad√≠sticas con gr√°ficos"</li>
              <li>"Integraci√≥n de Google Maps para localizaci√≥n"</li>
              <li>"Soporte para Material Design 3"</li>
              <li>"A√±adido modo oscuro"</li>
              <li>"Implementaci√≥n de notificaciones push"</li>
            </ul>
            <div class="info-box">
              <p>üí° Los MINOR releases deber√≠an ser backwards-compatible: usuarios pueden actualizar sin romper funcionalidad existente</p>
            </div>
          </div>

          <div class="rule-card">
            <h4>üü¢ PATCH (0.0.X) - Correcciones de Bugs</h4>
            <p><strong>Incrementa cuando:</strong></p>
            <ul>
              <li>Corriges crashes o bugs</li>
              <li>Mejoras performance sin cambios visibles</li>
              <li>Actualizas dependencias por seguridad</li>
              <li>Corriges typos en UI</li>
              <li>Arreglas problemas de UI/UX menores</li>
              <li>Optimizas c√≥digo sin cambios funcionales</li>
            </ul>
            <p><strong>Ejemplos concretos en Android:</strong></p>
            <ul>
              <li>"Corregido crash al rotar pantalla en MainActivity"</li>
              <li>"Solucionado memory leak en ImageLoader"</li>
              <li>"Actualizada librer√≠a OkHttp por vulnerabilidad de seguridad"</li>
              <li>"Mejorada carga de im√°genes, reducci√≥n del 30% en tiempo"</li>
              <li>"Corregido texto en espa√±ol en pantalla de login"</li>
            </ul>
            <div class="success-box">
              <p>‚úÖ PATCH releases pueden y deben ser frecuentes. No esperes a acumular muchos fixes.</p>
            </div>
          </div>
        </div>

        <h3>2. üìñ Documentaci√≥n Autom√°tica y Changelogs</h3>
        <p>Los changelogs son cr√≠ticos para comunicar cambios a usuarios, stakeholders y el equipo. Automatiza su generaci√≥n para mantener consistencia:</p>

        <div class="changelog-best-practices">
          <h4>Estructura Recomendada de CHANGELOG.md:</h4>
          <div class="code-block">
            <pre><code># Changelog

Todos los cambios notables en este proyecto ser√°n documentados en este archivo.

El formato est√° basado en [Keep a Changelog](https://keepachangelog.com/es-ES/1.0.0/),
y este proyecto adhiere a [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [2.3.1] - 2025-08-25

### üêõ Fixed
- Corregido crash al abrir configuraci√≥n en dispositivos con Android 11 (#234)
- Solucionado problema de sincronizaci√≥n con servidor (#241)
- Arreglado memory leak en RecyclerView de mensajes (#245)

### üîß Changed
- Mejorado performance de carga inicial en 40%
- Actualizada librer√≠a Glide de 4.15 a 4.16 por vulnerabilidad

## [2.3.0] - 2025-08-18

### ‚ú® Added
- Nueva pantalla de estad√≠sticas con gr√°ficos interactivos (#210)
- Soporte para exportar datos en formato CSV (#215)
- Implementado modo oscuro en toda la app (#198)
- A√±adidas notificaciones programadas (#220)

### üêõ Fixed
- Corregido bug donde los filtros no se aplicaban correctamente (#205)
- Solucionado crash al tomar foto en algunos dispositivos Samsung (#212)

### üîí Security
- Actualizado cifrado de datos locales (Room) con AES-256

## [2.2.5] - 2025-08-10

### üêõ Fixed
- Hotfix: Corregido crash cr√≠tico al hacer login con Google (#202)

## [2.2.4] - 2025-08-08

### üêõ Fixed
- Corregido layout roto en tablets en orientaci√≥n horizontal (#195)
- Solucionado problema de timeout en llamadas de API (#197)

### üîß Changed
- Mejorada UI de la pantalla de perfil con Material Design 3

## [2.2.0] - 2025-08-01

### ‚ú® Added
- Implementada b√∫squeda avanzada con filtros (#180)
- A√±adido soporte para compartir contenido (#185)
- Nueva secci√≥n de favoritos (#175)

### ‚ö†Ô∏è Deprecated
- La API anterior de notificaciones ser√° removida en v3.0.0
- M√©todo `getUserData()` deprecado, usar `getUserProfile()` en su lugar

### üêõ Fixed
- M√∫ltiples mejoras de estabilidad y correcciones menores

---

## [2.1.0] - 2025-07-15

[Versiones anteriores...]

[2.3.1]: https://github.com/usuario/proyecto/compare/v2.3.0...v2.3.1
[2.3.0]: https://github.com/usuario/proyecto/compare/v2.2.5...v2.3.0
[2.2.5]: https://github.com/usuario/proyecto/compare/v2.2.4...v2.2.5</code></pre>
          </div>

          <h4>Convenciones para Mensajes de Commit:</h4>
          <p>Usa <a href="https://www.conventionalcommits.org/">Conventional Commits</a> para facilitar la generaci√≥n autom√°tica de changelogs:</p>
          <div class="code-block">
            <pre><code># Formato:
&lt;tipo&gt;[√°mbito opcional]: &lt;descripci√≥n&gt;

# Ejemplos:
feat(auth): add biometric authentication support
fix(chat): resolve message duplication issue (#234)
perf(images): optimize image loading by 40%
docs(readme): update installation instructions
refactor(database): migrate Room queries to Flow
test(profile): add unit tests for ProfileViewModel
chore(deps): update Kotlin to 1.9.0
security(api): update OkHttp to fix CVE-2023-1234

# Con breaking change:
feat(api)!: change authentication flow
BREAKING CHANGE: AuthManager.login() now returns Flow instead of LiveData</code></pre>
          </div>
        </div>

        <h3>3. üß™ Testing por Versiones</h3>
        <p>El versionado no es solo n√∫meros - tiene implicaciones t√©cnicas que deben ser testeadas:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">MigrationTest.kt - Testing de Migraciones de BD</span>
          </div>
          <pre><code>@RunWith(AndroidJUnit4::class)
class MigrationTest {
    private lateinit var database: AppDatabase
    
    @get:Rule
    val helper: MigrationTestHelper = MigrationTestHelper(
        InstrumentationRegistry.getInstrumentation(),
        AppDatabase::class.java.canonicalName,
        FrameworkSQLiteOpenHelperFactory()
    )
    
    @Test
    fun migrate2To3() {
        // Crear BD en versi√≥n 2
        helper.createDatabase(TEST_DB, 2).apply {
            // Insertar datos de prueba en formato v2
            execSQL("INSERT INTO users (id, name, email) VALUES (1, 'Test User', 'test@example.com')")
            close()
        }
        
        // Ejecutar migraci√≥n a versi√≥n 3
        val dbVersion3 = helper.runMigrationsAndValidate(TEST_DB, 3, true, MIGRATION_2_3)
        
        // Verificar que los datos migraron correctamente
        val cursor = dbVersion3.query("SELECT * FROM users WHERE id = 1")
        assertTrue(cursor.moveToFirst())
        
        // Verificar que la nueva columna existe
        val columnIndex = cursor.getColumnIndex("profile_image_url")
        assertTrue(columnIndex >= 0)
        
        cursor.close()
        dbVersion3.close()
    }
    
    @Test
    fun migrateAllVersionsSequentially() {
        // Test que todas las migraciones funcionan en secuencia
        helper.createDatabase(TEST_DB, 1).close()
        
        // Migrar de 1 -> 2 -> 3 -> 4 -> 5
        val db = helper.runMigrationsAndValidate(
            TEST_DB,
            5,
            true,
            MIGRATION_1_2,
            MIGRATION_2_3,
            MIGRATION_3_4,
            MIGRATION_4_5
        )
        
        db.close()
    }
}

// Test de compatibilidad de SharedPreferences entre versiones
@Test
fun testSharedPreferencesBackwardCompatibility() {
    // Simular preferencias guardadas en v2.2.0
    val prefs = context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
    prefs.edit()
        .putString("user_theme", "dark")
        .putInt("version_code", 202000)
        .apply()
    
    // Simular upgrade a v2.3.0
    val migrationHelper = PreferencesMigrationHelper(context)
    migrationHelper.migrate(202000, 203000)
    
    // Verificar que las preferencias antiguas siguen funcionando
    val theme = prefs.getString("user_theme", "light")
    assertEquals("dark", theme)
    
    // Verificar que se a√±adieron nuevas preferencias con valores por defecto
    val newFeatureEnabled = prefs.getBoolean("dark_mode_enabled", false)
    assertTrue(newFeatureEnabled)  // Debe derivarse de user_theme
}</code></pre>
        </div>

        <h3>4. üîÑ Estrategia de Deprecaci√≥n</h3>
        <p>Cuando necesitas eliminar funcionalidad, hazlo gradualmente usando el sistema de versionado:</p>

        <div class="deprecation-strategy">
          <h4>Proceso de Deprecaci√≥n en 3 Fases:</h4>
          
          <div class="phase-card">
            <h5>Fase 1: Deprecar (Version X.Y.0)</h5>
            <div class="code-block">
              <pre><code>@Deprecated(
    message = "Use getUserProfile() instead",
    replaceWith = ReplaceWith("getUserProfile()"),
    level = DeprecationLevel.WARNING
)
fun getUserData(): User {
    // Mantener implementaci√≥n funcional
    return getUserProfile()
}

fun getUserProfile(): User {
    // Nueva implementaci√≥n mejorada
    return userRepository.getProfile()
}</code></pre>
            </div>
            <p>üìù En el changelog de X.Y.0:</p>
            <ul>
              <li>A√±adir nota en secci√≥n "Deprecated"</li>
              <li>Explicar la alternativa recomendada</li>
              <li>Indicar en qu√© versi√≥n se eliminar√° (t√≠picamente next MAJOR)</li>
            </ul>
          </div>

          <div class="phase-card">
            <h5>Fase 2: Advertencia Fuerte (Version X.Y+1.0)</h5>
            <div class="code-block">
              <pre><code>@Deprecated(
    message = "getUserData() will be removed in v${X+1}.0.0. Use getUserProfile() instead",
    replaceWith = ReplaceWith("getUserProfile()"),
    level = DeprecationLevel.ERROR  // Ahora es ERROR
)
fun getUserData(): User {
    // Log para tracking
    Timber.w("Deprecated method getUserData() called. Update to getUserProfile()")
    Analytics.logEvent("deprecated_api_usage", mapOf("method" to "getUserData"))
    
    return getUserProfile()
}</code></pre>
            </div>
            <p>Adicionalmente:</p>
            <ul>
              <li>Enviar notificaci√≥n in-app a desarrolladores/beta testers</li>
              <li>A√±adir Analytics para medir uso de APIs deprecadas</li>
              <li>Actualizar documentaci√≥n con ejemplos de migraci√≥n</li>
            </ul>
          </div>

          <div class="phase-card">
            <h5>Fase 3: Eliminar (Version X+1.0.0)</h5>
            <div class="code-block">
              <pre><code>// getUserData() completamente eliminado

fun getUserProfile(): User {
    return userRepository.getProfile()
}</code></pre>
            </div>
            <p>üìù En el changelog de X+1.0.0:</p>
            <ul>
              <li>Listar en secci√≥n "Breaking Changes" o "Removed"</li>
              <li>Incluir gu√≠a de migraci√≥n</li>
              <li>Comunicar claramente que es un MAJOR release</li>
            </ul>
          </div>
        </div>

        <h3>5. üìä Monitoreo y Analytics por Versi√≥n</h3>
        <p>Usa el versionado para tomar decisiones basadas en datos:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">Analytics Setup</span>
          </div>
          <pre><code>// En Application.onCreate()
class MyApplication : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // Enviar informaci√≥n de versi√≥n a analytics
        FirebaseAnalytics.getInstance(this).apply {
            setUserProperty("app_version_name", BuildConfig.VERSION_NAME)
            setUserProperty("app_version_code", BuildConfig.VERSION_CODE.toString())
            setUserProperty("app_version_major", BuildConfig.VERSION_MAJOR.toString())
            setUserProperty("app_version_minor", BuildConfig.VERSION_MINOR.toString())
        }
        
        // Configurar Crashlytics
        FirebaseCrashlytics.getInstance().apply {
            setCustomKey("version_name", BuildConfig.VERSION_NAME)
            setCustomKey("version_code", BuildConfig.VERSION_CODE)
        }
        
        // Log de adoption rate
        logVersionAdoption()
    }
    
    private fun logVersionAdoption() {
        val prefs = getSharedPreferences("app_data", MODE_PRIVATE)
        val previousVersionCode = prefs.getInt("previous_version_code", 0)
        
        if (previousVersionCode != 0 && previousVersionCode != BuildConfig.VERSION_CODE) {
            // Usuario actualiz√≥
            Analytics.logEvent("app_updated", mapOf(
                "from_version" to previousVersionCode,
                "to_version" to BuildConfig.VERSION_CODE,
                "update_type" to determineUpdateType(previousVersionCode, BuildConfig.VERSION_CODE)
            ))
        }
        
        prefs.edit().putInt("previous_version_code", BuildConfig.VERSION_CODE).apply()
    }
    
    private fun determineUpdateType(from: Int, to: Int): String {
        val fromMajor = from / 10000
        val toMajor = to / 10000
        
        return when {
            toMajor > fromMajor -> "major"
            (to / 100) % 100 > (from / 100) % 100 -> "minor"
            else -> "patch"
        }
    }
}</code></pre>
        </div>

        <div class="analytics-dashboard">
          <h4>M√©tricas Clave a Monitorear por Versi√≥n:</h4>
          <ul>
            <li><strong>Adoption Rate:</strong> % de usuarios en cada versi√≥n</li>
            <li><strong>Crash Rate por Versi√≥n:</strong> Identificar regresiones r√°pidamente</li>
            <li><strong>Performance Metrics:</strong> Tiempo de inicio, consumo de memoria por versi√≥n</li>
            <li><strong>Retention Rate:</strong> Comparar entre versiones</li>
            <li><strong>Feature Usage:</strong> Medir adopci√≥n de nuevas features por versi√≥n</li>
            <li><strong>Update Velocity:</strong> Tiempo promedio que los usuarios tardan en actualizar</li>
          </ul>
        </div>

        <h2>üõ†Ô∏è Herramientas y Librer√≠as Recomendadas</h2>
        <p>El ecosistema Android ofrece m√∫ltiples herramientas que facilitan la gesti√≥n del versionado. Aqu√≠ est√°n las m√°s √∫tiles y probadas:</p>

        <div class="tools-detailed">
          <div class="tool-card-detailed">
            <h3>1. Gradle Version Plugin</h3>
            <p><strong>Repositorio:</strong> <code>com.github.ben-manes:gradle-versions-plugin</code></p>
            <p><strong>Qu√© hace:</strong> Automatiza el incremento de versiones y gestiona dependencias.</p>
            
            <div class="code-block">
              <pre><code>// build.gradle (Project)
plugins {
    id 'com.github.ben-manes.versions' version '0.51.0'
}

// Verificar actualizaciones de dependencias
./gradlew dependencyUpdates

// Task personalizada para incrementar versi√≥n
task bumpVersion {
    doLast {
        // Implementaci√≥n personalizada
    }
}</code></pre>
            </div>
            
            <div class="pros-cons-section">
              <div class="pros">
                <h4>‚úÖ Ventajas:</h4>
                <ul>
                  <li>Integraci√≥n nativa con Gradle</li>
                  <li>Flexible y customizable</li>
                  <li>No requiere dependencias externas</li>
                  <li>Puede combinarse con otros plugins</li>
                </ul>
              </div>
              <div class="cons">
                <h4>‚ùå Limitaciones:</h4>
                <ul>
                  <li>Requiere configuraci√≥n manual inicial</li>
                  <li>No incluye features avanzadas out-of-the-box</li>
                  <li>Necesitas escribir tus propios tasks</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="tool-card-detailed">
            <h3>2. Fastlane</h3>
            <p><strong>Website:</strong> <a href="https://fastlane.tools/">fastlane.tools</a></p>
            <p><strong>Qu√© hace:</strong> Suite completa de automatizaci√≥n para mobile, incluyendo versionado, builds, screenshots, y deployments.</p>
            
            <div class="code-block">
              <div class="code-header">
                <span class="code-title">Gemfile</span>
              </div>
              <pre><code>source "https://rubygems.org"

gem "fastlane"
gem "fastlane-plugin-increment_version_code"</code></pre>
            </div>

            <div class="code-block">
              <div class="code-header">
                <span class="code-title">fastlane/Fastfile</span>
              </div>
              <pre><code>default_platform(:android)

platform :android do
  desc "Incrementar PATCH version"
  lane :bump_patch do
    # Leer versi√≥n actual
    version_props = File.read("../version.properties")
    current_patch = version_props.match(/VERSION_PATCH=(\d+)/)[1].to_i
    
    # Incrementar
    new_patch = current_patch + 1
    version_props.gsub!(/VERSION_PATCH=\d+/, "VERSION_PATCH=#{new_patch}")
    
    # Guardar
    File.write("../version.properties", version_props)
    
    puts "‚úÖ Patch version incremented to #{new_patch}"
  end
  
  desc "Build and deploy to Play Store"
  lane :deploy_production do
    # Incrementar versi√≥n
    bump_patch
    
    # Build
    gradle(
      task: "bundle",
      build_type: "Release"
    )
    
    # Upload a Play Store
    upload_to_play_store(
      track: 'production',
      rollout: '0.1',  # 10% rollout inicial
      skip_upload_screenshots: true,
      skip_upload_images: true
    )
    
    # Crear tag en git
    add_git_tag(
      tag: "v#{lane_context[SharedValues::VERSION_NAME]}"
    )
    push_git_tags
    
    # Notificar
    slack(
      message: "üöÄ Nueva versi√≥n #{lane_context[SharedValues::VERSION_NAME]} en producci√≥n!"
    )
  end
  
  desc "Deploy to beta"
  lane :deploy_beta do
    gradle(task: "bundle", build_type: "Release")
    
    upload_to_play_store(
      track: 'beta',
      skip_upload_screenshots: true
    )
  end
  
  desc "Deploy to internal testing"
  lane :deploy_internal do
    gradle(task: "bundle", build_type: "Release")
    
    upload_to_play_store(
      track: 'internal',
      skip_upload_screenshots: true
    )
  end
end</code></pre>
            </div>

            <div class="usage-examples">
              <h4>Comandos √∫tiles:</h4>
              <div class="code-block">
                <pre><code># Incrementar versi√≥n
fastlane bump_patch

# Deploy a producci√≥n
fastlane deploy_production

# Deploy a beta
fastlane deploy_beta

# Deploy a internal testing
fastlane deploy_internal

# Lista de lanes disponibles
fastlane lanes</code></pre>
              </div>
            </div>
            
            <div class="pros-cons-section">
              <div class="pros">
                <h4>‚úÖ Ventajas:</h4>
                <ul>
                  <li>Soluci√≥n completa y probada en producci√≥n</li>
                  <li>Comunidad grande y activa</li>
                  <li>Plugins para casi cualquier necesidad</li>
                  <li>Funciona en Android e iOS</li>
                  <li>Integraci√≥n con CI/CD out-of-the-box</li>
                </ul>
              </div>
              <div class="cons">
                <h4>‚ùå Limitaciones:</h4>
                <ul>
                  <li>Requiere Ruby (dependencia adicional)</li>
                  <li>Curva de aprendizaje moderada</li>
                  <li>Puede ser overhead para proyectos muy simples</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="tool-card-detailed">
            <h3>3. Semantic Release</h3>
            <p><strong>Repository:</strong> <a href="https://github.com/semantic-release/semantic-release">semantic-release</a></p>
            <p><strong>Qu√© hace:</strong> Versionado completamente autom√°tico basado en commits convencionales.</p>
            
            <div class="code-block">
              <div class="code-header">
                <span class="code-title">package.json</span>
              </div>
              <pre><code>{
  "name": "my-android-app",
  "version": "0.0.0-development",
  "scripts": {
    "semantic-release": "semantic-release"
  },
  "devDependencies": {
    "semantic-release": "^22.0.0",
    "@semantic-release/git": "^10.0.1",
    "@semantic-release/changelog": "^6.0.3",
    "@semantic-release/exec": "^6.0.3"
  }
}</code></pre>
            </div>

            <div class="code-block">
              <div class="code-header">
                <span class="code-title">.releaserc.json</span>
              </div>
              <pre><code>{
  "branches": ["main"],
  "plugins": [
    "@semantic-release/commit-analyzer",
    "@semantic-release/release-notes-generator",
    [
      "@semantic-release/changelog",
      {
        "changelogFile": "CHANGELOG.md"
      }
    ],
    [
      "@semantic-release/exec",
      {
        "prepareCmd": "./scripts/update-version.sh ${nextRelease.version}",
        "publishCmd": "./gradlew bundleRelease"
      }
    ],
    [
      "@semantic-release/git",
      {
        "assets": ["CHANGELOG.md", "version.properties"],
        "message": "chore(release): ${nextRelease.version} [skip ci]\n\n${nextRelease.notes}"
      }
    ],
    "@semantic-release/github"
  ]
}</code></pre>
            </div>

            <div class="code-block">
              <div class="code-header">
                <span class="code-title">scripts/update-version.sh</span>
              </div>
              <pre><code>#!/bin/bash
# Script para actualizar version.properties

NEW_VERSION=$1
MAJOR=$(echo $NEW_VERSION | cut -d. -f1)
MINOR=$(echo $NEW_VERSION | cut -d. -f2)
PATCH=$(echo $NEW_VERSION | cut -d. -f3)

cat > version.properties << EOF
VERSION_MAJOR=$MAJOR
VERSION_MINOR=$MINOR
VERSION_PATCH=$PATCH
BUILD_NUMBER=$GITHUB_RUN_NUMBER
VERSION_SUFFIX=
EOF

echo "‚úÖ Version updated to $NEW_VERSION"</code></pre>
            </div>
            
            <div class="pros-cons-section">
              <div class="pros">
                <h4>‚úÖ Ventajas:</h4>
                <ul>
                  <li>Versionado 100% autom√°tico</li>
                  <li>Fuerza uso de conventional commits</li>
                  <li>Genera changelogs autom√°ticos y profesionales</li>
                  <li>Integraci√≥n perfecta con CI/CD</li>
                  <li>Elimina errores humanos en versionado</li>
                </ul>
              </div>
              <div class="cons">
                <h4>‚ùå Limitaciones:</h4>
                <ul>
                  <li>Requiere Node.js (ecosistema diferente)</li>
                  <li>TODO el equipo debe usar conventional commits</li>
                  <li>Menos control manual sobre versiones</li>
                  <li>Configuraci√≥n inicial compleja</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="tool-card-detailed">
            <h3>4. Git Version Plugin</h3>
            <p><strong>Plugin:</strong> <code>com.palantir.git-version</code></p>
            <p><strong>Qu√© hace:</strong> Deriva versiones directamente de tags de Git.</p>
            
            <div class="code-block">
              <pre><code>// build.gradle (Project)
plugins {
    id 'com.palantir.git-version' version '3.0.0'
}

// build.gradle (App)
def gitVersion = versionDetails()

android {
    defaultConfig {
        versionName gitVersion.lastTag
        versionCode gitVersion.commitDistance
        
        buildConfigField "String", "GIT_HASH", "\"${gitVersion.gitHash}\""
        buildConfigField "boolean", "IS_CLEAN_TAG", "${gitVersion.isCleanTag}"
    }
}</code></pre>
            </div>
            
            <div class="pros-cons-section">
              <div class="pros">
                <h4>‚úÖ Ventajas:</h4>
                <ul>
                  <li>Git como single source of truth</li>
                  <li>Sin archivos de configuraci√≥n adicionales</li>
                  <li>Perfecto para CI/CD</li>
                  <li>Reproducibilidad garantizada</li>
                </ul>
              </div>
              <div class="cons">
                <h4>‚ùå Limitaciones:</h4>
                <ul>
                  <li>Dependencia estricta de Git tags</li>
                  <li>Requiere disciplina en tagging</li>
                  <li>Menos flexible para casos especiales</li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <div class="tool-comparison-table">
          <h3>Comparaci√≥n R√°pida:</h3>
          <table>
            <thead>
              <tr>
                <th>Herramienta</th>
                <th>Complejidad</th>
                <th>Automatizaci√≥n</th>
                <th>Mejor para</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Gradle Plugin</strong></td>
                <td>Baja</td>
                <td>Media</td>
                <td>Proyectos simples, equipos peque√±os</td>
              </tr>
              <tr>
                <td><strong>Fastlane</strong></td>
                <td>Media</td>
                <td>Alta</td>
                <td>Proyectos medianos/grandes, equipos establecidos</td>
              </tr>
              <tr>
                <td><strong>Semantic Release</strong></td>
                <td>Alta</td>
                <td>Muy Alta</td>
                <td>Equipos que usan conventional commits, CI/CD maduro</td>
              </tr>
              <tr>
                <td><strong>Git Version</strong></td>
                <td>Baja</td>
                <td>Alta</td>
                <td>Proyectos con disciplina en Git, CI/CD</td>
              </tr>
            </tbody>
          </table>
        </div>

        <div class="recommendation-box">
          <h4>üéØ Nuestra Recomendaci√≥n por Tama√±o de Proyecto:</h4>
          <ul>
            <li><strong>Proyecto personal/peque√±o (1-3 devs):</strong> Gradle tasks manuales o Git Version Plugin</li>
            <li><strong>Startup/mediano (4-10 devs):</strong> Fastlane con configuraci√≥n b√°sica</li>
            <li><strong>Empresa/grande (10+ devs):</strong> Semantic Release + Fastlane + CI/CD completo</li>
            <li><strong>M√∫ltiples apps/white label:</strong> Fastlane con configuraci√≥n modular por proyecto</li>
          </ul>
        </div>

        <h2>üéØ Conclusi√≥n y Pasos Siguientes</h2>
        <p>El versionado sem√°ntico en Android es mucho m√°s que simplemente incrementar n√∫meros - es una <strong>filosof√≠a de comunicaci√≥n</strong>, una <strong>herramienta de gesti√≥n de riesgos</strong>, y un <strong>enabler para la automatizaci√≥n</strong>. Despu√©s de revisar todos los aspectos t√©cnicos, estrat√©gicos y pr√°cticos, queda claro que un sistema de versionado bien dise√±ado e implementado es fundamental para el √©xito a largo plazo de cualquier aplicaci√≥n Android.</p>

        <h3>üîë Puntos Clave para Recordar</h3>
        <div class="key-takeaways">
          <div class="takeaway-card">
            <h4>1. üìä El Versionado es Comunicaci√≥n</h4>
            <p>Cada n√∫mero de versi√≥n comunica informaci√≥n valiosa:</p>
            <ul>
              <li>A los <strong>usuarios</strong>: Qu√© esperar de la actualizaci√≥n</li>
              <li>Al <strong>equipo</strong>: Qu√© tipo de cambios incluye el release</li>
              <li>A <strong>stakeholders</strong>: El ritmo y alcance del desarrollo</li>
              <li>A <strong>sistemas automatizados</strong>: C√≥mo procesar la actualizaci√≥n</li>
            </ul>
          </div>

          <div class="takeaway-card">
            <h4>2. üéØ Consistencia > Perfecci√≥n</h4>
            <p>Es m√°s importante que TODO el equipo siga el mismo sistema que tener el sistema "perfecto". La documentaci√≥n clara y la automatizaci√≥n ayudan a mantener consistencia.</p>
          </div>

          <div class="takeaway-card">
            <h4>3. ü§ñ Automatiza Temprano</h4>
            <p>Implementar automatizaci√≥n desde el principio ahorra innumerables horas y previene errores. El costo inicial de configuraci√≥n se paga multiplicado en el tiempo.</p>
          </div>

          <div class="takeaway-card">
            <h4>4. üì± Android tiene Particularidades</h4>
            <p>El sistema dual (versionCode/versionName), App Bundles, staged rollouts, y m√∫ltiples tracks de distribuci√≥n hacen que el versionado en Android sea m√°s complejo que en otras plataformas. Acepta y abraza esta complejidad.</p>
          </div>

          <div class="takeaway-card">
            <h4>5. üìä Mide y Aprende</h4>
            <p>Usa analytics para entender adoption rates, crash rates por versi√≥n, y patrones de actualizaci√≥n. Los datos informan decisiones sobre deprecaci√≥n, soporte de versiones antiguas, y velocidad de releases.</p>
          </div>
        </div>

        <h3>üöÄ Plan de Acci√≥n Recomendado</h3>
        <p>Si est√°s empezando un nuevo proyecto o mejorando uno existente, sigue este plan paso a paso:</p>

        <div class="action-plan">
          <div class="action-phase">
            <h4>Fase 1: Fundamentos (Semana 1)</h4>
            <div class="checklist">
              <label><input type="checkbox"> Documentar estrategia de versionado en README.md del proyecto</label>
              <label><input type="checkbox"> Configurar version.properties o sistema equivalente</label>
              <label><input type="checkbox"> Implementar versionCode calculation en build.gradle</label>
              <label><input type="checkbox"> Definir reglas claras para MAJOR/MINOR/PATCH con el equipo</label>
              <label><input type="checkbox"> Crear template de CHANGELOG.md</label>
              <label><input type="checkbox"> Configurar git tags para releases (v1.0.0, v1.1.0, etc.)</label>
            </div>
          </div>

          <div class="action-phase">
            <h4>Fase 2: Automatizaci√≥n B√°sica (Semana 2)</h4>
            <div class="checklist">
              <label><input type="checkbox"> Crear Gradle tasks para incrementar versiones (bump-patch, bump-minor, bump-major)</label>
              <label><input type="checkbox"> Configurar pre-commit hooks para validar commits</label>
              <label><input type="checkbox"> Implementar generaci√≥n autom√°tica de changelogs (b√°sica)</label>
              <label><input type="checkbox"> Configurar signing config para releases</label>
              <label><input type="checkbox"> Documentar proceso de release en CONTRIBUTING.md</label>
            </div>
          </div>

          <div class="action-phase">
            <h4>Fase 3: CI/CD Integration (Semana 3-4)</h4>
            <div class="checklist">
              <label><input type="checkbox"> Configurar GitHub Actions o CI preferido</label>
              <label><input type="checkbox"> Implementar builds autom√°ticos en push a main/develop</label>
              <label><input type="checkbox"> Configurar deployment autom√°tico a internal testing</label>
              <label><input type="checkbox"> A√±adir validaci√≥n de version uniqueness</label>
              <label><input type="checkbox"> Configurar notificaciones de releases (Slack, email, etc.)</label>
              <label><input type="checkbox"> Implementar tagged releases autom√°ticos</label>
            </div>
          </div>

          <div class="action-phase">
            <h4>Fase 4: Optimizaci√≥n y Monitoreo (Ongoing)</h4>
            <div class="checklist">
              <label><input type="checkbox"> Configurar Firebase Crashlytics con version tracking</label>
              <label><input type="checkbox"> Implementar analytics de adoption rate</label>
              <label><input type="checkbox"> Configurar staged rollouts para producci√≥n</label>
              <label><input type="checkbox"> Crear dashboard de m√©tricas por versi√≥n</label>
              <label><input type="checkbox"> Implementar alertas autom√°ticas para crash rate spikes</label>
              <label><input type="checkbox"> Establecer proceso de deprecaci√≥n y comunicaci√≥n</label>
              <label><input type="checkbox"> Revisar y refinar proceso cada trimestre</label>
            </div>
          </div>
        </div>

        <h3>‚ö†Ô∏è Errores Comunes y C√≥mo Evitarlos</h3>
        <div class="common-mistakes">
          <div class="mistake-card">
            <h4>‚ùå Error #1: Olvidar Incrementar versionCode</h4>
            <p><strong>Consecuencia:</strong> Google Play rechaza la subida o usuarios no ven la actualizaci√≥n</p>
            <p><strong>Soluci√≥n:</strong> Automatiza el incremento. Nunca lo hagas manualmente.</p>
            <div class="code-block">
              <pre><code>// ‚úÖ BIEN: Calculado autom√°ticamente
versionCode = calculateVersionCode()

// ‚ùå MAL: Hardcodeado y olvidable
versionCode = 123</code></pre>
            </div>
          </div>

          <div class="mistake-card">
            <h4>‚ùå Error #2: No Sincronizar versionName con versionCode</h4>
            <p><strong>Consecuencia:</strong> Confusi√≥n en debugging, analytics inconsistentes</p>
            <p><strong>Soluci√≥n:</strong> Deriva ambos de la misma fuente (version.properties o git tags)</p>
          </div>

          <div class="mistake-card">
            <h4>‚ùå Error #3: Cambios MAJOR sin Comunicaci√≥n</h4>
            <p><strong>Consecuencia:</strong> Usuarios sorprendidos, reviews negativas, churn</p>
            <p><strong>Soluci√≥n:</strong> Comunica cambios grandes con anticipaci√≥n, usa beta extensively</p>
          </div>

          <div class="mistake-card">
            <h4>‚ùå Error #4: No Tener Estrategia de Rollback</h4>
            <p><strong>Consecuencia:</strong> Imposibilidad de revertir releases problem√°ticos r√°pidamente</p>
            <p><strong>Soluci√≥n:</strong> Usa staged rollouts, mant√©n versi√≥n anterior en beta, ten hotfix process</p>
          </div>

          <div class="mistake-card">
            <h4>‚ùå Error #5: Ignorar Adoption Rates</h4>
            <p><strong>Consecuencia:</strong> Deprecar features/versiones que a√∫n tienen usuarios significativos</p>
            <p><strong>Soluci√≥n:</strong> Monitor analytics, establece thresholds antes de deprecar (ej: <5% usuarios)</p>
          </div>
        </div>

        <h3>üìö Recursos Adicionales</h3>
        <div class="resources-section">
          <h4>Documentaci√≥n Oficial:</h4>
          <ul>
            <li><a href="https://semver.org/">Semantic Versioning Specification (semver.org)</a> - La especificaci√≥n oficial completa</li>
            <li><a href="https://developer.android.com/studio/publish/versioning">Android Developer Guide: Version Your App</a> - Gu√≠a oficial de Google</li>
            <li><a href="https://support.google.com/googleplay/android-developer/answer/9859152">Play Console Help: Release Tracks</a> - Documentaci√≥n de tracks de Google Play</li>
          </ul>

          <h4>Herramientas y Plugins:</h4>
          <ul>
            <li><a href="https://fastlane.tools/">Fastlane</a> - Automatizaci√≥n completa para mobile</li>
            <li><a href="https://github.com/semantic-release/semantic-release">Semantic Release</a> - Versionado autom√°tico</li>
            <li><a href="https://www.conventionalcommits.org/">Conventional Commits</a> - Especificaci√≥n para commits estructurados</li>
            <li><a href="https://keepachangelog.com/">Keep a Changelog</a> - Gu√≠a para mantener changelogs</li>
          </ul>

          <h4>Art√≠culos y Casos de Estudio:</h4>
          <ul>
            <li><a href="#">C√≥mo Spotify Gestiona Releases de Android</a> - Caso de estudio real</li>
            <li><a href="#">Conventional Commits en Android</a> - Blog post relacionado</li>
            <li><a href="#">CI/CD con GitHub Actions para Android</a> - Tutorial completo</li>
          </ul>
        </div>

        <h3>ü§ù Conclusi√≥n Final</h3>
        <p>El versionado sem√°ntico en Android es un viaje, no un destino. Comienza simple, automatiza gradualmente, y refina tu proceso bas√°ndote en la experiencia del equipo. Lo m√°s importante es la <strong>consistencia</strong> y la <strong>comunicaci√≥n clara</strong>.</p>

        <p>Recuerda que cada aplicaci√≥n exitosa en Google Play Store - ya sea Gmail, WhatsApp, o la tuya propia - depende de un sistema robusto de versionado working silently in the background. Invierte tiempo en implementarlo correctamente desde el principio, y te ahorrar√° innumerables horas y dolores de cabeza en el futuro.</p>

        <div class="final-quote">
          <blockquote>
            <p>"El mejor momento para implementar un buen sistema de versionado fue al inicio del proyecto. El segundo mejor momento es ahora."</p>
            <cite>- Sabidur√≠a de desarrolladores Android veteranos</cite>
          </blockquote>
        </div>

        <div class="next-steps-box">
          <h3>üöÄ Pr√≥ximos Pasos Recomendados</h3>
          <ol>
            <li><strong>Audita tu proyecto actual:</strong> ¬øSigue alguna convenci√≥n? ¬øEs autom√°tico?</li>
            <li><strong>Documenta la estrategia:</strong> Escribe las reglas y comp√°rtelas con el equipo</li>
            <li><strong>Implementa automatizaci√≥n b√°sica:</strong> Gradle tasks para bumping versions</li>
            <li><strong>Configura CI/CD:</strong> Builds y deployments autom√°ticos</li>
            <li><strong>Monitorea y mide:</strong> Analytics por versi√≥n, crash rates, adoption</li>
            <li><strong>Itera y mejora:</strong> Refina el proceso bas√°ndote en feedback</li>
            <li><strong>Comparte conocimiento:</strong> Educa al equipo sobre la importancia del versionado</li>
          </ol>
          <p><strong>¬øListo para implementar?</strong> Descarga nuestra <a href="#">plantilla de proyecto Android con versionado autom√°tico</a> y comienza en minutos.</p>
        </div>

        <div class="article-footer">
          <div class="tags">
            <span class="tag">Android</span>
            <span class="tag">Versionado</span>
            <span class="tag">Gradle</span>
            <span class="tag">CI/CD</span>
          </div>
          <div class="share-buttons">
            <a href="#" class="share-btn">Compartir en Twitter</a>
            <a href="#" class="share-btn">Compartir en LinkedIn</a>
          </div>
        </div>
      </div>
    </div>
  </article>

  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-text">
          <p>&copy; 2025 ArceApps. Desarrollado con HTML, CSS y JavaScript.</p>
        </div>
        <div class="footer-links">
          <a href="#" class="footer-link">GitHub</a>
          <a href="#" class="footer-link">LinkedIn</a>
          <a href="#" class="footer-link">Contacto</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>
