<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Null Safety en Android con Kotlin - ArceApps Blog</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-left">
        <div class="nav-logo">
          <h3><a href="../index.html">ArceApps</a></h3>
        </div>
      </div>
      <div class="nav-right">
        <ul class="nav-menu" id="nav-menu">
          <li class="nav-item">
            <a href="../index.html" class="nav-link">Inicio</a>
          </li>
          <li class="nav-item">
            <a href="../about.html" class="nav-link">About</a>
          </li>
          <li class="nav-item">
            <a href="../portfolio.html" class="nav-link">Portfolio</a>
          </li>
          <li class="nav-item">
            <a href="../blog.html" class="nav-link active">Blog</a>
          </li>
        </ul>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
          <div class="theme-toggle-circle">
            <span class="theme-icon">üåô</span>
          </div>
        </button>
        <div class="nav-toggle" id="nav-toggle">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </div>
      </div>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">30 de septiembre de 2026</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>Null Safety en Android con Kotlin: Adi√≥s NullPointerException</h1>
        <p class="article-subtitle">Domina la seguridad nula de Kotlin en Android: desde conceptos b√°sicos hasta patrones avanzados, y descubre c√≥mo eliminar los temidos NPE de tus apps</p>
        <div class="article-image">
          <img src="../images/placeholder-article-null-safety.svg" alt="Kotlin Null Safety Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>üõ°Ô∏è ¬øQu√© es Null Safety?</h2>
        <p><strong>Null Safety</strong> es una caracter√≠stica fundamental de Kotlin que elimina los errores de referencia nula (NullPointerException) en tiempo de compilaci√≥n. A diferencia de Java, donde los NPE son una fuente constante de crashes, Kotlin hace imposible acceder a referencias nulas accidentalmente.</p>

        <p>En el desarrollo <strong>Android con Kotlin</strong>, null safety es especialmente importante porque trabajamos constantemente con datos que pueden no existir: respuestas de API, inputs de usuario, datos de sensores, etc. üöÄ</p>

        <div class="code-block">
          <pre><code>// ‚ùå En Java - Potencial NPE en runtime
String userName = getUser().getName();
int length = userName.length(); // üí• NPE si userName es null

// ‚úÖ En Kotlin - Error detectado en compile time
val userName: String? = getUser()?.name
val length = userName.length() // ‚ùå Error de compilaci√≥n

// ‚úÖ Versi√≥n segura en Kotlin
val length = userName?.length ?: 0 // Safe call + elvis operator</code></pre>
        </div>

        <h2>üéØ ¬øPara qu√© sirve Null Safety?</h2>
        <p>Null safety en Android no es solo una caracter√≠stica t√©cnica, es una herramienta que transforma completamente la experiencia de desarrollo:</p>

        <h3>1. Elimina Crashes por NPE</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ ANDROID: Fragment con null safety
class UserProfileFragment : Fragment() {
    
    private var _binding: FragmentUserProfileBinding? = null
    private val binding get() = _binding!!
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        _binding = FragmentUserProfileBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // ‚úÖ Safe access to arguments
        arguments?.getString(ARG_USER_ID)?.let { userId ->
            loadUserProfile(userId)
        } ?: run {
            // Handle missing user ID
            showError("User ID is required")
            findNavController().popBackStack()
        }
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null // ‚úÖ Prevent memory leaks
    }
}</code></pre>
        </div>

        <h3>2. Hace el C√≥digo M√°s Expresivo</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ ANDROID: ViewModel con null safety expresivo
class ProductListViewModel @Inject constructor(
    private val productRepository: ProductRepository
) : ViewModel() {
    
    private val _products = MutableLiveData<List<Product>?>()
    val products: LiveData<List<Product>?> = _products
    
    private val _selectedProduct = MutableLiveData<Product?>()
    val selectedProduct: LiveData<Product?> = _selectedProduct
    
    fun loadProducts(categoryId: String?) {
        viewModelScope.launch {
            // ‚úÖ El tipo nullable es expl√≠cito
            val result = categoryId?.let { id ->
                productRepository.getProductsByCategory(id)
            } ?: productRepository.getAllProducts()
            
            _products.value = result
        }
    }
    
    fun selectProduct(productId: String?) {
        // ‚úÖ Null safety evita l√≥gica defensiva innecesaria
        productId?.let { id ->
            val product = _products.value?.find { it.id == id }
            _selectedProduct.value = product
        }
    }
    
    // ‚úÖ Property computed con null safety
    val hasProducts: Boolean
        get() = !products.value.isNullOrEmpty()
        
    val selectedProductPrice: String
        get() = selectedProduct.value?.formattedPrice ?: "Precio no disponible"
}</code></pre>
        </div>

        <h3>3. Facilita el Manejo de Estados</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ ANDROID: Estados seguros con sealed classes
sealed class UiState<out T> {
    object Loading : UiState<Nothing>()
    data class Success<T>(val data: T) : UiState<T>()
    data class Error(val message: String) : UiState<Nothing>()
}

class UserRepository @Inject constructor(
    private val apiService: UserApiService,
    private val userDao: UserDao
) {
    suspend fun getUserProfile(userId: String): UiState<User> {
        return try {
            // ‚úÖ API response puede ser null
            val userResponse = apiService.getUser(userId)
            val user = userResponse?.body()
            
            when {
                user != null -> {
                    userDao.insertUser(user)
                    UiState.Success(user)
                }
                userResponse?.isSuccessful == true -> {
                    UiState.Error("User data is empty")
                }
                else -> {
                    UiState.Error("Network error: ${userResponse?.message()}")
                }
            }
        } catch (e: Exception) {
            UiState.Error("Unexpected error: ${e.localizedMessage}")
        }
    }
}</code></pre>
        </div>

        <h2>‚úÖ Cu√°ndo se Recomienda su Uso</h2>
        <div class="recommendations">
          <div class="recommendation-item">
            <div class="recommendation-icon">üåê</div>
            <div class="recommendation-content">
              <h4>APIs y Datos Remotos</h4>
              <p>Siempre usar tipos nullable para respuestas de API que pueden fallar o estar vac√≠as</p>
            </div>
          </div>
          
          <div class="recommendation-item">
            <div class="recommendation-icon">üì±</div>
            <div class="recommendation-content">
              <h4>UI Components</h4>
              <p>View binding, argumentos de Fragment, y referencias a vistas que pueden no existir</p>
            </div>
          </div>
          
          <div class="recommendation-item">
            <div class="recommendation-icon">üíæ</div>
            <div class="recommendation-content">
              <h4>Persistencia Local</h4>
              <p>Datos de Room, SharedPreferences, y archivos que pueden no existir</p>
            </div>
          </div>
          
          <div class="recommendation-item">
            <div class="recommendation-icon">üîÑ</div>
            <div class="recommendation-content">
              <h4>Estados Transitorios</h4>
              <p>Loading states, cache temporal, y datos que cambian de disponibilidad</p>
            </div>
          </div>
        </div>

        <h2>‚ùå Cu√°ndo est√° Desaconsejado</h2>
        <p>Aunque null safety es una caracter√≠stica poderosa, hay situaciones donde su mal uso puede complicar el c√≥digo:</p>

        <h3>1. Null Safety Falso con !! (Not-null assertion)</h3>
        <div class="code-block">
          <pre><code>// ‚ùå MAL USO: Abuso del not-null assertion operator
class BadUserFragment : Fragment() {
    
    private var binding: FragmentUserBinding? = null
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // ‚ùå PELIGROSO: Puede causar NPE
        val userId = arguments!!.getString(ARG_USER_ID)!!
        val user = userRepository.getUser(userId)!!
        
        binding!!.tvUserName.text = user.name!!
        binding!!.tvEmail.text = user.email!!
    }
}

// ‚úÖ MEJOR: Manejo seguro y expl√≠cito
class GoodUserFragment : Fragment() {
    
    private var _binding: FragmentUserBinding? = null
    private val binding get() = _binding!!
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        val userId = arguments?.getString(ARG_USER_ID)
        if (userId == null) {
            showError("User ID is required")
            return
        }
        
        viewModel.loadUser(userId)
        observeUserData()
    }
}</code></pre>
        </div>

        <h3>2. Tipos Nullable Innecesarios</h3>
        <div class="code-block">
          <pre><code>// ‚ùå MAL USO: Nullables innecesarios
data class UserProfile(
    val id: String?,          // ‚ùå Un ID siempre deber√≠a existir
    val name: String?,        // ‚ùå Un nombre siempre deber√≠a existir
    val email: String?,       // ‚ùå Un email siempre deber√≠a existir
    val avatar: String?       // ‚úÖ OK - El avatar puede no existir
)

// ‚úÖ MEJOR: Nullables solo donde tiene sentido
data class UserProfile(
    val id: String,           // ‚úÖ Non-null: siempre debe existir
    val name: String,         // ‚úÖ Non-null: siempre debe existir  
    val email: String,        // ‚úÖ Non-null: siempre debe existir
    val avatar: String?,      // ‚úÖ Nullable: puede no tener avatar
    val bio: String?,         // ‚úÖ Nullable: puede no tener bio
    val phoneNumber: String?  // ‚úÖ Nullable: puede no tener tel√©fono
)</code></pre>
        </div>

        <h3>3. Complicaci√≥n Innecesaria de APIs</h3>
        <div class="code-block">
          <pre><code>// ‚ùå MAL USO: API confusa con nullables
interface UserRepository {
    suspend fun getUser(id: String?): User?
    suspend fun updateUser(user: User?): Boolean?
    suspend fun deleteUser(id: String?): Unit?
}

// ‚úÖ MEJOR: API clara con tipos apropiados
interface UserRepository {
    suspend fun getUser(id: String): User?           // ID never null, User might not exist
    suspend fun updateUser(user: User): Boolean      // User never null, operation succeeds/fails
    suspend fun deleteUser(id: String): Unit         // ID never null, operation always completes
}</code></pre>
        </div>

        <h2>‚ö†Ô∏è Malas Pr√°cticas y Diferencias con Java</h2>
        <p>Al migrar de Java a Kotlin para Android, es com√∫n caer en antipatrones que eliminan los beneficios de null safety:</p>

        <h3>1. Mentalidad Defensiva de Java</h3>
        <div class="code-block">
          <pre><code>// ‚ùå JAVA MINDSET: Exceso de null checks innecesarios
fun displayUserInfo(user: User) {
    // ‚ùå Kotlin ya garantiza que user no es null
    if (user != null) {
        if (user.name != null) {
            binding.tvName.text = user.name
        }
        if (user.email != null) {
            binding.tvEmail.text = user.email
        }
    }
}

// ‚úÖ KOTLIN MINDSET: Conf√≠a en el sistema de tipos
fun displayUserInfo(user: User) {
    // ‚úÖ user es non-null por definici√≥n
    binding.tvName.text = user.name
    binding.tvEmail.text = user.email
    
    // ‚úÖ Solo check nulls donde realmente pueden ser null
    user.avatar?.let { avatarUrl ->
        binding.ivAvatar.load(avatarUrl)
    }
}</code></pre>
        </div>

        <h3>2. Comparaci√≥n: Java vs Kotlin Null Handling</h3>
        <div class="code-block">
          <pre><code>// ‚ùå JAVA: Null checks manuales propensos a errores
public class UserManager {
    public String getUserDisplayName(User user) {
        if (user != null) {
            String firstName = user.getFirstName();
            String lastName = user.getLastName();
            
            if (firstName != null && lastName != null) {
                return firstName + " " + lastName;
            } else if (firstName != null) {
                return firstName;
            } else if (lastName != null) {
                return lastName;
            }
        }
        return "Unknown User";
    }
}

// ‚úÖ KOTLIN: Null safety expresivo y seguro
class UserManager {
    fun getUserDisplayName(user: User?): String {
        return user?.let { u ->
            listOfNotNull(u.firstName, u.lastName)
                .takeIf { it.isNotEmpty() }
                ?.joinToString(" ")
        } ?: "Unknown User"
    }
    
    // O m√°s simple:
    fun getUserDisplayNameSimple(user: User?): String {
        val first = user?.firstName
        val last = user?.lastName
        
        return when {
            first != null && last != null -> "$first $last"
            first != null -> first
            last != null -> last
            else -> "Unknown User"
        }
    }
}</code></pre>
        </div>

        <h3>3. Platform Types: Peligro en Interoperabilidad</h3>
        <div class="code-block">
          <pre><code>// ‚ö†Ô∏è PLATFORM TYPES: Java interop sin null safety
// Java class
public class JavaUserService {
    public User getUser(String id) {
        // Puede devolver null sin anotaciones
        return repository.findUser(id);
    }
}

// ‚ùå MAL USO en Kotlin: Asumir non-null
class UserViewModel(private val javaService: JavaUserService) {
    fun loadUser(id: String) {
        // ‚ùå PELIGROSO: Platform type puede ser null
        val user = javaService.getUser(id) // User! (platform type)
        displayUser(user) // üí• Potencial NPE
    }
}

// ‚úÖ MEJOR: Defensive approach con platform types
class UserViewModel(private val javaService: JavaUserService) {
    fun loadUser(id: String) {
        // ‚úÖ SEGURO: Tratar platform types como nullable
        val user: User? = javaService.getUser(id)
        user?.let { displayUser(it) }
    }
}</code></pre>
        </div>

        <h2>üéØ Patrones Avanzados de Null Safety en Android</h2>
        
        <h3>1. Repository Pattern con Null Safety</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ PATR√ìN: Repository con manejo seguro de m√∫ltiples fuentes
class UserRepository @Inject constructor(
    private val apiService: UserApiService,
    private val userDao: UserDao,
    private val preferencesManager: PreferencesManager
) {
    suspend fun getUserProfile(userId: String, forceRefresh: Boolean = false): User? {
        // ‚úÖ Cache first strategy con null safety
        val cachedUser = if (!forceRefresh) userDao.getUser(userId) else null
        
        return cachedUser ?: run {
            // ‚úÖ Network fallback con manejo de errores
            try {
                val networkUser = apiService.getUser(userId).body()
                networkUser?.also { user ->
                    userDao.insertUser(user)
                    preferencesManager.setLastSyncTime(System.currentTimeMillis())
                }
            } catch (e: Exception) {
                // ‚úÖ Fallback al cache aunque sea viejo
                userDao.getUser(userId)
            }
        }
    }
    
    // ‚úÖ Flow con null safety para updates reactivos
    fun getUserProfileFlow(userId: String): Flow<User?> {
        return userDao.getUserFlow(userId)
            .distinctUntilChanged()
            .onEach { user ->
                // ‚úÖ Auto-refresh si datos son muy viejos
                if (user == null || isDataStale(user.lastUpdated)) {
                    refreshUserProfile(userId)
                }
            }
    }
}</code></pre>
        </div>

        <h3>2. ViewModel con Estados Null-Safe</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ PATR√ìN: ViewModel con estados tipados y null safety
class UserProfileViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    // ‚úÖ Estados expl√≠citos en lugar de nulls confusos
    private val _uiState = MutableStateFlow<UserProfileUiState>(UserProfileUiState.Loading)
    val uiState: StateFlow<UserProfileUiState> = _uiState.asStateFlow()
    
    // ‚úÖ User actual separado del estado de UI
    private val _currentUser = MutableStateFlow<User?>(null)
    val currentUser: StateFlow<User?> = _currentUser.asStateFlow()
    
    fun loadUserProfile(userId: String) {
        viewModelScope.launch {
            _uiState.value = UserProfileUiState.Loading
            
            try {
                val user = userRepository.getUserProfile(userId)
                
                if (user != null) {
                    _currentUser.value = user
                    _uiState.value = UserProfileUiState.Success(user)
                } else {
                    _uiState.value = UserProfileUiState.Error("User not found")
                }
            } catch (e: Exception) {
                _uiState.value = UserProfileUiState.Error(
                    e.localizedMessage ?: "Unknown error occurred"
                )
            }
        }
    }
    
    // ‚úÖ Computed properties con null safety
    val userDisplayName: String
        get() = currentUser.value?.let { user ->
            "${user.firstName} ${user.lastName}".trim()
        } ?: "Unknown User"
        
    val hasProfileImage: Boolean
        get() = !currentUser.value?.profileImageUrl.isNullOrBlank()
}

sealed class UserProfileUiState {
    object Loading : UserProfileUiState()
    data class Success(val user: User) : UserProfileUiState()
    data class Error(val message: String) : UserProfileUiState()
}</code></pre>
        </div>

        <h3>3. Fragment con Lifecycle-Aware Null Safety</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ PATR√ìN: Fragment con null safety y lifecycle awareness
class UserProfileFragment : Fragment() {
    
    private var _binding: FragmentUserProfileBinding? = null
    private val binding get() = _binding!!
    
    private val viewModel: UserProfileViewModel by viewModels()
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentUserProfileBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        // ‚úÖ Safe argument extraction
        val userId = arguments?.getString(ARG_USER_ID)
        if (userId.isNullOrBlank()) {
            showErrorAndNavigateBack("User ID is required")
            return
        }
        
        setupUI()
        observeViewModel()
        viewModel.loadUserProfile(userId)
    }
    
    private fun observeViewModel() {
        // ‚úÖ Lifecycle-aware observation
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collect { state ->
                when (state) {
                    is UserProfileUiState.Loading -> showLoading(true)
                    is UserProfileUiState.Success -> {
                        showLoading(false)
                        displayUser(state.user)
                    }
                    is UserProfileUiState.Error -> {
                        showLoading(false)
                        showError(state.message)
                    }
                }
            }
        }
        
        // ‚úÖ Separate observation for user changes
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.currentUser.collect { user ->
                // ‚úÖ Update UI elements that depend on user
                updateNavigationTitle(user?.displayName)
                updateShareButton(user != null)
            }
        }
    }
    
    private fun displayUser(user: User) {
        binding.apply {
            tvUserName.text = user.displayName
            tvEmail.text = user.email
            
            // ‚úÖ Conditional UI updates
            user.profileImageUrl?.let { imageUrl ->
                ivProfileImage.load(imageUrl) {
                    placeholder(R.drawable.ic_placeholder_user)
                    error(R.drawable.ic_error_user)
                }
            } ?: run {
                ivProfileImage.setImageResource(R.drawable.ic_default_user)
            }
            
            // ‚úÖ Optional field handling
            user.bio?.let { bio ->
                tvBio.text = bio
                tvBio.isVisible = true
            } ?: run {
                tvBio.isVisible = false
            }
        }
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null // ‚úÖ Prevent memory leaks
    }
    
    companion object {
        private const val ARG_USER_ID = "user_id"
        
        fun newInstance(userId: String): UserProfileFragment {
            return UserProfileFragment().apply {
                arguments = bundleOf(ARG_USER_ID to userId)
            }
        }
    }
}</code></pre>
        </div>

        <h2>üõ†Ô∏è Herramientas y Operadores Esenciales</h2>
        <div class="tools-grid">
          <div class="tool-card">
            <h4>Safe Call (?. )</h4>
            <p>Llama un m√©todo solo si el objeto no es null</p>
            <code>user?.name</code>
          </div>
          
          <div class="tool-card">
            <h4>Elvis Operator (?:)</h4>
            <p>Proporciona un valor por defecto si es null</p>
            <code>user?.name ?: "Unknown"</code>
          </div>
          
          <div class="tool-card">
            <h4>Not-null Assertion (!!)</h4>
            <p>Convierte nullable a non-null (usar con cuidado)</p>
            <code>user!!.name</code>
          </div>
          
          <div class="tool-card">
            <h4>Safe Cast (as?)</h4>
            <p>Cast seguro que devuelve null si falla</p>
            <code>obj as? String</code>
          </div>
        </div>

        <div class="conclusion">
          <h3>üéØ Conclusi√≥n</h3>
          <p><strong>Null Safety en Kotlin</strong> no es solo una caracter√≠stica del lenguaje, es una filosof√≠a de desarrollo que transforma c√≥mo construimos apps Android. Al adoptar null safety correctamente, eliminamos una de las principales fuentes de crashes y creamos c√≥digo m√°s expresivo y mantenible.</p>
          
          <p>Las ventajas sobre Java son claras:</p>
          <ul>
            <li><strong>Compile-time safety:</strong> Los NPE se detectan antes de llegar a producci√≥n</li>
            <li><strong>C√≥digo m√°s expresivo:</strong> Los tipos declaran expl√≠citamente la posibilidad de null</li>
            <li><strong>Menos c√≥digo defensivo:</strong> No necesitas null checks en every line</li>
            <li><strong>Better IDE support:</strong> El IDE puede ayudarte mejor cuando sabe qu√© puede ser null</li>
          </ul>
          
          <p>Recuerda: <strong>null safety es un contrato</strong> entre t√∫ y el compilador. √ösalo sabiamente y tu c√≥digo Android ser√° m√°s robusto y profesional.</p>
        </div>

        <div class="next-steps">
          <h3>üöÄ Pr√≥ximos pasos recomendados</h3>
          <ol>
            <li>Audita tu c√≥digo existente buscando usos innecesarios de !!</li>
            <li>Migra tus Java classes a Kotlin con null annotations</li>
            <li>Implementa sealed classes para estados en lugar de nulls</li>
            <li>Configura detekt/ktlint para detectar null safety antipatterns</li>
            <li>Aprende sobre scope functions (.let, .also, .apply, .run)</li>
            <li>Domina Flow y StateFlow para manejo reactivo de nullables</li>
            <li>Implementa Result types para error handling avanzado</li>
          </ol>
        </div>

        <div class="article-footer">
          <div class="tags">
            <span class="tag">Android</span>
            <span class="tag">Kotlin</span>
            <span class="tag">Null Safety</span>
            <span class="tag">NullPointerException</span>
            <span class="tag">Safe Calls</span>
            <span class="tag">Elvis Operator</span>
            <span class="tag">Best Practices</span>
            <span class="tag">Java Migration</span>
          </div>
          <div class="share-buttons">
            <a href="#" class="share-btn">Compartir en Twitter</a>
            <a href="#" class="share-btn">Compartir en LinkedIn</a>
          </div>
        </div>
      </div>
    </div>
  </article>

  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-text">
          <p>&copy; 2025 ArceApps. Desarrollado con HTML, CSS y JavaScript.</p>
        </div>
        <div class="footer-links">
          <a href="#" class="footer-link">GitHub</a>
          <a href="#" class="footer-link">LinkedIn</a>
          <a href="#" class="footer-link">Contacto</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>