<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ViewModel en MVVM Android: El Puente Inteligente Entre UI y Lógica - ArceApps Blog</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-left">
        <div class="nav-logo">
          <h3><a href="../index.html">ArceApps</a></h3>
        </div>
      </div>
      <div class="nav-right">
        <ul class="nav-menu" id="nav-menu">
          <li class="nav-item">
            <a href="../index.html" class="nav-link">Inicio</a>
          </li>
          <li class="nav-item">
            <a href="../about.html" class="nav-link">About</a>
          </li>
          <li class="nav-item">
            <a href="../portfolio.html" class="nav-link">Portfolio</a>
          </li>
          <li class="nav-item">
            <a href="../blog.html" class="nav-link active">Blog</a>
          </li>
        </ul>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
          <div class="theme-toggle-circle">
            <span class="theme-icon">🌙</span>
          </div>
        </button>
        <div class="nav-toggle" id="nav-toggle">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </div>
      </div>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">25 de julio de 2025</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>ViewModel en MVVM Android: El Puente Inteligente Entre UI y Lógica</h1>
        <p class="article-subtitle">Domina la capa ViewModel en PuzzleQuest: gestión de estado, comunicación reactiva, manejo del lifecycle y patterns avanzados para crear ViewModels robustos y escalables</p>
        <div class="article-image">
          <img src="../images/placeholder-article-viewmodel.svg" alt="ViewModel MVVM Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>🎭 ¿Qué es el ViewModel en MVVM?</h2>
        <p>El ViewModel es el <strong>director de orquesta</strong> en nuestra app PuzzleQuest. Actúa como intermediario inteligente entre la UI (Activities/Fragments) y la capa Model, gestionando el estado de la pantalla, coordinando llamadas a Use Cases, y exponiendo datos de forma reactiva. Es la pieza que hace que MVVM sea tan poderoso para Android.</p>

        <div class="viewmodel-definition">
          <h3>🎯 Responsabilidades del ViewModel</h3>
          <div class="responsibilities-grid">
            <div class="responsibility-card">
              <div class="responsibility-icon">🔄</div>
              <h4>Gestión de Estado</h4>
              <p>Mantiene y gestiona el estado de la UI</p>
            </div>
            <div class="responsibility-card">
              <div class="responsibility-icon">🎬</div>
              <h4>Orquestación</h4>
              <p>Coordina Use Cases y transformaciones</p>
            </div>
            <div class="responsibility-card">
              <div class="responsibility-icon">📡</div>
              <h4>Comunicación Reactiva</h4>
              <p>Expone streams de datos observables</p>
            </div>
            <div class="responsibility-card">
              <div class="responsibility-icon">🔄</div>
              <h4>Lifecycle Awareness</h4>
              <p>Sobrevive a cambios de configuración</p>
            </div>
          </div>
        </div>

        <h2>🏗️ Arquitectura del ViewModel en PuzzleQuest</h2>
        
        <div class="architecture-diagram">
          <h3>📊 Flujo de Datos con ViewModel</h3>
          <div class="viewmodel-flow">
            <div class="flow-layer">
              <h4>UI Layer</h4>
              <div class="flow-components">
                <div class="component">Fragment/Activity</div>
                <div class="component">Compose UI</div>
              </div>
            </div>
            <div class="flow-separator">⬆️ UI State<br/>⬇️ UI Events</div>
            <div class="flow-layer">
              <h4>ViewModel Layer</h4>
              <div class="flow-components">
                <div class="component">State Management</div>
                <div class="component">Event Handling</div>
                <div class="component">Data Transformation</div>
              </div>
            </div>
            <div class="flow-separator">⬇️ Use Case Calls<br/>⬆️ Data Streams</div>
            <div class="flow-layer">
              <h4>Domain Layer</h4>
              <div class="flow-components">
                <div class="component">Use Cases</div>
                <div class="component">Repository</div>
              </div>
            </div>
          </div>
        </div>

        <h2>🎮 ViewModel para Juego de Puzzles: GameViewModel</h2>

        <p>Implementemos el ViewModel más complejo de PuzzleQuest - el que maneja la lógica del juego:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/game/GameViewModel.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">📋 Copiar</button>
          </div>
          <pre><code class="language-kotlin">@HiltViewModel
class GameViewModel @Inject constructor(
    private val startPuzzleGameUseCase: StartPuzzleGameUseCase,
    private val movePuzzlePieceUseCase: MovePuzzlePieceUseCase,
    private val saveGameProgressUseCase: SaveGameProgressUseCase,
    private val pauseGameUseCase: PauseGameUseCase,
    private val completePuzzleUseCase: CompletePuzzleUseCase,
    private val getHintUseCase: GetHintUseCase,
    private val analyticsTracker: AnalyticsTracker,
    private val soundManager: SoundManager,
    private val hapticFeedback: HapticFeedback,
    savedStateHandle: SavedStateHandle
) : ViewModel() {
    
    // ========== State Management ==========
    
    private val puzzleId: String = savedStateHandle.get&lt;String&gt;("puzzleId") 
        ?: throw IllegalArgumentException("puzzleId is required")
    
    // UI State principal
    private val _uiState = MutableStateFlow(GameUiState())
    val uiState: StateFlow&lt;GameUiState&gt; = _uiState.asStateFlow()
    
    // Estados específicos para diferentes aspectos del juego
    private val _gameState = MutableStateFlow&lt;GameState?&gt;(null)
    val gameState: StateFlow&lt;GameState?&gt; = _gameState.asStateFlow()
    
    private val _timerState = MutableStateFlow(TimerState())
    val timerState: StateFlow&lt;TimerState&gt; = _timerState.asStateFlow()
    
    // Eventos de UI (one-time events)
    private val _uiEvents = Channel&lt;GameUiEvent&gt;(Channel.BUFFERED)
    val uiEvents: Flow&lt;GameUiEvent&gt; = _uiEvents.receiveAsFlow()
    
    // Timer para el cronómetro del juego
    private var gameTimer: Job? = null
    
    // ========== Lifecycle ==========
    
    init {
        // Inicializar el juego automáticamente
        initializeGame()
        
        // Observar cambios en el estado del juego para react a eventos importantes
        observeGameState()
    }
    
    override fun onCleared() {
        super.onCleared()
        // Cleanup resources
        cancelGameTimer()
        
        // Auto-save si hay un juego en progreso
        _gameState.value?.let { gameState ->
            if (gameState.isActive) {
                viewModelScope.launch {
                    saveGameProgressUseCase(SaveGameProgressUseCase.Params(gameState))
                }
            }
        }
    }
    
    // ========== Initialization ==========
    
    private fun initializeGame() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            val params = StartPuzzleGameUseCase.Params(
                puzzleId = PuzzleId(puzzleId),
                userLevel = getCurrentUserLevel(),
                forceRestart = false
            )
            
            startPuzzleGameUseCase(params)
                .onSuccess { gameSession ->
                    val initialGameState = gameSession.toGameState()
                    _gameState.value = initialGameState
                    
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            puzzle = gameSession.puzzle,
                            errorMessage = null
                        )
                    }
                    
                    startGameTimer()
                    
                    analyticsTracker.track("game_initialized", mapOf(
                        "puzzle_id" to puzzleId,
                        "was_resumed" to gameSession.isResumed
                    ))
                }
                .onFailure { exception ->
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            errorMessage = exception.message ?: "Error desconocido"
                        )
                    }
                    
                    _uiEvents.trySend(GameUiEvent.ShowError(exception.message ?: "Error al cargar el puzzle"))
                }
        }
    }
    
    private fun observeGameState() {
        viewModelScope.launch {
            _gameState.collect { gameState ->
                gameState?.let { state ->
                    // Update timer state
                    _timerState.update { 
                        it.copy(
                            elapsedTimeMs = state.elapsedTimeMs,
                            isRunning = state.isActive
                        )
                    }
                    
                    // Check for puzzle completion
                    if (puzzleGameEngine.isPuzzleCompleted(state)) {
                        handlePuzzleCompletion(state)
                    }
                    
                    // Auto-save progress periodically
                    if (state.moveCount % 5 == 0 && state.moveCount > 0) {
                        autoSaveProgress(state)
                    }
                }
            }
        }
    }
    
    // ========== User Actions ==========
    
    fun onPieceClicked(pieceId: PieceId) {
        val currentState = _gameState.value ?: return
        
        if (!currentState.isActive) {
            _uiEvents.trySend(GameUiEvent.ShowMessage("El juego está pausado"))
            return
        }
        
        // Determinar posición objetivo (espacio vacío)
        val emptyPosition = currentState.getEmptyPosition()
        val piece = currentState.getPiece(pieceId) ?: return
        
        // Verificar si el movimiento es válido
        if (!piece.currentPosition.isAdjacentTo(emptyPosition)) {
            // Piece not adjacent to empty space
            hapticFeedback.performInvalidMove()
            soundManager.playInvalidMoveSound()
            _uiEvents.trySend(GameUiEvent.ShowPieceError(pieceId))
            return
        }
        
        // Ejecutar movimiento
        movePiece(pieceId, emptyPosition)
    }
    
    private fun movePiece(pieceId: PieceId, targetPosition: Position) {
        viewModelScope.launch {
            val currentState = _gameState.value ?: return@launch
            
            // Update UI inmediatamente para mejor responsiveness
            _uiState.update { it.copy(isProcessingMove = true) }
            
            val params = MovePuzzlePieceUseCase.Params(
                puzzleId = PuzzleId(puzzleId),
                fromPosition = currentState.getPiece(pieceId)?.currentPosition ?: return@launch,
                toPosition = targetPosition
            )
            
            movePuzzlePieceUseCase(params)
                .onSuccess { moveResult ->
                    when (moveResult) {
                        is MoveResult.ValidMove -> {
                            _gameState.value = moveResult.gameSession.toGameState()
                            
                            // UI feedback
                            hapticFeedback.performValidMove()
                            soundManager.playValidMoveSound()
                            
                            _uiEvents.trySend(GameUiEvent.PieceMovedSuccessfully(pieceId))
                        }
                        
                        is MoveResult.Invalid -> {
                            hapticFeedback.performInvalidMove()
                            soundManager.playInvalidMoveSound()
                            _uiEvents.trySend(GameUiEvent.ShowError(moveResult.reason))
                        }
                        
                        is MoveResult.PuzzleCompleted -> {
                            _gameState.value = moveResult.gameSession.toGameState()
                            // Completion will be handled by observeGameState()
                        }
                    }
                }
                .onFailure { exception ->
                    _uiEvents.trySend(GameUiEvent.ShowError(exception.message ?: "Error al mover pieza"))
                }
                .also {
                    _uiState.update { it.copy(isProcessingMove = false) }
                }
        }
    }
    
    fun onPauseGame() {
        viewModelScope.launch {
            val currentState = _gameState.value ?: return@launch
            
            if (!currentState.isActive) return@launch
            
            pauseGameUseCase(PauseGameUseCase.Params(currentState))
                .onSuccess { pausedState ->
                    _gameState.value = pausedState
                    cancelGameTimer()
                    
                    _uiEvents.trySend(GameUiEvent.GamePaused)
                    
                    analyticsTracker.track("game_paused", mapOf(
                        "puzzle_id" to puzzleId,
                        "move_count" to currentState.moveCount,
                        "elapsed_time_ms" to currentState.elapsedTimeMs
                    ))
                }
        }
    }
    
    fun onResumeGame() {
        val currentState = _gameState.value ?: return
        
        if (currentState.isPaused) {
            _gameState.update { it?.copy(status = GameStatus.ACTIVE) }
            startGameTimer()
            
            _uiEvents.trySend(GameUiEvent.GameResumed)
            
            analyticsTracker.track("game_resumed", mapOf(
                "puzzle_id" to puzzleId
            ))
        }
    }
    
    fun onRequestHint() {
        viewModelScope.launch {
            val currentState = _gameState.value ?: return@launch
            
            if (currentState.hintsUsed >= currentState.maxHints) {
                _uiEvents.trySend(GameUiEvent.ShowMessage("No tienes más pistas disponibles"))
                return@launch
            }
            
            _uiState.update { it.copy(isLoadingHint = true) }
            
            getHintUseCase(GetHintUseCase.Params(currentState))
                .onSuccess { hint ->
                    _gameState.update { 
                        it?.copy(hintsUsed = it.hintsUsed + 1) 
                    }
                    
                    _uiEvents.trySend(GameUiEvent.ShowHint(hint))
                    
                    analyticsTracker.track("hint_used", mapOf(
                        "puzzle_id" to puzzleId,
                        "hint_number" to currentState.hintsUsed + 1,
                        "move_count" to currentState.moveCount
                    ))
                }
                .onFailure { exception ->
                    _uiEvents.trySend(GameUiEvent.ShowError("No se pudo generar una pista"))
                }
                .also {
                    _uiState.update { it.copy(isLoadingHint = false) }
                }
        }
    }
    
    fun onRestartGame() {
        viewModelScope.launch {
            // Confirm restart with user first
            _uiEvents.trySend(GameUiEvent.ConfirmRestart { confirmed ->
                if (confirmed) {
                    performRestart()
                }
            })
        }
    }
    
    private fun performRestart() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            val params = StartPuzzleGameUseCase.Params(
                puzzleId = PuzzleId(puzzleId),
                userLevel = getCurrentUserLevel(),
                forceRestart = true
            )
            
            startPuzzleGameUseCase(params)
                .onSuccess { gameSession ->
                    _gameState.value = gameSession.toGameState()
                    
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            puzzle = gameSession.puzzle
                        )
                    }
                    
                    startGameTimer()
                    
                    _uiEvents.trySend(GameUiEvent.GameRestarted)
                    
                    analyticsTracker.track("game_restarted", mapOf(
                        "puzzle_id" to puzzleId
                    ))
                }
                .onFailure { exception ->
                    _uiState.update { 
                        it.copy(
                            isLoading = false,
                            errorMessage = exception.message
                        )
                    }
                }
        }
    }
    
    // ========== Game Timer ==========
    
    private fun startGameTimer() {
        cancelGameTimer()
        
        gameTimer = viewModelScope.launch {
            while (true) {
                delay(1000) // Update every second
                
                val currentState = _gameState.value
                if (currentState?.isActive == true) {
                    val newElapsedTime = System.currentTimeMillis() - currentState.startTime
                    
                    _gameState.update { 
                        it?.copy(elapsedTimeMs = newElapsedTime) 
                    }
                    
                    _timerState.update { 
                        it.copy(elapsedTimeMs = newElapsedTime) 
                    }
                } else {
                    break // Exit timer loop if game is not active
                }
            }
        }
    }
    
    private fun cancelGameTimer() {
        gameTimer?.cancel()
        gameTimer = null
    }
    
    // ========== Game Completion ==========
    
    private fun handlePuzzleCompletion(gameState: GameState) {
        viewModelScope.launch {
            cancelGameTimer()
            
            _uiState.update { it.copy(isProcessingCompletion = true) }
            
            // Trigger completion haptics and sound
            hapticFeedback.performPuzzleCompletion()
            soundManager.playCompletionSound()
            
            // Show completion animation
            _uiEvents.trySend(GameUiEvent.StartCompletionAnimation)
            
            // Process completion through use case
            val params = CompletePuzzleUseCase.Params(
                puzzleId = PuzzleId(puzzleId),
                finalGameState = gameState
            )
            
            completePuzzleUseCase(params)
                .onSuccess { completionResult ->
                    _uiState.update { 
                        it.copy(
                            isProcessingCompletion = false,
                            completionResult = completionResult
                        )
                    }
                    
                    _uiEvents.trySend(GameUiEvent.PuzzleCompleted(completionResult))
                    
                    // Show achievements if any
                    if (completionResult.hasNewAchievements) {
                        completionResult.newAchievements.forEach { achievement ->
                            _uiEvents.trySend(GameUiEvent.ShowAchievement(achievement))
                        }
                    }
                    
                    analyticsTracker.track("puzzle_completed", mapOf(
                        "puzzle_id" to puzzleId,
                        "completion_time_ms" to gameState.elapsedTimeMs,
                        "move_count" to gameState.moveCount,
                        "hints_used" to gameState.hintsUsed,
                        "score" to completionResult.score.totalPoints
                    ))
                }
                .onFailure { exception ->
                    _uiState.update { 
                        it.copy(
                            isProcessingCompletion = false,
                            errorMessage = exception.message
                        )
                    }
                    
                    _uiEvents.trySend(GameUiEvent.ShowError("Error al procesar la finalización"))
                }
        }
    }
    
    // ========== Auto-save ==========
    
    private fun autoSaveProgress(gameState: GameState) {
        viewModelScope.launch {
            try {
                saveGameProgressUseCase(SaveGameProgressUseCase.Params(gameState))
            } catch (e: Exception) {
                // Silent fail for auto-save - don't disrupt user experience
                Timber.w(e, "Failed to auto-save progress")
            }
        }
    }
    
    // ========== Helper Methods ==========
    
    private fun getCurrentUserLevel(): Int {
        // Simplified - in real app, get from user repository
        return 1
    }
    
    // ========== Error Handling ==========
    
    fun onErrorShown() {
        _uiState.update { it.copy(errorMessage = null) }
    }
    
    // ========== State Classes ==========
    
    data class GameUiState(
        val isLoading: Boolean = false,
        val puzzle: Puzzle? = null,
        val isProcessingMove: Boolean = false,
        val isLoadingHint: Boolean = false,
        val isProcessingCompletion: Boolean = false,
        val completionResult: PuzzleCompletionResult? = null,
        val errorMessage: String? = null
    ) {
        val isGameReady: Boolean get() = puzzle != null && !isLoading
        val canInteract: Boolean get() = isGameReady && !isProcessingMove && !isProcessingCompletion
    }
    
    data class TimerState(
        val elapsedTimeMs: Long = 0,
        val isRunning: Boolean = false
    ) {
        val formattedTime: String
            get() {
                val seconds = elapsedTimeMs / 1000
                val minutes = seconds / 60
                val remainingSeconds = seconds % 60
                return "%02d:%02d".format(minutes, remainingSeconds)
            }
    }
    
    // ========== UI Events ==========
    
    sealed class GameUiEvent {
        object GamePaused : GameUiEvent()
        object GameResumed : GameUiEvent()
        object GameRestarted : GameUiEvent()
        object StartCompletionAnimation : GameUiEvent()
        
        data class ShowMessage(val message: String) : GameUiEvent()
        data class ShowError(val error: String) : GameUiEvent()
        data class ShowHint(val hint: PuzzleHint) : GameUiEvent()
        
        data class PieceMovedSuccessfully(val pieceId: PieceId) : GameUiEvent()
        data class ShowPieceError(val pieceId: PieceId) : GameUiEvent()
        
        data class PuzzleCompleted(val result: PuzzleCompletionResult) : GameUiEvent()
        data class ShowAchievement(val achievement: Achievement) : GameUiEvent()
        
        data class ConfirmRestart(val onConfirm: (Boolean) -> Unit) : GameUiEvent()
    }
}

// Extension function to convert GameSession to GameState
private fun GameSession.toGameState(): GameState {
    return GameState(
        puzzleId = PuzzleId(this.puzzleId),
        pieces = this.currentPieces,
        gridSize = this.puzzle.gameConfiguration.gridSize,
        difficulty = this.puzzle.gameConfiguration.difficulty,
        startTime = this.startTime,
        moveCount = this.movesCount,
        hintsUsed = this.hintsUsed,
        maxHints = this.puzzle.gameConfiguration.maxHints,
        elapsedTimeMs = this.elapsedTimeMs ?: 0,
        status = when (this.status) {
            GameSessionStatus.ACTIVE -> GameStatus.ACTIVE
            GameSessionStatus.PAUSED -> GameStatus.PAUSED
            GameSessionStatus.COMPLETED -> GameStatus.COMPLETED
            GameSessionStatus.ABANDONED -> GameStatus.ABANDONED
        }
    )
}</code></pre>
        </div>

        <h2>📋 ViewModel para Lista de Puzzles: PuzzleListViewModel</h2>

        <p>Un ViewModel más simple que maneja la lista de puzzles disponibles:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/puzzlelist/PuzzleListViewModel.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">📋 Copiar</button>
          </div>
          <pre><code class="language-kotlin">@HiltViewModel
class PuzzleListViewModel @Inject constructor(
    private val getPuzzleListUseCase: GetPuzzleListUseCase,
    private val searchPuzzlesUseCase: SearchPuzzlesUseCase,
    private val filterPuzzlesUseCase: FilterPuzzlesUseCase,
    private val userPreferencesRepository: UserPreferencesRepository,
    private val analyticsTracker: AnalyticsTracker
) : ViewModel() {
    
    // ========== Search & Filter State ==========
    
    private val _searchQuery = MutableStateFlow("")
    val searchQuery: StateFlow&lt;String&gt; = _searchQuery.asStateFlow()
    
    private val _selectedFilters = MutableStateFlow(PuzzleFilters())
    val selectedFilters: StateFlow&lt;PuzzleFilters&gt; = _selectedFilters.asStateFlow()
    
    private val _sortOption = MutableStateFlow(PuzzleSortBy.CREATED_DATE)
    val sortOption: StateFlow&lt;PuzzleSortBy&gt; = _sortOption.asStateFlow()
    
    // ========== UI State ==========
    
    private val _uiState = MutableStateFlow(PuzzleListUiState())
    val uiState: StateFlow&lt;PuzzleListUiState&gt; = _uiState.asStateFlow()
    
    // ========== Derived State ==========
    
    // Combina search, filters y sort para obtener la lista final
    val puzzles: StateFlow&lt;List&lt;Puzzle&gt;&gt; = combine(
        searchQuery,
        selectedFilters,
        sortOption
    ) { query, filters, sort ->
        PuzzleSearchCriteria(
            query = query.takeIf { it.isNotBlank() },
            categories = filters.categories,
            difficulties = filters.difficulties,
            gridSizes = filters.gridSizes,
            completionStatus = filters.completionStatus,
            sortBy = sort,
            sortOrder = filters.sortOrder
        )
    }.flatMapLatest { criteria ->
        getPuzzleListUseCase(GetPuzzleListUseCase.Params(
            difficultyFilter = criteria.difficulties.firstOrNull()?.value,
            completionFilter = when (criteria.completionStatus) {
                CompletionStatus.COMPLETED -> true
                CompletionStatus.NOT_STARTED -> false
                else -> null
            },
            searchQuery = criteria.query,
            sortOrder = when (criteria.sortBy) {
                PuzzleSortBy.DIFFICULTY -> SortOrder.DIFFICULTY_ASC
                PuzzleSortBy.TITLE -> SortOrder.TITLE
                PuzzleSortBy.CREATED_DATE -> SortOrder.CREATED_DATE
                else -> SortOrder.CREATED_DATE
            }
        )).map { result ->
            result.getOrElse { emptyList() }
        }
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = emptyList()
    )
    
    // Analytics para tracking de búsquedas
    private val searchAnalytics = searchQuery
        .debounce(1000) // Wait 1 second after user stops typing
        .filter { it.isNotBlank() }
        .onEach { query ->
            analyticsTracker.track("puzzle_search", mapOf(
                "query" to query,
                "query_length" to query.length
            ))
        }
        .launchIn(viewModelScope)
    
    init {
        loadInitialData()
        observePuzzleUpdates()
    }
    
    // ========== Initialization ==========
    
    private fun loadInitialData() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }
            
            try {
                // Load user preferences
                val preferences = userPreferencesRepository.getUserPreferences().first()
                _sortOption.value = preferences.defaultSortOrder.toPuzzleSortBy()
                
                // Set initial filters based on preferences
                _selectedFilters.value = PuzzleFilters(
                    categories = preferences.preferredCategories,
                    difficulties = listOf(preferences.preferredDifficulty)
                )
                
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        error = null
                    )
                }
                
                analyticsTracker.track("puzzle_list_loaded", mapOf(
                    "preferred_difficulty" to preferences.preferredDifficulty.name,
                    "preferred_categories" to preferences.preferredCategories.map { it.name }
                ))
                
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        isLoading = false,
                        error = e.message ?: "Error al cargar puzzles"
                    )
                }
            }
        }
    }
    
    private fun observePuzzleUpdates() {
        // Observar cambios en puzzles para actualizar la UI cuando se completan
        viewModelScope.launch {
            getPuzzleListUseCase(GetPuzzleListUseCase.Params())
                .catch { exception ->
                    _uiState.update { 
                        it.copy(error = exception.message ?: "Error al actualizar puzzles")
                    }
                }
                .collect { result ->
                    result.onFailure { exception ->
                        _uiState.update { 
                            it.copy(error = exception.message ?: "Error al cargar puzzles")
                        }
                    }
                }
        }
    }
    
    // ========== User Actions ==========
    
    fun onSearchQueryChanged(query: String) {
        _searchQuery.value = query
        
        // Clear filters cuando el usuario busca
        if (query.isNotBlank() && _selectedFilters.value.hasActiveFilters) {
            _selectedFilters.value = PuzzleFilters()
        }
    }
    
    fun onClearSearch() {
        _searchQuery.value = ""
    }
    
    fun onFilterChanged(filters: PuzzleFilters) {
        _selectedFilters.value = filters
        
        // Save preferences
        viewModelScope.launch {
            try {
                val currentPrefs = userPreferencesRepository.getUserPreferences().first()
                val updatedPrefs = currentPrefs.copy(
                    preferredCategories = filters.categories,
                    preferredDifficulty = filters.difficulties.firstOrNull() ?: currentPrefs.preferredDifficulty
                )
                userPreferencesRepository.updateUserPreferences(updatedPrefs)
                
                analyticsTracker.track("puzzle_filters_changed", mapOf(
                    "categories" to filters.categories.map { it.name },
                    "difficulties" to filters.difficulties.map { it.name },
                    "completion_status" to filters.completionStatus?.name
                ))
            } catch (e: Exception) {
                Timber.w(e, "Failed to save filter preferences")
            }
        }
    }
    
    fun onSortChanged(sortBy: PuzzleSortBy) {
        _sortOption.value = sortBy
        
        analyticsTracker.track("puzzle_sort_changed", mapOf(
            "sort_by" to sortBy.name
        ))
    }
    
    fun onPuzzleClicked(puzzle: Puzzle) {
        analyticsTracker.track("puzzle_selected", mapOf(
            "puzzle_id" to puzzle.id.value,
            "difficulty" to puzzle.gameConfiguration.difficulty.name,
            "category" to puzzle.metadata.category.name,
            "is_completed" to puzzle.progress.isCompleted,
            "can_be_continued" to puzzle.canBeContinued()
        ))
    }
    
    fun onRefresh() {
        viewModelScope.launch {
            _uiState.update { it.copy(isRefreshing = true) }
            
            try {
                // Force refresh from remote
                getPuzzleListUseCase(GetPuzzleListUseCase.Params(forceRefresh = true))
                    .first() // Take first emission
                
                _uiState.update { 
                    it.copy(
                        isRefreshing = false,
                        error = null
                    )
                }
                
                analyticsTracker.track("puzzle_list_refreshed")
                
            } catch (e: Exception) {
                _uiState.update { 
                    it.copy(
                        isRefreshing = false,
                        error = e.message ?: "Error al actualizar"
                    )
                }
            }
        }
    }
    
    fun onErrorDismissed() {
        _uiState.update { it.copy(error = null) }
    }
    
    // ========== Helper Methods ==========
    
    fun getFilteredPuzzleCount(): StateFlow&lt;Int&gt; {
        return puzzles.map { it.size }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(),
            initialValue = 0
        )
    }
    
    fun hasActiveFiltersOrSearch(): StateFlow&lt;Boolean&gt; {
        return combine(searchQuery, selectedFilters) { query, filters ->
            query.isNotBlank() || filters.hasActiveFilters
        }.stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(),
            initialValue = false
        )
    }
    
    // ========== State Classes ==========
    
    data class PuzzleListUiState(
        val isLoading: Boolean = false,
        val isRefreshing: Boolean = false,
        val error: String? = null
    )
    
    data class PuzzleFilters(
        val categories: List&lt;PuzzleCategory&gt; = emptyList(),
        val difficulties: List&lt;DifficultyLevel&gt; = emptyList(),
        val gridSizes: List&lt;GridSize&gt; = emptyList(),
        val completionStatus: CompletionStatus? = null,
        val sortOrder: SortOrder = SortOrder.DESCENDING
    ) {
        val hasActiveFilters: Boolean
            get() = categories.isNotEmpty() || 
                   difficulties.isNotEmpty() || 
                   gridSizes.isNotEmpty() || 
                   completionStatus != null
        
        fun clearAll(): PuzzleFilters = PuzzleFilters()
    }
}

// Extension functions
private fun com.arceapps.domain.model.SortOrder.toPuzzleSortBy(): PuzzleSortBy {
    return when (this) {
        com.arceapps.domain.model.SortOrder.DIFFICULTY_ASC,
        com.arceapps.domain.model.SortOrder.DIFFICULTY_DESC -> PuzzleSortBy.DIFFICULTY
        com.arceapps.domain.model.SortOrder.TITLE -> PuzzleSortBy.TITLE
        com.arceapps.domain.model.SortOrder.CREATED_DATE -> PuzzleSortBy.CREATED_DATE
        com.arceapps.domain.model.SortOrder.LAST_PLAYED -> PuzzleSortBy.LAST_PLAYED
        com.arceapps.domain.model.SortOrder.COMPLETION_TIME -> PuzzleSortBy.COMPLETION_TIME
    }
}</code></pre>
        </div>

        <h2>🔄 State Management Patterns</h2>

        <p>Implementemos patterns avanzados de gestión de estado:</p>

        <h3>1. UiState Pattern</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/common/UiState.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">📋 Copiar</button>
          </div>
          <pre><code class="language-kotlin">/**
 * Pattern base para gestionar estados de UI de forma consistente
 */
sealed class UiState&lt;out T&gt; {
    object Loading : UiState&lt;Nothing&gt;()
    data class Success&lt;T&gt;(val data: T) : UiState&lt;T&gt;()
    data class Error(val exception: Throwable) : UiState&lt;Nothing&gt;()
    
    val isLoading: Boolean get() = this is Loading
    val isSuccess: Boolean get() = this is Success
    val isError: Boolean get() = this is Error
    
    fun getDataOrNull(): T? = if (this is Success) data else null
    
    fun getErrorOrNull(): Throwable? = if (this is Error) exception else null
}

/**
 * Extension functions para transformar Result a UiState
 */
fun &lt;T&gt; Result&lt;T&gt;.toUiState(): UiState&lt;T&gt; {
    return fold(
        onSuccess = { UiState.Success(it) },
        onFailure = { UiState.Error(it) }
    )
}

fun &lt;T&gt; Flow&lt;Result&lt;T&gt;&gt;.toUiState(): Flow&lt;UiState&lt;T&gt;&gt; {
    return map { it.toUiState() }
        .catch { emit(UiState.Error(it)) }
        .onStart { emit(UiState.Loading) }
}

/**
 * Async state para operaciones en background
 */
data class AsyncState&lt;T&gt;(
    val isLoading: Boolean = false,
    val data: T? = null,
    val error: String? = null
) {
    val hasData: Boolean get() = data != null
    val hasError: Boolean get() = error != null
    
    fun loading(): AsyncState&lt;T&gt; = copy(isLoading = true, error = null)
    
    fun success(data: T): AsyncState&lt;T&gt; = copy(isLoading = false, data = data, error = null)
    
    fun error(error: String): AsyncState&lt;T&gt; = copy(isLoading = false, error = error)
    
    fun error(throwable: Throwable): AsyncState&lt;T&gt; = error(throwable.message ?: "Unknown error")
}</code></pre>
        </div>

        <h3>2. Coroutine Error Handling</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/common/ViewModelExtensions.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">📋 Copiar</button>
          </div>
          <pre><code class="language-kotlin">/**
 * Extensions para ViewModel que simplifican manejo de errores y loading states
 */

/**
 * Ejecuta una operación suspendida con manejo automático de loading y errores
 */
fun &lt;T&gt; ViewModel.launchWithState(
    loadingState: MutableStateFlow&lt;Boolean&gt;,
    errorState: MutableStateFlow&lt;String?&gt;,
    block: suspend () -> T
): Job {
    return viewModelScope.launch {
        try {
            loadingState.value = true
            errorState.value = null
            block()
        } catch (e: Exception) {
            errorState.value = e.message ?: "Error desconocido"
            Timber.e(e, "Error in ViewModel operation")
        } finally {
            loadingState.value = false
        }
    }
}

/**
 * Ejecuta una operación con Result y actualiza AsyncState automáticamente
 */
fun &lt;T&gt; ViewModel.launchWithAsyncState(
    state: MutableStateFlow&lt;AsyncState&lt;T&gt;&gt;,
    block: suspend () -> Result&lt;T&gt;
): Job {
    return viewModelScope.launch {
        state.value = state.value.loading()
        
        val result = try {
            block()
        } catch (e: Exception) {
            Result.failure(e)
        }
        
        state.value = result.fold(
            onSuccess = { state.value.success(it) },
            onFailure = { state.value.error(it) }
        )
    }
}

/**
 * Collect Flow con manejo automático de errores
 */
fun &lt;T&gt; Flow&lt;T&gt;.collectWithErrorHandling(
    scope: CoroutineScope,
    errorHandler: (Throwable) -> Unit = { Timber.e(it) },
    collector: (T) -> Unit
): Job {
    return this
        .catch { throwable ->
            errorHandler(throwable)
        }
        .onEach(collector)
        .launchIn(scope)
}

/**
 * Debounce for user input
 */
fun &lt;T&gt; StateFlow&lt;T&gt;.debounceUserInput(timeoutMs: Long = 300): Flow&lt;T&gt; {
    return this.debounce(timeoutMs).distinctUntilChanged()
}</code></pre>
        </div>

        <h2>🧪 Testing ViewModels</h2>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">test/presentation/game/GameViewModelTest.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">📋 Copiar</button>
          </div>
          <pre><code class="language-kotlin">@ExperimentalCoroutinesApi
class GameViewModelTest {
    
    @get:Rule
    val coroutineRule = MainCoroutineRule()
    
    @get:Rule
    val instantExecutorRule = InstantTaskExecutorRule()
    
    // Mocks
    private val mockStartPuzzleGameUseCase = mockk&lt;StartPuzzleGameUseCase&gt;()
    private val mockMovePuzzlePieceUseCase = mockk&lt;MovePuzzlePieceUseCase&gt;()
    private val mockSaveGameProgressUseCase = mockk&lt;SaveGameProgressUseCase&gt;()
    private val mockCompletePuzzleUseCase = mockk&lt;CompletePuzzleUseCase&gt;()
    private val mockGetHintUseCase = mockk&lt;GetHintUseCase&gt;()
    private val mockAnalyticsTracker = mockk&lt;AnalyticsTracker&gt;()
    private val mockSoundManager = mockk&lt;SoundManager&gt;()
    private val mockHapticFeedback = mockk&lt;HapticFeedback&gt;()
    
    private lateinit var savedStateHandle: SavedStateHandle
    private lateinit var viewModel: GameViewModel
    
    @Before
    fun setup() {
        clearAllMocks()
        MockKAnnotations.init(this)
        
        // Mock all use case calls to avoid NullPointerException
        coEvery { mockAnalyticsTracker.track(any(), any()) } just Runs
        coEvery { mockSoundManager.playValidMoveSound() } just Runs
        coEvery { mockSoundManager.playInvalidMoveSound() } just Runs
        coEvery { mockSoundManager.playCompletionSound() } just Runs
        coEvery { mockHapticFeedback.performValidMove() } just Runs
        coEvery { mockHapticFeedback.performInvalidMove() } just Runs
        coEvery { mockHapticFeedback.performPuzzleCompletion() } just Runs
        
        savedStateHandle = SavedStateHandle(mapOf("puzzleId" to "test-puzzle-1"))
    }
    
    private fun createViewModel(): GameViewModel {
        return GameViewModel(
            startPuzzleGameUseCase = mockStartPuzzleGameUseCase,
            movePuzzlePieceUseCase = mockMovePuzzlePieceUseCase,
            saveGameProgressUseCase = mockSaveGameProgressUseCase,
            pauseGameUseCase = mockPauseGameUseCase,
            completePuzzleUseCase = mockCompletePuzzleUseCase,
            getHintUseCase = mockGetHintUseCase,
            analyticsTracker = mockAnalyticsTracker,
            soundManager = mockSoundManager,
            hapticFeedback = mockHapticFeedback,
            savedStateHandle = savedStateHandle
        )
    }
    
    @Test
    fun `when ViewModel is created, should initialize game automatically`() = runTest {
        // Given
        val testGameSession = createTestGameSession()
        coEvery { 
            mockStartPuzzleGameUseCase(any()) 
        } returns Result.success(testGameSession)
        
        // When
        viewModel = createViewModel()
        
        // Then
        advanceUntilIdle()
        
        val uiState = viewModel.uiState.value
        assertFalse(uiState.isLoading)
        assertNotNull(uiState.puzzle)
        assertNull(uiState.errorMessage)
        
        coVerify { mockStartPuzzleGameUseCase(any()) }
        coVerify { mockAnalyticsTracker.track("game_initialized", any()) }
    }
    
    @Test
    fun `when piece clicked and move is valid, should update game state`() = runTest {
        // Given
        val testGameSession = createTestGameSession()
        coEvery { mockStartPuzzleGameUseCase(any()) } returns Result.success(testGameSession)
        
        val validMoveResult = MoveResult.ValidMove(testGameSession.copy(movesCount = 1))
        coEvery { mockMovePuzzlePieceUseCase(any()) } returns Result.success(validMoveResult)
        
        viewModel = createViewModel()
        advanceUntilIdle()
        
        // When
        viewModel.onPieceClicked(PieceId("piece-1"))
        advanceUntilIdle()
        
        // Then
        val gameState = viewModel.gameState.value
        assertNotNull(gameState)
        assertEquals(1, gameState?.moveCount)
        
        coVerify { mockMovePuzzlePieceUseCase(any()) }
        coVerify { mockSoundManager.playValidMoveSound() }
        coVerify { mockHapticFeedback.performValidMove() }
    }
    
    @Test
    fun `when puzzle is completed, should handle completion flow`() = runTest {
        // Given
        val testGameSession = createTestGameSession()
        coEvery { mockStartPuzzleGameUseCase(any()) } returns Result.success(testGameSession)
        
        val completionResult = MoveResult.PuzzleCompleted(testGameSession.copy(isCompleted = true))
        coEvery { mockMovePuzzlePieceUseCase(any()) } returns Result.success(completionResult)
        
        val puzzleCompletionResult = createTestCompletionResult()
        coEvery { mockCompletePuzzleUseCase(any()) } returns Result.success(puzzleCompletionResult)
        
        viewModel = createViewModel()
        advanceUntilIdle()
        
        // When
        viewModel.onPieceClicked(PieceId("piece-1"))
        advanceUntilIdle()
        
        // Then
        val uiState = viewModel.uiState.value
        assertNotNull(uiState.completionResult)
        assertFalse(uiState.isProcessingCompletion)
        
        coVerify { mockCompletePuzzleUseCase(any()) }
        coVerify { mockSoundManager.playCompletionSound() }
        coVerify { mockHapticFeedback.performPuzzleCompletion() }
        coVerify { mockAnalyticsTracker.track("puzzle_completed", any()) }
    }
    
    @Test
    fun `when hint requested and hints available, should show hint`() = runTest {
        // Given
        val testGameSession = createTestGameSession()
        coEvery { mockStartPuzzleGameUseCase(any()) } returns Result.success(testGameSession)
        
        val testHint = PuzzleHint(pieceId = PieceId("piece-1"), targetPosition = Position(1, 1))
        coEvery { mockGetHintUseCase(any()) } returns Result.success(testHint)
        
        viewModel = createViewModel()
        advanceUntilIdle()
        
        // When
        viewModel.onRequestHint()
        advanceUntilIdle()
        
        // Then
        val gameState = viewModel.gameState.value
        assertEquals(1, gameState?.hintsUsed)
        
        coVerify { mockGetHintUseCase(any()) }
        coVerify { mockAnalyticsTracker.track("hint_used", any()) }
    }
    
    @Test
    fun `when error occurs in initialization, should show error state`() = runTest {
        // Given
        val exception = Exception("Network error")
        coEvery { mockStartPuzzleGameUseCase(any()) } returns Result.failure(exception)
        
        // When
        viewModel = createViewModel()
        advanceUntilIdle()
        
        // Then
        val uiState = viewModel.uiState.value
        assertFalse(uiState.isLoading)
        assertEquals("Network error", uiState.errorMessage)
        assertNull(uiState.puzzle)
    }
    
    @Test
    fun `when game is paused and resumed, should update timer state correctly`() = runTest {
        // Given
        val testGameSession = createTestGameSession()
        coEvery { mockStartPuzzleGameUseCase(any()) } returns Result.success(testGameSession)
        coEvery { mockPauseGameUseCase(any()) } returns Result.success(
            testGameSession.toGameState().copy(status = GameStatus.PAUSED)
        )
        
        viewModel = createViewModel()
        advanceUntilIdle()
        
        // When pause
        viewModel.onPauseGame()
        advanceUntilIdle()
        
        // Then
        val timerStateAfterPause = viewModel.timerState.value
        assertFalse(timerStateAfterPause.isRunning)
        
        // When resume
        viewModel.onResumeGame()
        advanceUntilIdle()
        
        // Then
        val timerStateAfterResume = viewModel.timerState.value
        assertTrue(timerStateAfterResume.isRunning)
        
        coVerify { mockPauseGameUseCase(any()) }
        coVerify { mockAnalyticsTracker.track("game_paused", any()) }
        coVerify { mockAnalyticsTracker.track("game_resumed", any()) }
    }
    
    // ========== Helper Methods ==========
    
    private fun createTestGameSession(): GameSession {
        return GameSession(
            id = "session-1",
            puzzleId = "test-puzzle-1",
            puzzle = createTestPuzzle(),
            startTime = System.currentTimeMillis(),
            currentPieces = createTestPieces(),
            movesCount = 0,
            hintsUsed = 0,
            status = GameSessionStatus.ACTIVE,
            isResumed = false
        )
    }
    
    private fun createTestPuzzle(): Puzzle {
        return Puzzle(
            id = PuzzleId("test-puzzle-1"),
            metadata = PuzzleMetadata(
                title = "Test Puzzle",
                description = "Test Description",
                imageUrl = "https://example.com/image.jpg",
                category = PuzzleCategory.NATURE,
                isActive = true,
                createdAt = Instant.now(),
                updatedAt = Instant.now()
            ),
            gameConfiguration = GameConfiguration(
                gridSize = GridSize.SMALL_3X3,
                difficulty = DifficultyLevel.MEDIUM,
                allowHints = true,
                maxHints = 3
            ),
            progress = PuzzleProgress(),
            statistics = PuzzleStatistics()
        )
    }
    
    private fun createTestPieces(): List&lt;PuzzlePiece&gt; {
        return (0..8).map { index ->
            PuzzlePiece(
                id = PieceId("piece-$index"),
                puzzleId = PuzzleId("test-puzzle-1"),
                position = Position(index / 3, index % 3),
                currentPosition = Position(index / 3, index % 3),
                visualData = PieceVisualData(
                    imageUrl = "https://example.com/piece-$index.jpg",
                    imageSectionBounds = ImageBounds(0, 0, 100, 100)
                )
            )
        }
    }
    
    private fun createTestCompletionResult(): PuzzleCompletionResult {
        return PuzzleCompletionResult(
            puzzle = createTestPuzzle(),
            score = GameScore(
                totalPoints = 1000,
                breakdown = ScoreBreakdown.empty(),
                achievedRating = PuzzleRating.FOUR_STAR
            ),
            newAchievements = emptyList(),
            leaderboardPosition = null,
            userStats = createTestUserStats()
        )
    }
    
    private fun createTestUserStats(): UserStats {
        return UserStats(
            userId = UserId("test-user"),
            gameStats = GameStats(),
            skillLevel = UserSkillLevel(1, 0),
            preferences = UserGamePreferences(),
            streaks = UserStreaks(),
            personalBests = PersonalBests()
        )
    }
}</code></pre>
        </div>

        <h2>🎯 Mejores Prácticas para ViewModels</h2>

        <div class="best-practices">
          <div class="practice-card">
            <h4>🔄 State Management</h4>
            <ul>
              <li>Un StateFlow para cada tipo de estado</li>
              <li>Immutable data classes para UI state</li>
              <li>Combine múltiples fuentes reactivamente</li>
              <li>Use SharedFlow para eventos one-time</li>
            </ul>
          </div>
          
          <div class="practice-card">
            <h4>🎭 Separation of Concerns</h4>
            <ul>
              <li>ViewModels coordinan, no implementan lógica</li>
              <li>Delegar operaciones complejas a Use Cases</li>
              <li>Mantener ViewModels platform-agnostic</li>
              <li>No references directas a Views o Context</li>
            </ul>
          </div>
          
          <div class="practice-card">
            <h4>⚡ Performance</h4>
            <ul>
              <li>Use StateIn y ShareIn apropiadamente</li>
              <li>Cancel coroutines en onCleared()</li>
              <li>Debounce user input para búsquedas</li>
              <li>Avoid heavy operations en main thread</li>
            </ul>
          </div>
          
          <div class="practice-card">
            <h4>🧪 Testing</h4>
            <ul>
              <li>Mock dependencies, not ViewModel internals</li>
              <li>Test state changes, not implementation</li>
              <li>Use MainCoroutineRule para testing</li>
              <li>Verify Use Case calls y analytics</li>
            </ul>
          </div>
        </div>

        <h2>🔗 Próximos Pasos</h2>
        
        <p>Con ViewModels dominados, continúa con:</p>
        
        <div class="next-steps">
          <div class="step-card">
            <h4>📱 <a href="blog-mvvm-view.html">Capa View</a></h4>
            <p>Conecta ViewModels con Compose UI y Views</p>
          </div>
          
          <div class="step-card">
            <h4>🔗 <a href="blog-data-binding-mvvm.html">Data Binding</a></h4>
            <p>Binding declarativo entre ViewModel y UI</p>
          </div>
          
          <div class="step-card">
            <h4>🧪 <a href="blog-testing-mvvm.html">Testing MVVM</a></h4>
            <p>Estrategias completas de testing</p>
          </div>
        </div>

        <div class="article-footer">
          <div class="article-tags">
            <span class="tag">Android</span>
            <span class="tag">Kotlin</span>
            <span class="tag">MVVM</span>
            <span class="tag">ViewModel</span>
            <span class="tag">StateFlow</span>
            <span class="tag">Coroutines</span>
            <span class="tag">State Management</span>
            <span class="tag">Testing</span>
          </div>
          
          <div class="article-navigation">
            <a href="blog-mvvm-model.html" class="nav-button">← Model Layer</a>
            <a href="blog-mvvm-view.html" class="nav-button">Siguiente: View Layer →</a>
          </div>
          
          <div class="share-section">
            <h4>¿Te gustó este artículo?</h4>
            <p>Compártelo con otros desarrolladores Android</p>
            <div class="share-buttons">
              <button class="share-btn twitter">🐦 Twitter</button>
              <button class="share-btn linkedin">💼 LinkedIn</button>
              <button class="share-btn copy">📋 Copiar enlace</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </article>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-text">
          <p>&copy; 2025 ArceApps. Desarrollado con HTML, CSS y JavaScript.</p>
        </div>
        <div class="footer-links">
          <a href="#" class="footer-link">GitHub</a>
          <a href="#" class="footer-link">LinkedIn</a>
          <a href="#" class="footer-link">Contacto</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>