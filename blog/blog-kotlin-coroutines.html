<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Kotlin Coroutines en Android - ArceApps Blog</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-left">
        <div class="nav-logo">
          <h3><a href="../index.html">ArceApps</a></h3>
        </div>
      </div>
      <div class="nav-right">
        <ul class="nav-menu" id="nav-menu">
          <li class="nav-item">
            <a href="../index.html" class="nav-link">Inicio</a>
          </li>
          <li class="nav-item">
            <a href="../about.html" class="nav-link">About</a>
          </li>
          <li class="nav-item">
            <a href="../portfolio.html" class="nav-link">Portfolio</a>
          </li>
          <li class="nav-item">
            <a href="../blog.html" class="nav-link active">Blog</a>
          </li>
        </ul>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
          <div class="theme-toggle-circle">
            <span class="theme-icon">üåô</span>
          </div>
        </button>
        <div class="nav-toggle" id="nav-toggle">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </div>
      </div>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">20 de septiembre de 2025</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>Kotlin Coroutines en Android: Programaci√≥n As√≠ncrona Moderna</h1>
        <p class="article-subtitle">Domina las corrutinas de Kotlin para crear aplicaciones Android m√°s eficientes y reactivas, siguiendo las mejores pr√°cticas de arquitectura limpia y MVVM</p>
        <div class="article-image">
          <img src="../images/placeholder-article-coroutines.svg" alt="Kotlin Coroutines Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>‚ö° Introducci√≥n a las Corrutinas de Kotlin</h2>
        <p>Las <strong>corrutinas de Kotlin</strong> son una herramienta revolucionaria para la programaci√≥n as√≠ncrona que ha transformado la forma en que desarrollamos aplicaciones Android. A diferencia de los callbacks y threads tradicionales, las corrutinas nos permiten escribir c√≥digo as√≠ncrono que se lee y mantiene como c√≥digo secuencial, sin bloquear el hilo principal.</p>

        <p>En el contexto de <strong>Android y arquitectura MVVM</strong>, las corrutinas son fundamentales para manejar operaciones como llamadas de red, acceso a base de datos y procesamiento en segundo plano, todo mientras mantenemos una UI responsiva y siguiendo los principios de la arquitectura limpia. üöÄ</p>

        <div class="coroutines-benefits-overview">
          <h3>¬øPor qu√© usar Corrutinas en lugar de AsyncTask o Threads?</h3>
          <div class="benefits-grid">
            <div class="benefit-card">
              <div class="benefit-icon">üìñ</div>
              <h4>C√≥digo Legible</h4>
              <p>Sintaxis secuencial para operaciones as√≠ncronas</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üîß</div>
              <h4>Manejo de Errores</h4>
              <p>Try-catch tradicional funciona perfectamente</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üöÄ</div>
              <h4>Performance</h4>
              <p>Ligeras: miles de corrutinas con bajo consumo</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üéØ</div>
              <h4>Lifecycle-Aware</h4>
              <p>Integraci√≥n perfecta con componentes Android</p>
            </div>
          </div>
        </div>

        <h2>üèóÔ∏è Conceptos Fundamentales</h2>
        <p>Para dominar las corrutinas en Android, es esencial entender sus componentes b√°sicos y c√≥mo se integran con la arquitectura MVVM.</p>

        <h3>Suspend Functions</h3>
        <p>Las <code>suspend functions</code> son el coraz√≥n de las corrutinas. Pueden ser pausadas y reanudadas sin bloquear el hilo:</p>
        
        <div class="code-block">
          <pre><code>// ‚úÖ Funci√≥n suspend para operaciones as√≠ncronas
suspend fun fetchUserProfile(userId: String): User {
    return withContext(Dispatchers.IO) {
        // Simula llamada de red
        delay(1000) // No bloquea el hilo principal
        apiService.getUser(userId)
    }
}

// ‚úÖ Uso en Repository
class UserRepository @Inject constructor(
    private val apiService: UserApiService,
    private val userDao: UserDao
) {
    suspend fun getUserProfile(userId: String): Result<User> {
        return try {
            val user = fetchUserProfile(userId)
            userDao.insertUser(user)
            Result.success(user)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}</code></pre>
        </div>

        <h3>Scopes y Contextos</h3>
        <p>Los <strong>scopes</strong> definen el ciclo de vida de las corrutinas, mientras que los <strong>contextos</strong> determinan en qu√© hilo se ejecutan:</p>

        <div class="code-block">
          <pre><code>// ‚úÖ ViewModel con viewModelScope
class UserProfileViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {
    
    private val _userProfile = MutableLiveData<User>()
    val userProfile: LiveData<User> = _userProfile
    
    private val _isLoading = MutableLiveData<Boolean>()
    val isLoading: LiveData<Boolean> = _isLoading
    
    private val _error = MutableLiveData<String?>()
    val error: LiveData<String?> = _error
    
    fun loadUserProfile(userId: String) {
        viewModelScope.launch {
            _isLoading.value = true
            _error.value = null
            
            userRepository.getUserProfile(userId)
                .onSuccess { user ->
                    _userProfile.value = user
                }
                .onFailure { exception ->
                    _error.value = exception.message
                }
            
            _isLoading.value = false
        }
    }
}</code></pre>
        </div>

        <h2>üéØ Integraci√≥n con Arquitectura MVVM</h2>
        <p>Las corrutinas se integran perfectamente con el patr√≥n MVVM, respetando la separaci√≥n de responsabilidades y facilitando el testing:</p>

        <h3>ViewModels con Corrutinas</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ ViewModel siguiendo principios de Clean Architecture
@HiltViewModel
class ProductListViewModel @Inject constructor(
    private val getProductsUseCase: GetProductsUseCase,
    private val addToFavoritesUseCase: AddToFavoritesUseCase
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(ProductListUiState())
    val uiState: StateFlow<ProductListUiState> = _uiState.asStateFlow()
    
    fun loadProducts(category: String? = null) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(isLoading = true)
            
            try {
                val products = getProductsUseCase(category)
                _uiState.value = _uiState.value.copy(
                    products = products,
                    isLoading = false,
                    error = null
                )
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = e.message
                )
            }
        }
    }
    
    fun addToFavorites(productId: String) {
        viewModelScope.launch {
            try {
                addToFavoritesUseCase(productId)
                // Actualizar UI state si es necesario
            } catch (e: Exception) {
                // Manejar error sin crashear la app
            }
        }
    }
}

data class ProductListUiState(
    val products: List<Product> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null
)</code></pre>
        </div>

        <h3>Repository Pattern con Corrutinas</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ Repository que respeta Single Source of Truth
@Singleton
class ProductRepository @Inject constructor(
    private val apiService: ProductApiService,
    private val productDao: ProductDao,
    private val networkManager: NetworkManager
) {
    
    fun getProducts(): Flow<List<Product>> = productDao.getAllProducts()
    
    suspend fun refreshProducts() {
        if (networkManager.isConnected()) {
            try {
                val remoteProducts = apiService.getProducts()
                productDao.insertProducts(remoteProducts)
            } catch (e: Exception) {
                // Los datos locales siguen disponibles
                Timber.e(e, "Error refreshing products")
            }
        }
    }
    
    suspend fun getProductDetails(productId: String): Product? {
        return withContext(Dispatchers.IO) {
            // Primero intentar obtener de cach√© local
            var product = productDao.getProduct(productId)
            
            if (product == null && networkManager.isConnected()) {
                // Si no est√° en cach√©, obtener de red
                try {
                    product = apiService.getProduct(productId)
                    productDao.insertProduct(product)
                } catch (e: Exception) {
                    Timber.e(e, "Error fetching product details")
                }
            }
            
            product
        }
    }
}</code></pre>
        </div>

        <h2>üöÄ Casos de Uso Avanzados</h2>
        
        <h3>Operaciones Paralelas con async/await</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ Ejecuci√≥n paralela de operaciones independientes
class DashboardViewModel @Inject constructor(
    private val userRepository: UserRepository,
    private val notificationRepository: NotificationRepository,
    private val statisticsRepository: StatisticsRepository
) : ViewModel() {
    
    fun loadDashboardData() {
        viewModelScope.launch {
            _isLoading.value = true
            
            try {
                // Ejecutar operaciones en paralelo
                val userDeferred = async { userRepository.getCurrentUser() }
                val notificationsDeferred = async { notificationRepository.getUnreadNotifications() }
                val statsDeferred = async { statisticsRepository.getUserStats() }
                
                // Esperar todos los resultados
                val user = userDeferred.await()
                val notifications = notificationsDeferred.await()
                val stats = statsDeferred.await()
                
                _dashboardState.value = DashboardState(
                    user = user,
                    notifications = notifications,
                    stats = stats,
                    isLoading = false
                )
            } catch (e: Exception) {
                _dashboardState.value = _dashboardState.value.copy(
                    isLoading = false,
                    error = e.message
                )
            }
        }
    }
}</code></pre>
        </div>

        <h3>Flow para Datos Reactivos</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ Uso de Flow para datos que cambian en tiempo real
class ChatViewModel @Inject constructor(
    private val chatRepository: ChatRepository
) : ViewModel() {
    
    private val _messages = MutableStateFlow<List<Message>>(emptyList())
    val messages: StateFlow<List<Message>> = _messages.asStateFlow()
    
    fun observeMessages(chatId: String) {
        viewModelScope.launch {
            chatRepository.getMessagesFlow(chatId)
                .catch { e ->
                    // Manejar errores del stream
                    Timber.e(e, "Error observing messages")
                }
                .collect { messageList ->
                    _messages.value = messageList
                }
        }
    }
    
    fun sendMessage(content: String, chatId: String) {
        viewModelScope.launch {
            try {
                chatRepository.sendMessage(content, chatId)
                // Flow se actualizar√° autom√°ticamente
            } catch (e: Exception) {
                // Mostrar error al usuario
            }
        }
    }
}</code></pre>
        </div>

        <h2>‚ö†Ô∏è Mejores Pr√°cticas y Errores Comunes</h2>
        
        <div class="warning-box">
          <h3>üö´ Errores frecuentes con Corrutinas</h3>
          <ul>
            <li><strong>GlobalScope.launch:</strong> Nunca uses GlobalScope en producci√≥n - usa scopes apropiados</li>
            <li><strong>Bloquear corrutinas:</strong> No uses runBlocking en el hilo principal</li>
            <li><strong>No manejar excepciones:</strong> Siempre maneja errores en operaciones as√≠ncronas</li>
            <li><strong>Memory leaks:</strong> Cancela corrutinas cuando el componente se destruye</li>
          </ul>
        </div>

        <h3>‚úÖ Buenas Pr√°cticas</h3>
        <div class="code-block">
          <pre><code>// ‚úÖ BIEN: Uso correcto de scopes y manejo de errores
class GoodViewModel @Inject constructor(
    private val repository: Repository
) : ViewModel() {
    
    private val _state = MutableStateFlow(UiState())
    val state: StateFlow<UiState> = _state.asStateFlow()
    
    // ‚úÖ Usar viewModelScope para auto-cancelaci√≥n
    fun loadData() {
        viewModelScope.launch {
            _state.value = _state.value.copy(isLoading = true)
            
            try {
                val data = withContext(Dispatchers.IO) {
                    repository.getData()
                }
                _state.value = _state.value.copy(
                    data = data,
                    isLoading = false,
                    error = null
                )
            } catch (e: CancellationException) {
                // No manejar - cancelaci√≥n normal
                throw e
            } catch (e: Exception) {
                _state.value = _state.value.copy(
                    isLoading = false,
                    error = e.message
                )
            }
        }
    }
}

// ‚ùå MAL: Uso de GlobalScope y falta de manejo de errores
class BadViewModel {
    fun loadData() {
        GlobalScope.launch { // üö´ Nunca uses GlobalScope
            val data = repository.getData() // üö´ No maneja errores
            // üö´ Posible memory leak y crasheos
        }
    }
}</code></pre>
        </div>

        <h2>üß™ Testing con Corrutinas</h2>
        <p>Las corrutinas son muy testeable usando las herramientas adecuadas:</p>

        <div class="code-block">
          <pre><code>// ‚úÖ Test unitario con corrutinas
@Test
fun `loadUserProfile should update state correctly`() = runTest {
    // Given
    val userId = "123"
    val expectedUser = User(id = userId, name = "Test User")
    coEvery { userRepository.getUserProfile(userId) } returns Result.success(expectedUser)
    
    // When
    viewModel.loadUserProfile(userId)
    advanceUntilIdle() // Esperar que todas las corrutinas terminen
    
    // Then
    val state = viewModel.uiState.value
    assertThat(state.user).isEqualTo(expectedUser)
    assertThat(state.isLoading).isFalse()
    assertThat(state.error).isNull()
}

@Test
fun `loadUserProfile should handle errors correctly`() = runTest {
    // Given
    val userId = "123"
    val errorMessage = "Network error"
    coEvery { userRepository.getUserProfile(userId) } returns Result.failure(Exception(errorMessage))
    
    // When
    viewModel.loadUserProfile(userId)
    advanceUntilIdle()
    
    // Then
    val state = viewModel.uiState.value
    assertThat(state.user).isNull()
    assertThat(state.isLoading).isFalse()
    assertThat(state.error).isEqualTo(errorMessage)
}</code></pre>
        </div>

        <h2>üì± Integraci√≥n con Jetpack Compose</h2>
        <div class="code-block">
          <pre><code>// ‚úÖ Uso de corrutinas en Composables
@Composable
fun UserProfileScreen(
    viewModel: UserProfileViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    LaunchedEffect(Unit) {
        viewModel.loadUserProfile()
    }
    
    when {
        uiState.isLoading -> {
            LoadingIndicator()
        }
        uiState.error != null -> {
            ErrorMessage(
                error = uiState.error,
                onRetry = { viewModel.loadUserProfile() }
            )
        }
        uiState.user != null -> {
            UserProfileContent(user = uiState.user)
        }
    }
}</code></pre>
        </div>

        <h2>üéØ Conclusi√≥n</h2>
        <p>Las <strong>corrutinas de Kotlin</strong> han revolucionado el desarrollo Android al proporcionar una forma elegante y eficiente de manejar operaciones as√≠ncronas. Su integraci√≥n con arquitectura MVVM y principios de Clean Architecture nos permite crear aplicaciones m√°s robustas, mantenibles y testeable.</p>

        <p>Puntos clave para recordar:</p>
        <ul>
          <li>üéØ <strong>Usa scopes apropiados:</strong> viewModelScope, lifecycleScope seg√∫n el contexto</li>
          <li>üõ°Ô∏è <strong>Maneja errores correctamente:</strong> Try-catch y Result types</li>
          <li>‚ö° <strong>Aprovecha la concurrencia:</strong> async/await para operaciones paralelas</li>
          <li>üîÑ <strong>Usa Flow para datos reactivos:</strong> Perfect para observar cambios</li>
          <li>üß™ <strong>Testa tus corrutinas:</strong> runTest y advanceUntilIdle</li>
          <li>üèóÔ∏è <strong>Respeta la arquitectura:</strong> Repository pattern y separaci√≥n de capas</li>
        </ul>

        <p>Las corrutinas no son solo una herramienta t√©cnica, sino un cambio de paradigma que nos acerca a un c√≥digo m√°s limpio, expresivo y mantenible. ¬°Dom√≠nalas y transforma la calidad de tus aplicaciones Android! üöÄ</p>

        <div class="next-steps-box">
          <h3>üöÄ Pr√≥ximos pasos recomendados</h3>
          <ol>
            <li>Migra tus AsyncTasks y callbacks existentes a corrutinas</li>
            <li>Implementa Repository pattern con Flow para datos reactivos</li>
            <li>Usa StateFlow/SharedFlow en lugar de LiveData en nuevos proyectos</li>
            <li>A√±ade tests unitarios para tus ViewModels con corrutinas</li>
            <li>Explora operadores avanzados de Flow (map, filter, combine)</li>
            <li>Implementa manejo de errores centralizado con sealed classes</li>
            <li>Integra con Room Database para operaciones de BD as√≠ncronas</li>
          </ol>
        </div>

        <div class="article-footer">
          <div class="tags">
            <span class="tag">Android</span>
            <span class="tag">Kotlin</span>
            <span class="tag">Coroutines</span>
            <span class="tag">MVVM</span>
            <span class="tag">Clean Architecture</span>
            <span class="tag">Async Programming</span>
            <span class="tag">Flow</span>
            <span class="tag">Testing</span>
          </div>
          <div class="share-buttons">
            <a href="#" class="share-btn">Compartir en Twitter</a>
            <a href="#" class="share-btn">Compartir en LinkedIn</a>
          </div>
        </div>
      </div>
    </div>
  </article>

  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-text">
          <p>&copy; 2025 ArceApps. Desarrollado con HTML, CSS y JavaScript.</p>
        </div>
        <div class="footer-links">
          <a href="#" class="footer-link">GitHub</a>
          <a href="#" class="footer-link">LinkedIn</a>
          <a href="#" class="footer-link">Contacto</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>