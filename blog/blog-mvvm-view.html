<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Capa View en MVVM Android: UI Reactiva y Declarativa - ArceApps Blog</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-left">
        <div class="nav-logo">
          <h3><a href="../index.html">ArceApps</a></h3>
        </div>
      </div>
      <div class="nav-right">
        <ul class="nav-menu" id="nav-menu">
          <li class="nav-item">
            <a href="../index.html" class="nav-link">Inicio</a>
          </li>
          <li class="nav-item">
            <a href="../about.html" class="nav-link">About</a>
          </li>
          <li class="nav-item">
            <a href="../portfolio.html" class="nav-link">Portfolio</a>
          </li>
          <li class="nav-item">
            <a href="../blog.html" class="nav-link active">Blog</a>
          </li>
        </ul>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
          <div class="theme-toggle-circle">
            <span class="theme-icon">üåô</span>
          </div>
        </button>
        <div class="nav-toggle" id="nav-toggle">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </div>
      </div>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">20 de julio de 2025</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>Capa View en MVVM Android: UI Reactiva y Declarativa</h1>
        <p class="article-subtitle">Construye interfaces din√°micas para PuzzleQuest con Jetpack Compose y View Binding, implementando observaci√≥n reactiva del ViewModel y UX fluida para el juego de puzzles</p>
        <div class="article-image">
          <img src="../images/placeholder-article-view-layer.svg" alt="View Layer MVVM Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>üì± ¬øQu√© es la Capa View en MVVM?</h2>
        <p>La capa View es donde la magia se hace visible. En PuzzleQuest, esta capa transforma el estado del ViewModel en una interfaz interactiva y atractiva. Es responsable de <strong>renderizar la UI</strong>, <strong>capturar eventos del usuario</strong> y <strong>reaccionar a cambios de estado</strong> sin conocer la l√≥gica de negocio subyacente.</p>

        <div class="view-definition">
          <h3>üéØ Responsabilidades de la Capa View</h3>
          <div class="responsibilities-grid">
            <div class="responsibility-card">
              <div class="responsibility-icon">üé®</div>
              <h4>Renderizado UI</h4>
              <p>Muestra datos del ViewModel en elementos visuales</p>
            </div>
            <div class="responsibility-card">
              <div class="responsibility-icon">üñ±Ô∏è</div>
              <h4>Eventos Usuario</h4>
              <p>Captura interacciones y las env√≠a al ViewModel</p>
            </div>
            <div class="responsibility-card">
              <div class="responsibility-icon">üîÑ</div>
              <h4>Observaci√≥n Reactiva</h4>
              <p>Se actualiza autom√°ticamente cuando cambia el estado</p>
            </div>
            <div class="responsibility-card">
              <div class="responsibility-icon">üé≠</div>
              <h4>Navegaci√≥n</h4>
              <p>Maneja transiciones entre pantallas</p>
            </div>
          </div>
        </div>

        <h2>üèóÔ∏è Arquitectura de View en PuzzleQuest</h2>
        
        <div class="architecture-diagram">
          <h3>üìä Componentes de la Capa View</h3>
          <div class="view-architecture">
            <div class="arch-layer">
              <h4>UI Framework</h4>
              <div class="arch-components">
                <div class="component">Jetpack Compose</div>
                <div class="component">View System</div>
                <div class="component">Navigation</div>
              </div>
            </div>
            <div class="arch-separator">‚¨áÔ∏è</div>
            <div class="arch-layer">
              <h4>Screen Components</h4>
              <div class="arch-components">
                <div class="component">Fragments/Activities</div>
                <div class="component">Composables</div>
                <div class="component">Custom Views</div>
              </div>
            </div>
            <div class="arch-separator">‚¨áÔ∏è</div>
            <div class="arch-layer">
              <h4>State Observation</h4>
              <div class="arch-components">
                <div class="component">collectAsState()</div>
                <div class="component">Observer Pattern</div>
                <div class="component">Data Binding</div>
              </div>
            </div>
          </div>
        </div>

        <h2>üéÆ Game Screen con Jetpack Compose</h2>

        <p>Implementemos la pantalla principal del juego usando Compose:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/game/GameScreen.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Composable
fun GameScreen(
    viewModel: GameViewModel = hiltViewModel(),
    onNavigateBack: () -> Unit,
    onNavigateToCompletion: (PuzzleCompletionResult) -> Unit
) {
    // ========== State Collection ==========
    
    val uiState by viewModel.uiState.collectAsState()
    val gameState by viewModel.gameState.collectAsState()
    val timerState by viewModel.timerState.collectAsState()
    
    // ========== Event Handling ==========
    
    // Observe UI events (one-time events)
    LaunchedEffect(viewModel) {
        viewModel.uiEvents.collect { event ->
            when (event) {
                is GameUiEvent.PuzzleCompleted -> {
                    onNavigateToCompletion(event.result)
                }
                is GameUiEvent.ShowError -> {
                    // Show snackbar or dialog
                }
                is GameUiEvent.ConfirmRestart -> {
                    // Show confirmation dialog
                }
                is GameUiEvent.StartCompletionAnimation -> {
                    // Trigger celebration animation
                }
                // Handle other events...
            }
        }
    }
    
    // ========== UI Structure ==========
    
    Box(
        modifier = Modifier
            .fillMaxSize()
            .background(MaterialTheme.colorScheme.background)
    ) {
        when {
            uiState.isLoading -> {
                LoadingIndicator(
                    modifier = Modifier.align(Alignment.Center)
                )
            }
            
            uiState.puzzle != null && gameState != null -> {
                GameContent(
                    puzzle = uiState.puzzle,
                    gameState = gameState,
                    timerState = timerState,
                    uiState = uiState,
                    onPieceClick = viewModel::onPieceClicked,
                    onPauseClick = viewModel::onPauseGame,
                    onResumeClick = viewModel::onResumeGame,
                    onHintClick = viewModel::onRequestHint,
                    onRestartClick = viewModel::onRestartGame,
                    modifier = Modifier.fillMaxSize()
                )
            }
            
            uiState.errorMessage != null -> {
                ErrorState(
                    message = uiState.errorMessage,
                    onRetry = { /* Retry logic */ },
                    onDismiss = viewModel::onErrorShown,
                    modifier = Modifier.align(Alignment.Center)
                )
            }
        }
        
        // Top bar con controles del juego
        GameTopBar(
            timerState = timerState,
            moveCount = gameState?.moveCount ?: 0,
            hintsUsed = gameState?.hintsUsed ?: 0,
            maxHints = gameState?.maxHints ?: 3,
            onBackClick = onNavigateBack,
            onPauseClick = viewModel::onPauseGame,
            modifier = Modifier.align(Alignment.TopStart)
        )
        
        // Bottom bar con controles adicionales
        GameBottomBar(
            onHintClick = viewModel::onRequestHint,
            onRestartClick = viewModel::onRestartGame,
            isHintLoading = uiState.isLoadingHint,
            canUseHint = (gameState?.hintsUsed ?: 0) < (gameState?.maxHints ?: 0),
            modifier = Modifier.align(Alignment.BottomStart)
        )
    }
}

@Composable
private fun GameContent(
    puzzle: Puzzle,
    gameState: GameState,
    timerState: TimerState,
    uiState: GameViewModel.GameUiState,
    onPieceClick: (PieceId) -> Unit,
    onPauseClick: () -> Unit,
    onResumeClick: () -> Unit,
    onHintClick: () -> Unit,
    onRestartClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier.padding(16.dp),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Spacer(modifier = Modifier.height(80.dp)) // Space for top bar
        
        // Puzzle info card
        PuzzleInfoCard(
            puzzle = puzzle,
            modifier = Modifier.fillMaxWidth()
        )
        
        Spacer(modifier = Modifier.height(24.dp))
        
        // Main puzzle grid
        PuzzleGrid(
            pieces = gameState.pieces,
            gridSize = gameState.gridSize,
            onPieceClick = onPieceClick,
            isInteractionEnabled = uiState.canInteract && gameState.isActive,
            modifier = Modifier
                .fillMaxWidth()
                .aspectRatio(1f)
        )
        
        Spacer(modifier = Modifier.height(24.dp))
        
        // Game stats
        GameStatsRow(
            moveCount = gameState.moveCount,
            hintsUsed = gameState.hintsUsed,
            elapsedTime = timerState.formattedTime,
            modifier = Modifier.fillMaxWidth()
        )
        
        Spacer(modifier = Modifier.height(80.dp)) // Space for bottom bar
    }
    
    // Overlay for paused state
    if (gameState.isPaused) {
        PausedOverlay(
            onResumeClick = onResumeClick,
            onRestartClick = onRestartClick,
            modifier = Modifier.fillMaxSize()
        )
    }
    
    // Completion animation overlay
    if (uiState.isProcessingCompletion) {
        CompletionAnimationOverlay(
            modifier = Modifier.fillMaxSize()
        )
    }
}</code></pre>
        </div>

        <h3>üß© Componente del Grid de Puzzle</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/game/components/PuzzleGrid.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Composable
fun PuzzleGrid(
    pieces: List&lt;PuzzlePiece&gt;,
    gridSize: GridSize,
    onPieceClick: (PieceId) -> Unit,
    isInteractionEnabled: Boolean,
    modifier: Modifier = Modifier
) {
    val configuration = LocalConfiguration.current
    val screenWidth = configuration.screenWidthDp.dp
    val gridPadding = 32.dp
    val availableWidth = screenWidth - gridPadding
    val pieceSize = availableWidth / gridSize.columns
    
    // Crear grid de posiciones
    val positionedPieces = remember(pieces, gridSize) {
        createPositionedPieces(pieces, gridSize)
    }
    
    Box(
        modifier = modifier
            .size(availableWidth)
            .background(
                color = MaterialTheme.colorScheme.surfaceVariant,
                shape = RoundedCornerShape(12.dp)
            )
            .padding(8.dp)
    ) {
        // Render grid background
        GridBackground(
            gridSize = gridSize,
            pieceSize = pieceSize,
            modifier = Modifier.fillMaxSize()
        )
        
        // Render puzzle pieces
        positionedPieces.forEach { (piece, position) ->
            if (piece != null) {
                PuzzlePieceComponent(
                    piece = piece,
                    position = position,
                    pieceSize = pieceSize,
                    onPieceClick = { onPieceClick(piece.id) },
                    isInteractionEnabled = isInteractionEnabled,
                    modifier = Modifier.fillMaxSize()
                )
            }
        }
    }
}

@Composable
private fun PuzzlePieceComponent(
    piece: PuzzlePiece,
    position: Position,
    pieceSize: Dp,
    onPieceClick: () -> Unit,
    isInteractionEnabled: Boolean,
    modifier: Modifier = Modifier
) {
    // Animation state for piece movement
    val animatedPosition by animateOffsetAsState(
        targetValue = Offset(
            x = position.column * pieceSize.value,
            y = position.row * pieceSize.value
        ),
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessLow
        ),
        label = "piece_position"
    )
    
    // Visual state for user feedback
    var isPressed by remember { mutableStateOf(false) }
    var isHighlighted by remember { mutableStateOf(false) }
    
    // Check if piece is in correct position for visual feedback
    val isInCorrectPosition = piece.isInCorrectPosition()
    
    Box(
        modifier = modifier
            .offset(
                x = animatedPosition.x.dp,
                y = animatedPosition.y.dp
            )
            .size(pieceSize)
            .padding(2.dp)
            .clickable(
                enabled = isInteractionEnabled,
                indication = null,
                interactionSource = remember { MutableInteractionSource() }
            ) {
                onPieceClick()
            }
            .pointerInput(Unit) {
                detectTapGestures(
                    onPress = { 
                        isPressed = true
                        tryAwaitRelease()
                        isPressed = false
                    }
                )
            }
    ) {
        // Piece background with visual states
        Card(
            modifier = Modifier.fillMaxSize(),
            elevation = CardDefaults.cardElevation(
                defaultElevation = if (isPressed) 8.dp else 4.dp
            ),
            colors = CardDefaults.cardColors(
                containerColor = when {
                    isInCorrectPosition -> MaterialTheme.colorScheme.primaryContainer
                    isHighlighted -> MaterialTheme.colorScheme.secondaryContainer
                    else -> MaterialTheme.colorScheme.surface
                }
            ),
            border = if (isPressed) {
                BorderStroke(2.dp, MaterialTheme.colorScheme.primary)
            } else null
        ) {
            // Piece image
            AsyncImage(
                model = ImageRequest.Builder(LocalContext.current)
                    .data(piece.visualData.imageUrl)
                    .crossfade(true)
                    .build(),
                contentDescription = "Puzzle piece ${piece.id.value}",
                modifier = Modifier.fillMaxSize(),
                contentScale = ContentScale.Crop
            )
            
            // Piece number overlay (for debugging/accessibility)
            if (BuildConfig.DEBUG) {
                Text(
                    text = piece.position.let { "${it.row},${it.column}" },
                    modifier = Modifier
                        .align(Alignment.TopStart)
                        .background(
                            MaterialTheme.colorScheme.primary,
                            RoundedCornerShape(4.dp)
                        )
                        .padding(4.dp),
                    color = MaterialTheme.colorScheme.onPrimary,
                    style = MaterialTheme.typography.labelSmall
                )
            }
        }
        
        // Correct position indicator
        if (isInCorrectPosition) {
            Icon(
                Icons.Default.CheckCircle,
                contentDescription = "Correct position",
                modifier = Modifier
                    .align(Alignment.TopEnd)
                    .padding(4.dp),
                tint = MaterialTheme.colorScheme.primary
            )
        }
    }
}

@Composable
private fun GridBackground(
    gridSize: GridSize,
    pieceSize: Dp,
    modifier: Modifier = Modifier
) {
    Canvas(modifier = modifier) {
        val strokeWidth = 2.dp.toPx()
        val color = Color.Gray.copy(alpha = 0.3f)
        
        // Draw vertical lines
        for (col in 0..gridSize.columns) {
            val x = col * pieceSize.toPx()
            drawLine(
                color = color,
                start = Offset(x, 0f),
                end = Offset(x, size.height),
                strokeWidth = strokeWidth
            )
        }
        
        // Draw horizontal lines
        for (row in 0..gridSize.rows) {
            val y = row * pieceSize.toPx()
            drawLine(
                color = color,
                start = Offset(0f, y),
                end = Offset(size.width, y),
                strokeWidth = strokeWidth
            )
        }
    }
}

// Helper function to create positioned pieces
private fun createPositionedPieces(
    pieces: List&lt;PuzzlePiece&gt;,
    gridSize: GridSize
): List&lt;Pair&lt;PuzzlePiece?, Position&gt;&gt; {
    val result = mutableListOf&lt;Pair&lt;PuzzlePiece?, Position&gt;&gt;()
    
    for (row in 0 until gridSize.rows) {
        for (col in 0 until gridSize.columns) {
            val position = Position(row, col)
            val piece = pieces.find { it.currentPosition == position }
            result.add(piece to position)
        }
    }
    
    return result
}</code></pre>
        </div>

        <h2>üìã Lista de Puzzles con LazyColumn</h2>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/puzzlelist/PuzzleListScreen.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PuzzleListScreen(
    viewModel: PuzzleListViewModel = hiltViewModel(),
    onPuzzleClick: (Puzzle) -> Unit,
    onNavigateToSettings: () -> Unit
) {
    // ========== State Collection ==========
    
    val puzzles by viewModel.puzzles.collectAsState()
    val uiState by viewModel.uiState.collectAsState()
    val searchQuery by viewModel.searchQuery.collectAsState()
    val selectedFilters by viewModel.selectedFilters.collectAsState()
    val sortOption by viewModel.sortOption.collectAsState()
    
    val hasActiveFilters by viewModel.hasActiveFiltersOrSearch().collectAsState()
    val filteredCount by viewModel.getFilteredPuzzleCount().collectAsState()
    
    // ========== UI State ==========
    
    var showFilterSheet by remember { mutableStateOf(false) }
    val pullRefreshState = rememberPullRefreshState(
        refreshing = uiState.isRefreshing,
        onRefresh = viewModel::onRefresh
    )
    
    // ========== Layout ==========
    
    Scaffold(
        topBar = {
            PuzzleListTopBar(
                searchQuery = searchQuery,
                onSearchQueryChange = viewModel::onSearchQueryChanged,
                onClearSearch = viewModel::onClearSearch,
                onFilterClick = { showFilterSheet = true },
                onSettingsClick = onNavigateToSettings,
                hasActiveFilters = hasActiveFilters
            )
        }
    ) { paddingValues ->
        Box(
            modifier = Modifier
                .fillMaxSize()
                .pullRefresh(pullRefreshState)
                .padding(paddingValues)
        ) {
            when {
                uiState.isLoading -> {
                    LoadingIndicator(
                        modifier = Modifier.align(Alignment.Center)
                    )
                }
                
                puzzles.isEmpty() && !uiState.isLoading -> {
                    EmptyState(
                        hasActiveFilters = hasActiveFilters,
                        onClearFilters = { viewModel.onFilterChanged(PuzzleFilters()) },
                        modifier = Modifier.align(Alignment.Center)
                    )
                }
                
                else -> {
                    LazyColumn(
                        modifier = Modifier.fillMaxSize(),
                        contentPadding = PaddingValues(16.dp),
                        verticalArrangement = Arrangement.spacedBy(12.dp)
                    ) {
                        // Filter/Sort summary
                        if (hasActiveFilters) {
                            item {
                                FilterSummaryCard(
                                    filters = selectedFilters,
                                    sortOption = sortOption,
                                    resultCount = filteredCount,
                                    onClearFilters = { 
                                        viewModel.onFilterChanged(PuzzleFilters())
                                        viewModel.onClearSearch()
                                    }
                                )
                            }
                        }
                        
                        // Puzzle items
                        items(
                            items = puzzles,
                            key = { it.id.value }
                        ) { puzzle ->
                            PuzzleListItem(
                                puzzle = puzzle,
                                onClick = { 
                                    viewModel.onPuzzleClicked(puzzle)
                                    onPuzzleClick(puzzle)
                                },
                                modifier = Modifier.animateItemPlacement()
                            )
                        }
                    }
                }
            }
            
            // Pull refresh indicator
            PullRefreshIndicator(
                refreshing = uiState.isRefreshing,
                state = pullRefreshState,
                modifier = Modifier.align(Alignment.TopCenter)
            )
        }
    }
    
    // ========== Filter Bottom Sheet ==========
    
    if (showFilterSheet) {
        PuzzleFilterBottomSheet(
            currentFilters = selectedFilters,
            currentSort = sortOption,
            onFiltersChanged = { filters ->
                viewModel.onFilterChanged(filters)
                showFilterSheet = false
            },
            onSortChanged = { sort ->
                viewModel.onSortChanged(sort)
            },
            onDismiss = { showFilterSheet = false }
        )
    }
    
    // ========== Error Handling ==========
    
    uiState.error?.let { errorMessage ->
        LaunchedEffect(errorMessage) {
            // Show snackbar for errors
        }
    }
}

@Composable
private fun PuzzleListItem(
    puzzle: Puzzle,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            // Puzzle thumbnail
            AsyncImage(
                model = puzzle.metadata.imageUrl,
                contentDescription = puzzle.metadata.title,
                modifier = Modifier
                    .size(80.dp)
                    .clip(RoundedCornerShape(8.dp)),
                contentScale = ContentScale.Crop
            )
            
            Spacer(modifier = Modifier.width(16.dp))
            
            // Puzzle info
            Column(
                modifier = Modifier
                    .weight(1f)
                    .fillMaxHeight(),
                verticalArrangement = Arrangement.SpaceBetween
            ) {
                // Title and description
                Column {
                    Text(
                        text = puzzle.metadata.title,
                        style = MaterialTheme.typography.titleMedium,
                        color = MaterialTheme.colorScheme.onSurface
                    )
                    
                    Text(
                        text = puzzle.metadata.description,
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant,
                        maxLines = 2,
                        overflow = TextOverflow.Ellipsis
                    )
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                // Puzzle metadata
                Row(
                    modifier = Modifier.fillMaxWidth(),
                    horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    // Difficulty and category
                    Row {
                        DifficultyChip(
                            difficulty = puzzle.gameConfiguration.difficulty,
                            modifier = Modifier.padding(end = 8.dp)
                        )
                        
                        CategoryChip(
                            category = puzzle.metadata.category
                        )
                    }
                    
                    // Progress indicator
                    PuzzleProgressIndicator(puzzle = puzzle)
                }
            }
        }
    }
}

@Composable
private fun PuzzleProgressIndicator(
    puzzle: Puzzle,
    modifier: Modifier = Modifier
) {
    when {
        puzzle.progress.isCompleted -> {
            Row(
                modifier = modifier,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    Icons.Default.CheckCircle,
                    contentDescription = "Completado",
                    tint = MaterialTheme.colorScheme.primary,
                    modifier = Modifier.size(16.dp)
                )
                Spacer(modifier = Modifier.width(4.dp))
                Text(
                    text = "Completado",
                    style = MaterialTheme.typography.labelMedium,
                    color = MaterialTheme.colorScheme.primary
                )
            }
        }
        
        puzzle.canBeContinued() -> {
            Row(
                modifier = modifier,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Icon(
                    Icons.Default.PlayArrow,
                    contentDescription = "Continuar",
                    tint = MaterialTheme.colorScheme.secondary,
                    modifier = Modifier.size(16.dp)
                )
                Spacer(modifier = Modifier.width(4.dp))
                Text(
                    text = "Continuar",
                    style = MaterialTheme.typography.labelMedium,
                    color = MaterialTheme.colorScheme.secondary
                )
            }
        }
        
        else -> {
            Text(
                text = "Nuevo",
                style = MaterialTheme.typography.labelMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                modifier = modifier
            )
        }
    }
}</code></pre>
        </div>

        <h2>üé® Componentes Reutilizables</h2>

        <h3>Chips para Dificultad y Categor√≠a</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/common/PuzzleChips.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Composable
fun DifficultyChip(
    difficulty: DifficultyLevel,
    modifier: Modifier = Modifier
) {
    val backgroundColor = when (difficulty) {
        DifficultyLevel.BEGINNER -> Color(0xFF4CAF50) // Green
        DifficultyLevel.EASY -> Color(0xFF8BC34A) // Light Green
        DifficultyLevel.MEDIUM -> Color(0xFFFF9800) // Orange
        DifficultyLevel.HARD -> Color(0xFFFF5722) // Deep Orange
        DifficultyLevel.EXPERT -> Color(0xFFF44336) // Red
    }
    
    val textColor = if (backgroundColor.luminance() > 0.5) {
        Color.Black
    } else {
        Color.White
    }
    
    Surface(
        modifier = modifier,
        shape = RoundedCornerShape(12.dp),
        color = backgroundColor
    ) {
        Text(
            text = difficulty.displayName,
            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
            style = MaterialTheme.typography.labelSmall,
            color = textColor
        )
    }
}

@Composable
fun CategoryChip(
    category: PuzzleCategory,
    modifier: Modifier = Modifier
) {
    val categoryIcon = when (category) {
        PuzzleCategory.NATURE -> "üåø"
        PuzzleCategory.ANIMALS -> "üêæ"
        PuzzleCategory.LANDSCAPES -> "üèîÔ∏è"
        PuzzleCategory.ARCHITECTURE -> "üèõÔ∏è"
        PuzzleCategory.ABSTRACT -> "üé®"
        PuzzleCategory.FOOD -> "üçé"
        PuzzleCategory.SPORTS -> "‚öΩ"
        PuzzleCategory.CUSTOM -> "‚ú®"
    }
    
    Surface(
        modifier = modifier,
        shape = RoundedCornerShape(12.dp),
        color = MaterialTheme.colorScheme.secondaryContainer
    ) {
        Row(
            modifier = Modifier.padding(horizontal = 8.dp, vertical = 4.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                text = categoryIcon,
                style = MaterialTheme.typography.labelSmall
            )
            Spacer(modifier = Modifier.width(4.dp))
            Text(
                text = category.displayName,
                style = MaterialTheme.typography.labelSmall,
                color = MaterialTheme.colorScheme.onSecondaryContainer
            )
        }
    }
}</code></pre>
        </div>

        <h2>üé≠ Animaciones y Transiciones</h2>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/common/PuzzleAnimations.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">/**
 * Animaciones espec√≠ficas para la app de puzzles
 */

@Composable
fun CompletionAnimationOverlay(
    modifier: Modifier = Modifier
) {
    var animationPlayed by remember { mutableStateOf(false) }
    
    LaunchedEffect(Unit) {
        animationPlayed = true
    }
    
    Box(
        modifier = modifier
            .background(
                Color.Black.copy(alpha = 0.7f)
            ),
        contentAlignment = Alignment.Center
    ) {
        // Celebration animation
        AnimatedVisibility(
            visible = animationPlayed,
            enter = scaleIn(
                animationSpec = spring(
                    dampingRatio = Spring.DampingRatioMediumBouncy,
                    stiffness = Spring.StiffnessLow
                )
            ) + fadeIn(animationSpec = tween(1000))
        ) {
            Column(
                horizontalAlignment = Alignment.CenterHorizontally
            ) {
                // Celebration icon
                Text(
                    text = "üéâ",
                    fontSize = 72.sp,
                    modifier = Modifier.animateContentSize()
                )
                
                Spacer(modifier = Modifier.height(16.dp))
                
                Text(
                    text = "¬°Puzzle Completado!",
                    style = MaterialTheme.typography.headlineMedium,
                    color = Color.White,
                    textAlign = TextAlign.Center
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text(
                    text = "¬°Excelente trabajo! üéä",
                    style = MaterialTheme.typography.bodyLarge,
                    color = Color.White.copy(alpha = 0.8f),
                    textAlign = TextAlign.Center
                )
            }
        }
    }
}

/**
 * Animaci√≥n para piezas que se mueven incorrectamente
 */
@Composable
fun Modifier.shakeAnimation(
    trigger: Boolean,
    onAnimationComplete: () -> Unit = {}
): Modifier = composed {
    val offsetX by animateFloatAsState(
        targetValue = if (trigger) 0f else 0f,
        animationSpec = if (trigger) {
            keyframes {
                durationMillis = 500
                0f at 0
                -10f at 100
                10f at 200
                -10f at 300
                10f at 400
                0f at 500
            }
        } else {
            tween(0)
        },
        finishedListener = { 
            if (trigger) onAnimationComplete()
        },
        label = "shake"
    )
    
    this.offset(x = offsetX.dp)
}

/**
 * Animaci√≥n de hint highlighting
 */
@Composable
fun Modifier.hintHighlight(
    isHighlighted: Boolean
): Modifier = composed {
    val alpha by animateFloatAsState(
        targetValue = if (isHighlighted) 0.3f else 0f,
        animationSpec = tween(
            durationMillis = 800,
            easing = EaseInOutCubic
        ),
        label = "hint_highlight"
    )
    
    val borderWidth by animateDpAsState(
        targetValue = if (isHighlighted) 3.dp else 0.dp,
        animationSpec = tween(
            durationMillis = 800,
            easing = EaseInOutCubic
        ),
        label = "hint_border"
    )
    
    this
        .background(
            color = MaterialTheme.colorScheme.primary.copy(alpha = alpha),
            shape = RoundedCornerShape(8.dp)
        )
        .border(
            width = borderWidth,
            color = MaterialTheme.colorScheme.primary,
            shape = RoundedCornerShape(8.dp)
        )
}

/**
 * Transition entre screens
 */
@ExperimentalAnimationApi
fun NavGraphBuilder.puzzleScreenTransitions() {
    composable(
        route = "puzzle_list",
        enterTransition = {
            slideIntoContainer(
                towards = AnimatedContentTransitionScope.SlideDirection.Up,
                animationSpec = tween(300)
            )
        },
        exitTransition = {
            slideOutOfContainer(
                towards = AnimatedContentTransitionScope.SlideDirection.Down,
                animationSpec = tween(300)
            )
        }
    ) {
        PuzzleListScreen(
            onPuzzleClick = { puzzle ->
                // Navigate to game
            }
        )
    }
    
    composable(
        route = "game/{puzzleId}",
        arguments = listOf(navArgument("puzzleId") { type = NavType.StringType }),
        enterTransition = {
            slideIntoContainer(
                towards = AnimatedContentTransitionScope.SlideDirection.Left,
                animationSpec = tween(300)
            )
        },
        exitTransition = {
            slideOutOfContainer(
                towards = AnimatedContentTransitionScope.SlideDirection.Right,
                animationSpec = tween(300)
            )
        }
    ) { backStackEntry ->
        val puzzleId = backStackEntry.arguments?.getString("puzzleId") ?: ""
        GameScreen(
            onNavigateBack = {
                // Navigate back
            }
        )
    }
}</code></pre>
        </div>

        <h2>üì± View Binding para Views Tradicionales</h2>

        <p>Para proyectos que a√∫n usan el sistema de Views tradicional:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/game/GameFragment.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@AndroidEntryPoint
class GameFragment : Fragment() {
    
    private var _binding: FragmentGameBinding? = null
    private val binding get() = _binding!!
    
    private val viewModel: GameViewModel by viewModels()
    
    private lateinit var puzzleGridAdapter: PuzzleGridAdapter
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentGameBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        setupUI()
        setupObservers()
        setupClickListeners()
    }
    
    private fun setupUI() {
        // Setup RecyclerView for puzzle grid
        puzzleGridAdapter = PuzzleGridAdapter { pieceId ->
            viewModel.onPieceClicked(pieceId)
        }
        
        binding.recyclerViewPuzzleGrid.apply {
            adapter = puzzleGridAdapter
            layoutManager = GridLayoutManager(context, 3) // Dynamic based on puzzle
            itemAnimator = DefaultItemAnimator().apply {
                // Custom animations for piece movements
                moveDuration = 300
                changeDuration = 300
            }
        }
        
        // Setup other UI components
        binding.buttonPause.setOnClickListener {
            viewModel.onPauseGame()
        }
        
        binding.buttonHint.setOnClickListener {
            viewModel.onRequestHint()
        }
        
        binding.buttonRestart.setOnClickListener {
            viewModel.onRestartGame()
        }
    }
    
    private fun setupObservers() {
        // Observe UI state
        viewModel.uiState.observe(viewLifecycleOwner) { uiState ->
            updateUIState(uiState)
        }
        
        // Observe game state
        viewModel.gameState.observe(viewLifecycleOwner) { gameState ->
            gameState?.let { updateGameState(it) }
        }
        
        // Observe timer state
        viewModel.timerState.observe(viewLifecycleOwner) { timerState ->
            updateTimerState(timerState)
        }
        
        // Observe UI events
        viewModel.uiEvents.observe(viewLifecycleOwner) { event ->
            handleUIEvent(event)
        }
    }
    
    private fun updateUIState(uiState: GameViewModel.GameUiState) {
        binding.apply {
            // Loading state
            progressBar.isVisible = uiState.isLoading
            
            // Error state
            if (uiState.errorMessage != null) {
                showError(uiState.errorMessage)
            }
            
            // Game ready state
            groupGameControls.isVisible = uiState.isGameReady
            
            // Interaction state
            recyclerViewPuzzleGrid.isEnabled = uiState.canInteract
            buttonHint.isEnabled = uiState.canInteract && !uiState.isLoadingHint
            
            // Hint loading
            buttonHint.text = if (uiState.isLoadingHint) "..." else "Pista"
        }
    }
    
    private fun updateGameState(gameState: GameState) {
        binding.apply {
            // Update puzzle grid
            puzzleGridAdapter.submitList(gameState.pieces)
            
            // Update game info
            textViewMoveCount.text = "Movimientos: ${gameState.moveCount}"
            textViewHintsUsed.text = "Pistas: ${gameState.hintsUsed}/${gameState.maxHints}"
            
            // Update puzzle progress
            val progressPercentage = calculateProgress(gameState.pieces)
            progressBarPuzzle.progress = progressPercentage
            
            // Pause overlay
            overlayPaused.isVisible = gameState.isPaused
        }
    }
    
    private fun updateTimerState(timerState: GameViewModel.TimerState) {
        binding.textViewTimer.text = timerState.formattedTime
        
        // Timer animation
        if (timerState.isRunning) {
            binding.textViewTimer.startAnimation(
                AnimationUtils.loadAnimation(context, R.anim.pulse)
            )
        } else {
            binding.textViewTimer.clearAnimation()
        }
    }
    
    private fun handleUIEvent(event: GameViewModel.GameUiEvent) {
        when (event) {
            is GameViewModel.GameUiEvent.ShowError -> {
                showError(event.error)
            }
            
            is GameViewModel.GameUiEvent.ShowMessage -> {
                showMessage(event.message)
            }
            
            is GameViewModel.GameUiEvent.PuzzleCompleted -> {
                showCompletionDialog(event.result)
            }
            
            is GameViewModel.GameUiEvent.ShowHint -> {
                highlightHintPiece(event.hint.pieceId)
            }
            
            is GameViewModel.GameUiEvent.ConfirmRestart -> {
                showRestartConfirmationDialog(event.onConfirm)
            }
            
            GameViewModel.GameUiEvent.StartCompletionAnimation -> {
                startCompletionAnimation()
            }
            
            // Handle other events...
            else -> {
                // Handle other events
            }
        }
    }
    
    private fun showError(message: String) {
        Snackbar.make(binding.root, message, Snackbar.LENGTH_LONG)
            .setAction("Reintentar") {
                viewModel.onErrorShown()
            }
            .show()
    }
    
    private fun showMessage(message: String) {
        Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
    }
    
    private fun showCompletionDialog(result: PuzzleCompletionResult) {
        MaterialAlertDialogBuilder(requireContext())
            .setTitle("¬°Puzzle Completado!")
            .setMessage("Puntuaci√≥n: ${result.score.totalPoints}\nTiempo: ${formatTime(result.puzzle.progress.completionTimeMs ?: 0)}")
            .setPositiveButton("Continuar") { _, _ ->
                findNavController().popBackStack()
            }
            .setNegativeButton("Jugar de nuevo") { _, _ ->
                viewModel.onRestartGame()
            }
            .show()
    }
    
    private fun highlightHintPiece(pieceId: PieceId) {
        // Find the piece in the adapter and highlight it
        puzzleGridAdapter.highlightPiece(pieceId)
        
        // Auto-remove highlight after 3 seconds
        binding.root.postDelayed({
            puzzleGridAdapter.clearHighlight()
        }, 3000)
    }
    
    private fun startCompletionAnimation() {
        // Trigger confetti or celebration animation
        binding.animationView.apply {
            setAnimation(R.raw.celebration_animation)
            playAnimation()
        }
    }
    
    private fun calculateProgress(pieces: List&lt;PuzzlePiece&gt;): Int {
        val correctPieces = pieces.count { it.isInCorrectPosition() }
        return (correctPieces * 100) / pieces.size
    }
    
    private fun formatTime(milliseconds: Long): String {
        val seconds = milliseconds / 1000
        val minutes = seconds / 60
        val remainingSeconds = seconds % 60
        return "%02d:%02d".format(minutes, remainingSeconds)
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}</code></pre>
        </div>

        <h2>üîÑ Navegaci√≥n entre Pantallas</h2>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">presentation/navigation/PuzzleNavigation.kt</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Composable
fun PuzzleNavGraph(
    navController: NavHostController,
    startDestination: String = "puzzle_list"
) {
    NavHost(
        navController = navController,
        startDestination = startDestination
    ) {
        // Puzzle List Screen
        composable("puzzle_list") {
            PuzzleListScreen(
                onPuzzleClick = { puzzle ->
                    navController.navigate("game/${puzzle.id.value}")
                },
                onNavigateToSettings = {
                    navController.navigate("settings")
                }
            )
        }
        
        // Game Screen
        composable(
            route = "game/{puzzleId}",
            arguments = listOf(
                navArgument("puzzleId") { 
                    type = NavType.StringType 
                }
            )
        ) { backStackEntry ->
            val puzzleId = backStackEntry.arguments?.getString("puzzleId") ?: ""
            
            GameScreen(
                onNavigateBack = {
                    navController.popBackStack()
                },
                onNavigateToCompletion = { completionResult ->
                    navController.navigate("completion/${puzzleId}") {
                        // Pass completion result as arguments or saved state
                        popUpTo("puzzle_list")
                    }
                }
            )
        }
        
        // Completion Screen
        composable(
            route = "completion/{puzzleId}",
            arguments = listOf(
                navArgument("puzzleId") { 
                    type = NavType.StringType 
                }
            )
        ) { backStackEntry ->
            val puzzleId = backStackEntry.arguments?.getString("puzzleId") ?: ""
            
            CompletionScreen(
                puzzleId = puzzleId,
                onNavigateToList = {
                    navController.navigate("puzzle_list") {
                        popUpTo("puzzle_list") { inclusive = true }
                    }
                },
                onPlayAgain = {
                    navController.navigate("game/$puzzleId") {
                        popUpTo("puzzle_list")
                    }
                }
            )
        }
        
        // Settings Screen
        composable("settings") {
            SettingsScreen(
                onNavigateBack = {
                    navController.popBackStack()
                }
            )
        }
    }
}</code></pre>
        </div>

        <h2>üéØ Mejores Pr√°cticas para la Capa View</h2>

        <div class="best-practices">
          <div class="practice-card">
            <h4>üîÑ State Observation</h4>
            <ul>
              <li>Use collectAsState() en Compose</li>
              <li>Collect en lifecycle-aware scope</li>
              <li>Handle configuration changes properly</li>
              <li>Avoid collecting in unstable scopes</li>
            </ul>
          </div>
          
          <div class="practice-card">
            <h4>üé® Performance</h4>
            <ul>
              <li>Lazy loading para listas grandes</li>
              <li>Use remember para computaciones costosas</li>
              <li>Minimize recompositions</li>
              <li>Proper key usage en LazyColumn</li>
            </ul>
          </div>
          
          <div class="practice-card">
            <h4>‚ôø Accessibility</h4>
            <ul>
              <li>ContentDescription para im√°genes</li>
              <li>Semantic properties apropiadas</li>
              <li>Keyboard navigation support</li>
              <li>Screen reader compatibility</li>
            </ul>
          </div>
          
          <div class="practice-card">
            <h4>üß™ Testing</h4>
            <ul>
              <li>UI tests con Compose Testing</li>
              <li>Mock ViewModels para testing</li>
              <li>Test user interactions</li>
              <li>Verify state changes visually</li>
            </ul>
          </div>
        </div>

        <h2>üîó Pr√≥ximos Pasos</h2>
        
        <p>Con la capa View completa, explora:</p>
        
        <div class="next-steps">
          <div class="step-card">
            <h4>üîó <a href="blog-data-binding-mvvm.html">Data Binding MVVM</a></h4>
            <p>Binding declarativo avanzado entre View y ViewModel</p>
          </div>
          
          <div class="step-card">
            <h4>üíâ <a href="blog-dependency-injection-mvvm.html">Dependency Injection</a></h4>
            <p>Configuraci√≥n completa de DI para MVVM</p>
          </div>
          
          <div class="step-card">
            <h4>üß™ <a href="blog-testing-mvvm.html">Testing MVVM</a></h4>
            <p>Testing integral de todas las capas</p>
          </div>
        </div>

        <div class="article-footer">
          <div class="article-tags">
            <span class="tag">Android</span>
            <span class="tag">Kotlin</span>
            <span class="tag">MVVM</span>
            <span class="tag">View Layer</span>
            <span class="tag">Jetpack Compose</span>
            <span class="tag">UI</span>
            <span class="tag">Navigation</span>
            <span class="tag">Animations</span>
          </div>
          
          <div class="article-navigation">
            <a href="blog-mvvm-viewmodel.html" class="nav-button">‚Üê ViewModel Layer</a>
            <a href="blog-data-binding-mvvm.html" class="nav-button">Siguiente: Data Binding ‚Üí</a>
          </div>
          
          <div class="share-section">
            <h4>¬øTe gust√≥ este art√≠culo?</h4>
            <p>Comp√°rtelo con otros desarrolladores Android</p>
            <div class="share-buttons">
              <button class="share-btn twitter">üê¶ Twitter</button>
              <button class="share-btn linkedin">üíº LinkedIn</button>
              <button class="share-btn copy">üìã Copiar enlace</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </article>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-text">
          <p>&copy; 2025 ArceApps. Desarrollado con HTML, CSS y JavaScript.</p>
        </div>
        <div class="footer-links">
          <a href="#" class="footer-link">GitHub</a>
          <a href="#" class="footer-link">LinkedIn</a>
          <a href="#" class="footer-link">Contacto</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>