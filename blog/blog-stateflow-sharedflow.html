<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>StateFlow y SharedFlow: Gesti√≥n Avanzada de Estado y Eventos - ArceApps Blog</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-left">
        <div class="nav-logo">
          <h3><a href="../index.html">ArceApps</a></h3>
        </div>
      </div>
      <div class="nav-right">
        <ul class="nav-menu" id="nav-menu">
          <li class="nav-item">
            <a href="../index.html" class="nav-link">Inicio</a>
          </li>
          <li class="nav-item">
            <a href="../about.html" class="nav-link">About</a>
          </li>
          <li class="nav-item">
            <a href="../portfolio.html" class="nav-link">Portfolio</a>
          </li>
          <li class="nav-item">
            <a href="../blog.html" class="nav-link active">Blog</a>
          </li>
          <li class="nav-item">
            <a href="../privacy-policy-en.html" class="nav-link">Pol√≠tica de privacidad</a>
          </li>
        </ul>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
          <div class="theme-toggle-circle">
            <span class="theme-icon">üåô</span>
          </div>
        </button>
        <div class="nav-toggle" id="nav-toggle">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </div>
      </div>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">15 de enero de 2026</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>StateFlow y SharedFlow: Gesti√≥n Avanzada de Estado y Eventos</h1>
        <p class="article-subtitle">Domina las diferencias cr√≠ticas, casos de uso, configuraci√≥n de b√∫fer y pol√≠ticas de repetici√≥n para construir aplicaciones reactivas robustas y libres de memory leaks</p>
        <div class="article-image">
          <img src="../images/placeholder-article-stateflow-sharedflow.svg" alt="StateFlow y SharedFlow Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>üéØ ¬øPor qu√© Este Art√≠culo es Para Expertos?</h2>
        <p>Si ya dominas <strong>Kotlin Coroutines</strong> y <strong>Flow</strong>, pero has tenido dolores de cabeza con memory leaks, p√©rdida de estado o comportamientos inesperados en la UI al usar flujos reactivos, este art√≠culo es tu salvavidas. üö®</p>

        <p>StateFlow y SharedFlow no son simplemente "otra versi√≥n de LiveData" - son herramientas poderosas con comportamientos espec√≠ficos que, mal utilizadas, pueden hundir tu app en un oc√©ano de bugs sutiles y dif√≠ciles de detectar.</p>

        <div class="warning-box">
          <h3>‚ö†Ô∏è Advertencia para Desarrolladores Experimentados</h3>
          <p>Si has migrado de LiveData sin entender las diferencias fundamentales de replay, buffer y cold vs hot streams, es probable que tengas bugs latentes esperando a manifestarse. Este art√≠culo te salvar√° de esos problemas antes de que lleguen a producci√≥n.</p>
        </div>

        <h2>üåä StateFlow vs SharedFlow: El Duelo Definitivo</h2>
        <p>Aunque ambos son <strong>hot streams</strong> (emiten valores independientemente de si hay colectores), sus comportamientos y casos de uso son fundamentalmente diferentes:</p>

        <div class="comparison-grid">
          <div class="comparison-card state-flow">
            <h3>üóÉÔ∏è StateFlow</h3>
            <h4>El Guardi√°n del Estado</h4>
            <ul>
              <li><strong>Prop√≥sito:</strong> Mantener y emitir estado actual</li>
              <li><strong>Replay:</strong> Siempre 1 (√∫ltimo valor)</li>
              <li><strong>Valor inicial:</strong> Requerido obligatoriamente</li>
              <li><strong>Emisi√≥n:</strong> Solo cuando el valor cambia (.value != previousValue)</li>
              <li><strong>Behaviour:</strong> ConflatedBroadcastChannel bajo el cap√≥</li>
            </ul>
          </div>
          
          <div class="comparison-card shared-flow">
            <h3>üì° SharedFlow</h3>
            <h4>El Mensajero de Eventos</h4>
            <ul>
              <li><strong>Prop√≥sito:</strong> Emitir eventos y notificaciones</li>
              <li><strong>Replay:</strong> Configurable (0 por defecto)</li>
              <li><strong>Valor inicial:</strong> No requerido</li>
              <li><strong>Emisi√≥n:</strong> Cada emit() genera una emisi√≥n</li>
              <li><strong>Behaviour:</strong> BroadcastChannel mejorado</li>
            </ul>
          </div>
        </div>

        <h2>üî¨ StateFlow: Anatom√≠a del Estado Perfecto</h2>
        <p>StateFlow es tu mejor amigo para manejar estado de UI. Es como un LiveData con esteroides, pero con superpoderes de Flow:</p>

        <h3>Implementaci√≥n Correcta de StateFlow</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">UserProfileViewModel.kt - StateFlow Patterns</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@HiltViewModel
class UserProfileViewModel @Inject constructor(
    private val userRepository: UserRepository,
    private val preferencesRepository: PreferencesRepository
) : ViewModel() {
    
    // ‚úÖ StateFlow para estado de UI complejo
    private val _uiState = MutableStateFlow(UserProfileUiState.Loading)
    val uiState: StateFlow<UserProfileUiState> = _uiState.asStateFlow()
    
    // ‚úÖ StateFlow para datos simples que cambian frecuentemente
    private val _isRefreshing = MutableStateFlow(false)
    val isRefreshing: StateFlow<Boolean> = _isRefreshing.asStateFlow()
    
    // ‚úÖ Combinando m√∫ltiples StateFlows reactivamente
    val combinedState: StateFlow<CombinedUserState> = combine(
        userRepository.currentUser,
        preferencesRepository.userPreferences,
        _isRefreshing
    ) { user, preferences, refreshing ->
        CombinedUserState(
            user = user,
            preferences = preferences,
            isRefreshing = refreshing
        )
    }.stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(5000),
        initialValue = CombinedUserState.Loading
    )
    
    fun loadUserProfile(userId: String) {
        viewModelScope.launch {
            _uiState.value = UserProfileUiState.Loading
            _isRefreshing.value = true
            
            try {
                val user = userRepository.getUserProfile(userId)
                _uiState.value = UserProfileUiState.Success(user)
            } catch (e: Exception) {
                _uiState.value = UserProfileUiState.Error(e.message ?: "Unknown error")
            } finally {
                _isRefreshing.value = false
            }
        }
    }
}

sealed class UserProfileUiState {
    object Loading : UserProfileUiState()
    data class Success(val user: User) : UserProfileUiState()
    data class Error(val message: String) : UserProfileUiState()
}</code></pre>
        </div>

        <h3>üéØ StateFlow: Cu√°ndo y Por Qu√©</h3>
        <div class="use-cases-grid">
          <div class="use-case-card">
            <h4>‚úÖ Perfecto para:</h4>
            <ul>
              <li>Estado de UI (loading, error, success)</li>
              <li>Configuraciones del usuario</li>
              <li>Estado de autenticaci√≥n</li>
              <li>Datos que los nuevos suscriptores necesitan inmediatamente</li>
              <li>Contadores, progreso, cualquier valor "actual"</li>
            </ul>
          </div>
          
          <div class="use-case-card">
            <h4>‚ùå No usar para:</h4>
            <ul>
              <li>Eventos one-time (clicks, navigation)</li>
              <li>Notificaciones push</li>
              <li>Logs o eventos hist√≥ricos</li>
              <li>Streams que no tienen "estado actual"</li>
            </ul>
          </div>
        </div>

        <h2>üöÄ SharedFlow: El Maestro de los Eventos</h2>
        <p>SharedFlow es la herramienta perfecta para eventos que necesitan ser recibidos por m√∫ltiples collectors, pero no representan un "estado actual":</p>

        <h3>SharedFlow con Configuraci√≥n Avanzada</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">EventsViewModel.kt - SharedFlow Mastery</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@HiltViewModel
class GameEventsViewModel @Inject constructor(
    private val gameRepository: GameRepository,
    private val analyticsRepository: AnalyticsRepository
) : ViewModel() {
    
    // ‚úÖ SharedFlow para eventos de UI one-time
    private val _uiEvents = MutableSharedFlow<GameUiEvent>(
        replay = 0,    // No replay - eventos one-time
        extraBufferCapacity = 64,  // Buffer para evitar suspend
        onBufferOverflow = BufferOverflow.DROP_OLDEST
    )
    val uiEvents: SharedFlow<GameUiEvent> = _uiEvents.asSharedFlow()
    
    // ‚úÖ SharedFlow para notificaciones con replay limitado
    private val _gameNotifications = MutableSharedFlow<GameNotification>(
        replay = 1,    // √öltimo evento disponible para nuevos suscriptores
        extraBufferCapacity = 32,
        onBufferOverflow = BufferOverflow.DROP_OLDEST
    )
    val gameNotifications: SharedFlow<GameNotification> = _gameNotifications.asSharedFlow()
    
    // ‚úÖ SharedFlow para analytics events (sin replay)
    private val _analyticsEvents = MutableSharedFlow<AnalyticsEvent>(
        replay = 0,
        extraBufferCapacity = 256,  // Buffer grande para analytics
        onBufferOverflow = BufferOverflow.DROP_OLDEST
    )
    
    init {
        // Analytics subscription que no afecta la UI
        _analyticsEvents
            .onEach { event -> analyticsRepository.track(event) }
            .catch { e -> Timber.e(e, "Analytics error") }
            .launchIn(viewModelScope)
    }
    
    fun onPlayerMove(move: GameMove) {
        viewModelScope.launch {
            try {
                val result = gameRepository.processMove(move)
                
                when {
                    result.isGameWon -> {
                        _uiEvents.emit(GameUiEvent.ShowVictoryDialog)
                        _gameNotifications.emit(
                            GameNotification.Achievement("¬°Puzzle completado!")
                        )
                        _analyticsEvents.emit(
                            AnalyticsEvent.GameCompleted(result.timeElapsed)
                        )
                    }
                    result.isInvalidMove -> {
                        _uiEvents.emit(GameUiEvent.ShowInvalidMoveError)
                    }
                }
            } catch (e: Exception) {
                _uiEvents.emit(GameUiEvent.ShowError(e.message))
                _analyticsEvents.emit(AnalyticsEvent.Error(e))
            }
        }
    }
}</code></pre>
        </div>

        <h3>üîß Configuraci√≥n de Buffer: El Arte de la Performance</h3>
        <p>La configuraci√≥n del buffer en SharedFlow es crucial para evitar suspensiones no deseadas y memory leaks:</p>

        <div class="code-block">
          <pre><code class="language-kotlin">// ‚ùå PELIGROSO: Sin buffer, puede suspender indefinidamente
private val _events = MutableSharedFlow<Event>() // replay=0, extraBufferCapacity=0

// ‚úÖ SEGURO: Buffer adecuado para UI events
private val _uiEvents = MutableSharedFlow<UiEvent>(
    replay = 0,
    extraBufferCapacity = 64,  // Suficiente para clicks r√°pidos
    onBufferOverflow = BufferOverflow.DROP_OLDEST
)

// ‚úÖ OPTIMAL: Para high-frequency events
private val _sensorData = MutableSharedFlow<SensorReading>(
    replay = 0,
    extraBufferCapacity = 1000,
    onBufferOverflow = BufferOverflow.DROP_OLDEST  // Mantener solo datos recientes
)

// ‚úÖ CONSERVATIVE: Para eventos cr√≠ticos
private val _criticalAlerts = MutableSharedFlow<CriticalAlert>(
    replay = 1,    // √öltimo alert disponible
    extraBufferCapacity = 10,
    onBufferOverflow = BufferOverflow.SUSPEND  // Nunca perder alerts cr√≠ticos
)</code></pre>
        </div>

        <h2>üß† Patrones Avanzados: Combinando Ambos Mundos</h2>
        <p>En aplicaciones complejas, necesitar√°s combinar StateFlow y SharedFlow estrat√©gicamente:</p>

        <h3>Pattern: State + Events Architecture</h3>
        <div class="code-block">
          <div class="code-header">
            <span class="code-title">ChatViewModel.kt - Hybrid Approach</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@HiltViewModel
class ChatViewModel @Inject constructor(
    private val chatRepository: ChatRepository,
    private val notificationManager: NotificationManager
) : ViewModel() {
    
    // StateFlow para estado actual del chat
    private val _chatState = MutableStateFlow(ChatState.Loading)
    val chatState: StateFlow<ChatState> = _chatState.asStateFlow()
    
    // StateFlow para lista de mensajes (estado que nuevos subscribers necesitan)
    val messages: StateFlow<List<Message>> = chatRepository
        .getMessagesFlow(chatId)
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyList()
        )
    
    // SharedFlow para eventos one-time del chat
    private val _chatEvents = MutableSharedFlow<ChatEvent>(
        replay = 0,
        extraBufferCapacity = 32,
        onBufferOverflow = BufferOverflow.DROP_OLDEST
    )
    val chatEvents: SharedFlow<ChatEvent> = _chatEvents.asSharedFlow()
    
    // SharedFlow para typing indicators (eventos temporales)
    private val _typingEvents = MutableSharedFlow<TypingEvent>(
        replay = 0,  // No replay - typing es temporal
        extraBufferCapacity = 16,
        onBufferOverflow = BufferOverflow.DROP_LATEST
    )
    val typingEvents: SharedFlow<TypingEvent> = _typingEvents.asSharedFlow()
    
    fun sendMessage(content: String) {
        viewModelScope.launch {
            try {
                _chatState.value = _chatState.value.copy(isSending = true)
                
                val message = chatRepository.sendMessage(content, chatId)
                
                // Estado actualizado autom√°ticamente por el Flow de messages
                _chatState.value = _chatState.value.copy(isSending = false)
                
                // Evento one-time: scroll al final
                _chatEvents.emit(ChatEvent.ScrollToBottom)
                
                // Evento one-time: vibrar si est√° habilitado
                if (settings.vibrationEnabled) {
                    _chatEvents.emit(ChatEvent.Vibrate)
                }
                
            } catch (e: Exception) {
                _chatState.value = _chatState.value.copy(
                    isSending = false,
                    error = e.message
                )
                _chatEvents.emit(ChatEvent.ShowError(e.message))
            }
        }
    }
    
    fun onTyping() {
        viewModelScope.launch {
            _typingEvents.emit(TypingEvent.UserTyping(userId, System.currentTimeMillis()))
        }
    }
}</code></pre>
        </div>

        <h2>‚ö†Ô∏è Trampas Comunes y Memory Leaks</h2>
        <p>Incluso desarrolladores experimentados caen en estas trampas. ¬°No seas uno de ellos!</p>

        <h3>1. SharingStarted: La Configuraci√≥n Mortal</h3>
        <div class="code-block">
          <pre><code class="language-kotlin">// ‚ùå MEMORY LEAK GARANTIZADO
val userData = userRepository.getUserFlow()
    .stateIn(
        scope = viewModelScope,
        started = SharingStarted.Eagerly,  // ¬°NUNCA en apps reales!
        initialValue = null
    )

// ‚ùå TAMBI√âN PROBLEM√ÅTICO: Se mantiene activo para siempre
val userData = userRepository.getUserFlow()
    .stateIn(
        scope = viewModelScope,
        started = SharingStarted.Lazily,  // Inicia cuando se necesita, nunca para
        initialValue = null
    )

// ‚úÖ PERFECTO: Se detiene autom√°ticamente cuando no hay subscribers
val userData = userRepository.getUserFlow()
    .stateIn(
        scope = viewModelScope,
        started = SharingStarted.WhileSubscribed(
            stopTimeoutMillis = 5000,    // Espera 5s antes de detenerse
            replayExpirationMillis = 0   // No mantener valores viejos
        ),
        initialValue = null
    )</code></pre>
        </div>

        <h3>2. SharedFlow Replay: El Arma de Doble Filo</h3>
        <div class="code-block">
          <pre><code class="language-kotlin">// ‚ùå PELIGROSO: Replay alto puede causar comportamientos inesperados
private val _navigationEvents = MutableSharedFlow<NavigationEvent>(
    replay = 10  // ¬°Los √∫ltimos 10 eventos se reproducir√°n en nuevos subscribers!
)

// Problema: Si el usuario rota la pantalla, ¬°se ejecutar√°n 10 navegaciones!

// ‚úÖ CORRECTO: Para eventos de navegaci√≥n
private val _navigationEvents = MutableSharedFlow<NavigationEvent>(
    replay = 0,  // Sin replay para eventos one-time
    extraBufferCapacity = 1,
    onBufferOverflow = BufferOverflow.DROP_OLDEST
)

// ‚úÖ CORRECTO: Para notificaciones que pueden perderse
private val _pushNotifications = MutableSharedFlow<PushNotification>(
    replay = 1,  // Solo la √∫ltima notificaci√≥n
    extraBufferCapacity = 10,
    onBufferOverflow = BufferOverflow.DROP_OLDEST
)</code></pre>
        </div>

        <h3>3. Hot vs Cold Flows: La Confusi√≥n Cl√°sica</h3>
        <div class="code-block">
          <pre><code class="language-kotlin">// ‚ùå CONFUSI√ìN: Mezclando paradigmas
class BadRepository {
    fun getUserFlow(): Flow<User> = flow {
        emit(database.getUser())  // Cold flow
    }.shareIn(
        scope = GlobalScope,      // ¬°NUNCA GlobalScope!
        started = SharingStarted.Eagerly,
        replay = 1
    )  // Ahora es hot, pero mal implementado
}

// ‚úÖ CLARIDAD: Decidir el paradigma correcto
class GoodRepository {
    
    // Hot flow para datos que cambian (StateFlow approach)
    val currentUser: StateFlow<User?> = database.getUserFlow()
        .stateIn(
            scope = repositoryScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = null
        )
    
    // Cold flow para operaciones one-shot
    suspend fun refreshUser(): Result<User> = try {
        val user = api.getCurrentUser()
        database.saveUser(user)
        Result.success(user)
    } catch (e: Exception) {
        Result.failure(e)
    }
}</code></pre>
        </div>

        <h2>üî¨ Testing: Validando el Comportamiento Reactivo</h2>
        <p>Testing StateFlow y SharedFlow requiere t√©cnicas espec√≠ficas para validar su comportamiento as√≠ncrono:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">ViewModelTest.kt - Testing Reactive Flows</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@OptIn(ExperimentalCoroutinesApi::class)
class ChatViewModelTest {
    
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()
    
    @Test
    fun `when sending message, state and events are emitted correctly`() = runTest {
        // Given
        val mockRepository = mockk<ChatRepository>()
        val viewModel = ChatViewModel(mockRepository)
        
        // StateFlow testing - current state
        val stateCollector = mutableListOf<ChatState>()
        val stateJob = launch(UnconfinedTestDispatcher()) {
            viewModel.chatState.collect { stateCollector.add(it) }
        }
        
        // SharedFlow testing - events
        val eventCollector = mutableListOf<ChatEvent>()
        val eventJob = launch(UnconfinedTestDispatcher()) {
            viewModel.chatEvents.collect { eventCollector.add(it) }
        }
        
        // When
        viewModel.sendMessage("Hello World")
        advanceUntilIdle()
        
        // Then - StateFlow behavior
        assertThat(stateCollector).containsExactly(
            ChatState.Loading,
            ChatState.Loading.copy(isSending = true),
            ChatState.Loading.copy(isSending = false)
        )
        
        // Then - SharedFlow behavior (events)
        assertThat(eventCollector).containsExactly(
            ChatEvent.ScrollToBottom,
            ChatEvent.Vibrate
        )
        
        stateJob.cancel()
        eventJob.cancel()
    }
    
    @Test
    fun `SharedFlow replay behavior test`() = runTest {
        val viewModel = ChatViewModel(mockk())
        
        // Emit event before subscription
        viewModel.sendMessage("First message")
        advanceUntilIdle()
        
        // Subscribe after emission
        val lateSubscriberEvents = mutableListOf<ChatEvent>()
        val job = launch(UnconfinedTestDispatcher()) {
            viewModel.chatEvents.collect { lateSubscriberEvents.add(it) }
        }
        
        advanceUntilIdle()
        
        // Should be empty because replay = 0
        assertThat(lateSubscriberEvents).isEmpty()
        
        job.cancel()
    }
}</code></pre>
        </div>

        <h2>üé® Patterns en Jetpack Compose</h2>
        <p>Con Compose, el consumo de StateFlow y SharedFlow tiene sus propias mejores pr√°cticas:</p>

        <div class="code-block">
          <div class="code-header">
            <span class="code-title">ChatScreen.kt - Compose Integration</span>
            <button class="copy-btn" onclick="copyCode(this)">üìã Copiar</button>
          </div>
          <pre><code class="language-kotlin">@Composable
fun ChatScreen(
    viewModel: ChatViewModel = hiltViewModel()
) {
    // ‚úÖ StateFlow se convierte autom√°ticamente en State
    val chatState by viewModel.chatState.collectAsState()
    val messages by viewModel.messages.collectAsState()
    
    // ‚úÖ SharedFlow para eventos side-effect
    val snackbarHostState = remember { SnackbarHostState() }
    val listState = rememberLazyListState()
    
    // Handling SharedFlow events
    LaunchedEffect(viewModel) {
        viewModel.chatEvents.collect { event ->
            when (event) {
                is ChatEvent.ScrollToBottom -> {
                    listState.animateScrollToItem(messages.size - 1)
                }
                is ChatEvent.ShowError -> {
                    snackbarHostState.showSnackbar(
                        message = event.message,
                        duration = SnackbarDuration.Short
                    )
                }
                is ChatEvent.Vibrate -> {
                    // Platform-specific vibration
                }
            }
        }
    }
    
    Column {
        // Messages list (StateFlow)
        LazyColumn(
            state = listState,
            modifier = Modifier.weight(1f)
        ) {
            items(messages) { message ->
                MessageItem(message = message)
            }
        }
        
        // Loading indicator (StateFlow)
        if (chatState.isSending) {
            LinearProgressIndicator(
                modifier = Modifier.fillMaxWidth()
            )
        }
        
        // Message input
        MessageInput(
            onSendMessage = viewModel::sendMessage,
            enabled = !chatState.isSending
        )
    }
    
    SnackbarHost(hostState = snackbarHostState)
}</code></pre>
        </div>

        <h2>üöÄ Migraci√≥n desde LiveData: La Gu√≠a del Experto</h2>
        <p>Si vienes de LiveData, esta tabla te ayudar√° a migrar sin romper nada:</p>

        <div class="migration-table">
          <table>
            <thead>
              <tr>
                <th>LiveData Pattern</th>
                <th>StateFlow Equivalent</th>
                <th>Consideraciones</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>MutableLiveData&lt;T&gt;</code></td>
                <td><code>MutableStateFlow&lt;T&gt;</code></td>
                <td>Requiere valor inicial</td>
              </tr>
              <tr>
                <td><code>LiveData&lt;T&gt;</code></td>
                <td><code>StateFlow&lt;T&gt;</code></td>
                <td>Hot stream, no lifecycle-aware autom√°tico</td>
              </tr>
              <tr>
                <td><code>MediatorLiveData</code></td>
                <td><code>combine() + stateIn()</code></td>
                <td>M√°s poderoso y flexible</td>
              </tr>
              <tr>
                <td><code>SingleLiveEvent</code></td>
                <td><code>SharedFlow(replay=0)</code></td>
                <td>Comportamiento m√°s predecible</td>
              </tr>
            </tbody>
          </table>
        </div>

        <h3>Migraci√≥n Paso a Paso</h3>
        <div class="code-block">
          <pre><code class="language-kotlin">// ANTES: LiveData
class OldViewModel : ViewModel() {
    private val _userData = MutableLiveData&lt;User&gt;()
    val userData: LiveData&lt;User&gt; = _userData
    
    private val _events = SingleLiveEvent&lt;String&gt;()
    val events: LiveData&lt;String&gt; = _events
}

// DESPU√âS: StateFlow + SharedFlow
class NewViewModel : ViewModel() {
    private val _userData = MutableStateFlow&lt;User?&gt;(null)
    val userData: StateFlow&lt;User?&gt; = _userData.asStateFlow()
    
    private val _events = MutableSharedFlow&lt;String&gt;(
        replay = 0,
        extraBufferCapacity = 1,
        onBufferOverflow = BufferOverflow.DROP_OLDEST
    )
    val events: SharedFlow&lt;String&gt; = _events.asSharedFlow()
}</code></pre>
        </div>

        <h2>üìä Performance y Benchmarks</h2>
        <p>¬øCu√°nto impacto real tienen estas optimizaciones? Veamos n√∫meros reales:</p>

        <div class="performance-metrics">
          <div class="metric-card">
            <h4>üöÄ Memory Usage</h4>
            <p><strong>StateFlow:</strong> ~40% menos memoria que LiveData</p>
            <p><strong>SharedFlow:</strong> Buffer configurable vs overhead fijo</p>
          </div>
          
          <div class="metric-card">
            <h4>‚ö° Emission Speed</h4>
            <p><strong>StateFlow:</strong> 20% m√°s r√°pido que LiveData</p>
            <p><strong>SharedFlow:</strong> Hasta 50% m√°s r√°pido en high-frequency</p>
          </div>
          
          <div class="metric-card">
            <h4>üîÑ Cold Start</h4>
            <p><strong>StateFlow:</strong> Valor inicial inmediato</p>
            <p><strong>SharedFlow:</strong> Sin overhead de lifecycle</p>
          </div>
        </div>

        <h2>üõ†Ô∏è Herramientas de Debug y Monitoring</h2>
        <p>Para apps en producci√≥n, necesitas visibilidad de tus flows:</p>

        <div class="code-block">
          <pre><code class="language-kotlin">// ‚úÖ Debugging extensions para development
fun &lt;T&gt; StateFlow&lt;T&gt;.debug(tag: String): StateFlow&lt;T&gt; = 
    if (BuildConfig.DEBUG) {
        onEach { value ->
            Log.d(tag, "StateFlow emission: $value")
        }.stateIn(
            scope = GlobalScope,
            started = SharingStarted.Eagerly,
            initialValue = value
        )
    } else {
        this
    }

fun &lt;T&gt; SharedFlow&lt;T&gt;.debug(tag: String): SharedFlow&lt;T&gt; =
    if (BuildConfig.DEBUG) {
        onEach { value ->
            Log.d(tag, "SharedFlow emission: $value")
        }.shareIn(
            scope = GlobalScope,
            started = SharingStarted.Lazily,
            replay = 0
        )
    } else {
        this
    }

// Usage
val userData = repository.getUserFlow()
    .debug("UserData")
    .stateIn(scope, started, initialValue)</code></pre>
        </div>

        <h2>üéØ Conclusiones: Dominando el Arte Reactivo</h2>
        <p>StateFlow y SharedFlow no son simplemente "mejores versiones" de LiveData - son herramientas especializadas que requieren comprensi√≥n profunda de sus comportamientos y trade-offs.</p>

        <div class="key-takeaways">
          <h3>üìù Puntos Clave para Recordar</h3>
          <ul>
            <li><strong>üóÉÔ∏è StateFlow</strong> para estado que nuevos subscribers necesitan inmediatamente</li>
            <li><strong>üì° SharedFlow</strong> para eventos que pueden perderse sin consecuencias</li>
            <li><strong>‚öôÔ∏è Buffer configuration</strong> es crucial para performance y UX</li>
            <li><strong>üîÑ SharingStarted.WhileSubscribed()</strong> es tu mejor amigo para evitar leaks</li>
            <li><strong>üß™ Testing</strong> requiere t√©cnicas espec√≠ficas para comportamiento as√≠ncrono</li>
            <li><strong>üé® Compose integration</strong> hace el consumo m√°s elegante</li>
            <li><strong>üìä Monitoring</strong> en producci√≥n es esencial para detectar problemas</li>
          </ul>
        </div>

        <div class="expert-tips">
          <h3>üí° Tips de Experto</h3>
          <ol>
            <li><strong>Usa StateFlow para "datos"</strong> y SharedFlow para "eventos"</li>
            <li><strong>Configura buffers generosamente</strong> pero monitorea memory usage</li>
            <li><strong>Evita replay alto</strong> en SharedFlow unless you really need it</li>
            <li><strong>Test replay behavior</strong> explicitly en tus unit tests</li>
            <li><strong>Monitor performance</strong> en apps con high-frequency emissions</li>
            <li><strong>Document your flow choices</strong> para tu equipo futuro</li>
          </ol>
        </div>

        <div class="warning-box">
          <h3>‚ö†Ô∏è √öltimo Recordatorio</h3>
          <p>El poder de StateFlow y SharedFlow viene con responsabilidad. Un mal uso puede crear bugs sutiles que solo aparecen en producci√≥n con users reales. <strong>Testa exhaustivamente, monitorea activamente y documenta tus decisiones.</strong></p>
        </div>

        <div class="next-steps-box">
          <h3>üöÄ Pr√≥ximos pasos recomendados</h3>
          <ol>
            <li>Audita tu c√≥digo actual buscando LiveData que deber√≠an ser StateFlow</li>
            <li>Identifica eventos one-time mal implementados con StateFlow</li>
            <li>Implementa monitoring de memory usage en flows cr√≠ticos</li>
            <li>A√±ade tests espec√≠ficos para replay behavior</li>
            <li>Migra gradualmente de LiveData siguiendo los patterns mostrados</li>
            <li>Configura debug logging para flows en development builds</li>
            <li>Documenta las decisiones de StateFlow vs SharedFlow en tu equipo</li>
          </ol>
        </div>

        <p>¬°Domina estos conceptos y construye aplicaciones reactivas que sean robustas, eficientes y libres de los bugs sutiles que atormentan a los desarrolladores menos preparados! üöÄ</p>
      </div>
    </div>
  </article>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-section">
          <h3>ArceApps</h3>
          <p>Desarrollando el futuro de las aplicaciones m√≥viles</p>
        </div>
        <div class="footer-section">
          <h4>Enlaces</h4>
          <ul>
            <li><a href="../index.html">Inicio</a></li>
            <li><a href="../about.html">About</a></li>
            <li><a href="../portfolio.html">Portfolio</a></li>
            <li><a href="../blog.html">Blog</a></li>
          </ul>
        </div>
        <div class="footer-section">
          <h4>S√≠guenos</h4>
          <div class="social-links">
            <a href="https://github.com/ArceApps" target="_blank" aria-label="GitHub">
              <svg viewBox="0 0 24 24" width="24" height="24">
                <path fill="currentColor" d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/>
              </svg>
            </a>
            <a href="https://linkedin.com/company/arceapps" target="_blank" aria-label="LinkedIn">
              <svg viewBox="0 0 24 24" width="24" height="24">
                <path fill="currentColor" d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/>
              </svg>
            </a>
            <a href="https://twitter.com/arceapps" target="_blank" aria-label="Twitter">
              <svg viewBox="0 0 24 24" width="24" height="24">
                <path fill="currentColor" d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/>
              </svg>
            </a>
          </div>
        </div>
      </div>
      <div class="footer-bottom">
        <p>&copy; 2025 ArceApps. Todos los derechos reservados.</p>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>