<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arquitectura MVVM en Android: Guía Completa desde Cero - ArceApps Blog</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-left">
        <div class="nav-logo">
          <h3><a href="../index.html">ArceApps</a></h3>
        </div>
      </div>
      <div class="nav-right">
        <ul class="nav-menu" id="nav-menu">
          <li class="nav-item">
            <a href="../index.html" class="nav-link">Inicio</a>
          </li>
          <li class="nav-item">
            <a href="../about.html" class="nav-link">About</a>
          </li>
          <li class="nav-item">
            <a href="../portfolio.html" class="nav-link">Portfolio</a>
          </li>
          <li class="nav-item">
            <a href="../blog.html" class="nav-link active">Blog</a>
          </li>
        </ul>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
          <div class="theme-toggle-circle">
            <span class="theme-icon">🌙</span>
          </div>
        </button>
        <div class="nav-toggle" id="nav-toggle">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </div>
      </div>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">1 de octubre de 2025</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>Arquitectura MVVM en Android: Guía Completa desde Cero</h1>
        <p class="article-subtitle">Domina el patrón Model-View-ViewModel desde los conceptos básicos hasta implementaciones avanzadas con ejemplos prácticos de un juego de Buscaminas para Android</p>
        <div class="article-image">
          <img src="../images/placeholder-article-mvvm.svg" alt="Arquitectura MVVM Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>🏗️ ¿Por qué necesitamos arquitecturas en nuestras apps?</h2>
        <p>Imagina que estás construyendo una casa. Podrías simplemente apilar ladrillos sin un plano, pero el resultado sería un <strong>desastre caótico</strong>. Lo mismo sucede con nuestras aplicaciones Android. Sin una arquitectura sólida, nuestro código se convierte en lo que llamamos "spaghetti code" 🍝 - imposible de mantener, testear y escalar.</p>

        <div class="architecture-benefits-overview">
          <h3>🎯 Beneficios clave de usar arquitecturas</h3>
          <div class="benefits-grid">
            <div class="benefit-card">
              <div class="benefit-icon">🧪</div>
              <h4>Testabilidad</h4>
              <p>Código separado en capas permite tests unitarios efectivos</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">🔧</div>
              <h4>Mantenibilidad</h4>
              <p>Cambios en una capa no afectan a las demás</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">📈</div>
              <h4>Escalabilidad</h4>
              <p>Fácil añadir nuevas funcionalidades sin romper código existente</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">👥</div>
              <h4>Colaboración</h4>
              <p>Equipos pueden trabajar en paralelo en diferentes capas</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">🐛</div>
              <h4>Debugging</h4>
              <p>Problemas localizados más fácilmente por responsabilidad</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">🔄</div>
              <h4>Reutilización</h4>
              <p>Componentes reutilizables entre diferentes partes de la app</p>
            </div>
          </div>
        </div>

        <h2>📱 ¿Cuándo usar arquitecturas en tu proyecto Android?</h2>
        <p>La pregunta no es "¿debería usar arquitecturas?" sino "¿cuál arquitectura es la adecuada para mi proyecto?". Analicemos diferentes escenarios:</p>

        <div class="project-scenarios">
          <div class="scenario-card green">
            <h4>✅ Proyectos donde SÍ necesitas arquitectura</h4>
            <ul>
              <li><strong>Apps con múltiples pantallas</strong> y navegación compleja</li>
              <li><strong>Equipos de más de 2 desarrolladores</strong> trabajando simultaneamente</li>
              <li><strong>Apps que consumen APIs</strong> y manejan estados complejos</li>
              <li><strong>Proyectos con ciclo de vida largo</strong> (más de 6 meses de desarrollo)</li>
              <li><strong>Apps comerciales</strong> que requieren mantenimiento continuo</li>
              <li><strong>Proyectos con testing requirements</strong> estrictos</li>
            </ul>
          </div>
          
          <div class="scenario-card yellow">
            <h4>⚠️ Proyectos donde podría ser overkill</h4>
            <ul>
              <li><strong>Prototipos rápidos</strong> o proof of concepts</li>
              <li><strong>Apps de una sola pantalla</strong> muy simples</li>
              <li><strong>Proyectos educativos</strong> para aprender conceptos básicos</li>
              <li><strong>Apps con deadline muy agresivo</strong> (menos de 2 semanas)</li>
            </ul>
            <p class="scenario-note">💡 <strong>Nota:</strong> Incluso en estos casos, aplicar principios básicos de separación nunca está de más.</p>
          </div>
        </div>

        <h2>🔍 Comparativa de Arquitecturas en Desarrollo Mobile</h2>
        <p>Antes de profundizar en MVVM, es importante entender el panorama de arquitecturas disponibles para desarrollo móvil:</p>

        <div class="architecture-comparison">
          <div class="arch-card">
            <h4>🏚️ No Architecture (God Activity/Fragment)</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>✅ Pros:</h5>
                <ul>
                  <li>Desarrollo muy rápido inicialmente</li>
                  <li>Curva de aprendizaje mínima</li>
                  <li>Ideal para prototipos</li>
                </ul>
              </div>
              <div class="cons">
                <h5>❌ Contras:</h5>
                <ul>
                  <li>Imposible de testear eficientemente</li>
                  <li>Código acoplado y frágil</li>
                  <li>Pesadilla de mantenimiento</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="arch-card">
            <h4>🏗️ MVC (Model-View-Controller)</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>✅ Pros:</h5>
                <ul>
                  <li>Separación básica de responsabilidades</li>
                  <li>Patrón bien conocido</li>
                  <li>Relativamente simple de implementar</li>
                </ul>
              </div>
              <div class="cons">
                <h5>❌ Contras:</h5>
                <ul>
                  <li>Controller tiende a crecer descontroladamente</li>
                  <li>Acoplamiento entre View y Controller</li>
                  <li>Difícil testing del Controller</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="arch-card">
            <h4>📊 MVP (Model-View-Presenter)</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>✅ Pros:</h5>
                <ul>
                  <li>View completamente pasiva y testeable</li>
                  <li>Lógica de presentación en Presenter</li>
                  <li>Separación clara de responsabilidades</li>
                </ul>
              </div>
              <div class="cons">
                <h5>❌ Contras:</h5>
                <ul>
                  <li>Boilerplate code considerable</li>
                  <li>Memory leaks por referencias View-Presenter</li>
                  <li>Presenter puede volverse complejo</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="arch-card highlighted">
            <h4>🎯 MVVM (Model-View-ViewModel)</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>✅ Pros:</h5>
                <ul>
                  <li>Data binding automático con LiveData/StateFlow</li>
                  <li>ViewModel sobrevive cambios de configuración</li>
                  <li>Excellent separation of concerns</li>
                  <li>Altamente testeable</li>
                  <li>Recomendado oficialmente por Google</li>
                </ul>
              </div>
              <div class="cons">
                <h5>❌ Contras:</h5>
                <ul>
                  <li>Curva de aprendizaje moderada</li>
                  <li>Requiere entender Lifecycle components</li>
                  <li>Puede ser overkill para apps muy simples</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="arch-card">
            <h4>🧅 Clean Architecture</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>✅ Pros:</h5>
                <ul>
                  <li>Separación extrema de capas</li>
                  <li>Altamente testeable y mantenible</li>
                  <li>Independent de frameworks</li>
                </ul>
              </div>
              <div class="cons">
                <h5>❌ Contras:</h5>
                <ul>
                  <li>Complejidad inicial muy alta</li>
                  <li>Mucho boilerplate code</li>
                  <li>Puede ser overkill para proyectos medianos</li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <h2>🏆 ¿Por qué elegir MVVM frente a otras arquitecturas?</h2>
        <p>MVVM se ha convertido en el <strong>estándar de facto</strong> para desarrollo Android por varias razones fundamentales:</p>

        <div class="mvvm-advantages">
          <div class="advantage-item">
            <div class="advantage-icon">🏗️</div>
            <div class="advantage-content">
              <h4>Soporte Nativo de Android</h4>
              <p>Google diseñó Android Architecture Components específicamente para MVVM. ViewModel, LiveData, Data Binding son parte del SDK oficial.</p>
            </div>
          </div>
          
          <div class="advantage-item">
            <div class="advantage-icon">🔄</div>
            <div class="advantage-content">
              <h4>Manejo Automático del Lifecycle</h4>
              <p>ViewModel sobrevive automáticamente a rotaciones de pantalla y otros cambios de configuración, preservando el estado sin esfuerzo adicional.</p>
            </div>
          </div>
          
          <div class="advantage-item">
            <div class="advantage-icon">📊</div>
            <div class="advantage-content">
              <h4>Data Binding Reactivo</h4>
              <p>Con LiveData/StateFlow, la UI se actualiza automáticamente cuando cambian los datos, eliminando la necesidad de actualizar vistas manualmente.</p>
            </div>
          </div>
          
          <div class="advantage-item">
            <div class="advantage-icon">🧪</div>
            <div class="advantage-content">
              <h4>Testing Simplificado</h4>
              <p>ViewModel no tiene dependencias de Android Framework, permitiendo unit tests puros y rápidos sin necesidad de instrumentación.</p>
            </div>
          </div>
        </div>

        <h2>🎯 Las Capas de MVVM: Anatomía de la Arquitectura</h2>
        <p>MVVM divide nuestra aplicación en <strong>tres capas principales</strong>, cada una con responsabilidades específicas y bien definidas:</p>

        <div class="mvvm-layers-diagram">
          <div class="layer-card model">
            <div class="layer-header">
              <h3>📊 MODEL</h3>
              <span class="layer-subtitle">Capa de Datos</span>
            </div>
            <div class="layer-content">
              <h4>Responsabilidades:</h4>
              <ul>
                <li>Gestión de datos (local y remoto)</li>
                <li>Lógica de negocio pura</li>
                <li>Repositorios y fuentes de datos</li>
                <li>Entidades y modelos de dominio</li>
              </ul>
              <h4>Componentes típicos:</h4>
              <ul>
                <li>Room Database</li>
                <li>Retrofit para APIs</li>
                <li>Repository implementations</li>
                <li>Use Cases/Interactors</li>
              </ul>
            </div>
          </div>

          <div class="layer-card view">
            <div class="layer-header">
              <h3>👁️ VIEW</h3>
              <span class="layer-subtitle">Capa de Presentación</span>
            </div>
            <div class="layer-content">
              <h4>Responsabilidades:</h4>
              <ul>
                <li>Mostrar datos al usuario</li>
                <li>Capturar interacciones de usuario</li>
                <li>Delegar lógica al ViewModel</li>
                <li>Observar cambios de estado</li>
              </ul>
              <h4>Componentes típicos:</h4>
              <ul>
                <li>Activities & Fragments</li>
                <li>Jetpack Compose</li>
                <li>XML Layouts</li>
                <li>Adapters</li>
              </ul>
            </div>
          </div>

          <div class="layer-card viewmodel">
            <div class="layer-header">
              <h3>🎭 VIEWMODEL</h3>
              <span class="layer-subtitle">Capa de Lógica de Presentación</span>
            </div>
            <div class="layer-content">
              <h4>Responsabilidades:</h4>
              <ul>
                <li>Lógica de presentación y estado de UI</li>
                <li>Comunicación entre View y Model</li>
                <li>Transformación de datos para la UI</li>
                <li>Manejo de eventos de usuario</li>
              </ul>
              <h4>Componentes típicos:</h4>
              <ul>
                <li>ViewModel classes</li>
                <li>LiveData/StateFlow</li>
                <li>Event handlers</li>
                <li>UI State management</li>
              </ul>
            </div>
          </div>
        </div>

        <h2>🎮 Implementando MVVM: Ejemplo con Buscaminas Android</h2>
        <p>Para demostrar MVVM en acción, vamos a construir un <strong>juego de Buscaminas</strong> desde cero. Este ejemplo te permitirá ver cómo cada capa interactúa en un escenario real.</p>

        <h3>📊 1. Capa MODEL: Entidades y Lógica de Negocio</h3>
        <p>Empezamos definiendo nuestras entidades de dominio y la lógica del juego:</p>

        <div class="code-block">
          <pre><code>// MinesweeperCell.kt - Entidad básica
data class MinesweeperCell(
    val row: Int,
    val column: Int,
    val isMine: Boolean = false,
    val isRevealed: Boolean = false,
    val isFlagged: Boolean = false,
    val neighborMineCount: Int = 0
) {
    val displayValue: String
        get() = when {
            isFlagged -> "🚩"
            !isRevealed -> "⬜"
            isMine -> "💣"
            neighborMineCount > 0 -> neighborMineCount.toString()
            else -> "⬜"
        }
}

// GameState.kt - Estados del juego
sealed class GameState {
    object Loading : GameState()
    object Playing : GameState()
    object Won : GameState()
    data class Lost(val explodedCell: MinesweeperCell) : GameState()
}

// GameDifficulty.kt - Niveles de dificultad
enum class GameDifficulty(
    val rows: Int,
    val columns: Int,
    val mineCount: Int,
    val displayName: String
) {
    BEGINNER(9, 9, 10, "Principiante"),
    INTERMEDIATE(16, 16, 40, "Intermedio"),
    EXPERT(16, 30, 99, "Experto")
}</code></pre>
        </div>

        <h3>🏗️ 2. Repository Pattern: Gestión de Datos</h3>
        <p>El Repository actúa como una <strong>única fuente de verdad</strong> para nuestros datos, abstrayendo la lógica de persistencia:</p>

        <div class="code-block">
          <pre><code>// MinesweeperRepository.kt
interface MinesweeperRepository {
    suspend fun generateBoard(difficulty: GameDifficulty): List&lt;List&lt;MinesweeperCell&gt;&gt;
    suspend fun saveGame(gameId: String, board: List&lt;List&lt;MinesweeperCell&gt;&gt;, state: GameState)
    suspend fun loadGame(gameId: String): GameData?
    suspend fun getGameStatistics(): GameStatistics
    suspend fun updateStatistics(result: GameResult)
}

class MinesweeperRepositoryImpl @Inject constructor(
    private val localDataSource: MinesweeperLocalDataSource,
    private val gameGenerator: GameGenerator
) : MinesweeperRepository {
    
    override suspend fun generateBoard(difficulty: GameDifficulty): List&lt;List&lt;MinesweeperCell&gt;&gt; {
        return gameGenerator.generateBoard(
            rows = difficulty.rows,
            columns = difficulty.columns,
            mineCount = difficulty.mineCount
        )
    }
    
    override suspend fun saveGame(
        gameId: String, 
        board: List&lt;List&lt;MinesweeperCell&gt;&gt;, 
        state: GameState
    ) {
        val gameData = GameData(
            id = gameId,
            board = board,
            state = state,
            timestamp = System.currentTimeMillis()
        )
        localDataSource.saveGame(gameData)
    }
    
    override suspend fun loadGame(gameId: String): GameData? {
        return localDataSource.getGame(gameId)
    }
    
    override suspend fun getGameStatistics(): GameStatistics {
        return localDataSource.getStatistics()
    }
    
    override suspend fun updateStatistics(result: GameResult) {
        localDataSource.updateStatistics(result)
    }
}</code></pre>
        </div>

        <h3>🎯 3. Use Cases: Lógica de Negocio Específica</h3>
        <p>Los Use Cases encapsulan la <strong>lógica de negocio específica</strong> de cada acción del usuario:</p>

        <div class="code-block">
          <pre><code>// RevealCellUseCase.kt - Lógica para revelar una celda
class RevealCellUseCase @Inject constructor() {
    
    operator fun invoke(
        board: List&lt;List&lt;MinesweeperCell&gt;&gt;,
        row: Int,
        column: Int
    ): RevealResult {
        val cell = board[row][column]
        
        // No se puede revelar una celda ya marcada o revelada
        if (cell.isFlagged || cell.isRevealed) {
            return RevealResult.Invalid
        }
        
        // Si es una mina, el juego termina
        if (cell.isMine) {
            return RevealResult.GameLost(cell)
        }
        
        // Revelar la celda y posiblemente celdas vecinas
        val updatedBoard = revealCell(board, row, column)
        
        // Verificar si el juego se ganó
        val isGameWon = checkWinCondition(updatedBoard)
        
        return RevealResult.Success(
            updatedBoard = updatedBoard,
            isGameWon = isGameWon
        )
    }
    
    private fun revealCell(
        board: List&lt;List&lt;MinesweeperCell&gt;&gt;,
        row: Int,
        column: Int
    ): List&lt;List&lt;MinesweeperCell&gt;&gt; {
        val mutableBoard = board.map { it.toMutableList() }.toMutableList()
        
        // Algoritmo de flood-fill para revelar celdas vacías conectadas
        fun floodFill(r: Int, c: Int) {
            if (r !in 0 until board.size || c !in 0 until board[0].size) return
            if (mutableBoard[r][c].isRevealed || mutableBoard[r][c].isMine) return
            
            mutableBoard[r][c] = mutableBoard[r][c].copy(isRevealed = true)
            
            // Si no hay minas vecinas, revelar celdas adyacentes
            if (mutableBoard[r][c].neighborMineCount == 0) {
                for (dr in -1..1) {
                    for (dc in -1..1) {
                        if (dr != 0 || dc != 0) {
                            floodFill(r + dr, c + dc)
                        }
                    }
                }
            }
        }
        
        floodFill(row, column)
        return mutableBoard
    }
    
    private fun checkWinCondition(board: List&lt;List&lt;MinesweeperCell&gt;&gt;): Boolean {
        return board.flatten().all { cell ->
            cell.isMine || cell.isRevealed
        }
    }
}

// ToggleFlagUseCase.kt - Lógica para marcar/desmarcar celdas
class ToggleFlagUseCase @Inject constructor() {
    
    operator fun invoke(
        board: List&lt;List&lt;MinesweeperCell&gt;&gt;,
        row: Int,
        column: Int
    ): List&lt;List&lt;MinesweeperCell&gt;&gt; {
        return board.mapIndexed { r, rowCells ->
            rowCells.mapIndexed { c, cell ->
                if (r == row && c == column && !cell.isRevealed) {
                    cell.copy(isFlagged = !cell.isFlagged)
                } else {
                    cell
                }
            }
        }
    }
}</code></pre>
        </div>

        <h3>🎭 4. ViewModel: El Corazón de MVVM</h3>
        <p>El ViewModel orquesta toda la lógica de presentación y mantiene el estado de la UI:</p>

        <div class="code-block">
          <pre><code>// MinesweeperViewModel.kt
@HiltViewModel
class MinesweeperViewModel @Inject constructor(
    private val repository: MinesweeperRepository,
    private val revealCellUseCase: RevealCellUseCase,
    private val toggleFlagUseCase: ToggleFlagUseCase
) : ViewModel() {
    
    // Estado privado mutable
    private val _uiState = MutableStateFlow(MinesweeperUiState())
    val uiState: StateFlow&lt;MinesweeperUiState&gt; = _uiState.asStateFlow()
    
    private val _gameState = MutableLiveData&lt;GameState&gt;(GameState.Loading)
    val gameState: LiveData&lt;GameState&gt; = _gameState
    
    private val _board = MutableLiveData&lt;List&lt;List&lt;MinesweeperCell&gt;&gt;&gt;()
    val board: LiveData&lt;List&lt;List&lt;MinesweeperCell&gt;&gt;&gt; = _board
    
    private val _elapsedTime = MutableLiveData&lt;Long&gt;(0L)
    val elapsedTime: LiveData&lt;Long&gt; = _elapsedTime
    
    private val _minesRemaining = MutableLiveData&lt;Int&gt;()
    val minesRemaining: LiveData&lt;Int&gt; = _minesRemaining
    
    private var gameTimer: Job? = null
    private var startTime: Long = 0L
    
    fun startNewGame(difficulty: GameDifficulty) {
        viewModelScope.launch {
            try {
                _gameState.value = GameState.Loading
                
                val newBoard = repository.generateBoard(difficulty)
                _board.value = newBoard
                _gameState.value = GameState.Playing
                _minesRemaining.value = difficulty.mineCount
                
                startTimer()
                
                // Actualizar UI state
                _uiState.value = _uiState.value.copy(
                    difficulty = difficulty,
                    isLoading = false,
                    error = null
                )
                
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Error al generar el juego: ${e.message}"
                )
            }
        }
    }
    
    fun onCellClick(row: Int, column: Int) {
        if (_gameState.value != GameState.Playing) return
        
        viewModelScope.launch {
            val currentBoard = _board.value ?: return@launch
            
            when (val result = revealCellUseCase(currentBoard, row, column)) {
                is RevealResult.Success -> {
                    _board.value = result.updatedBoard
                    
                    if (result.isGameWon) {
                        _gameState.value = GameState.Won
                        stopTimer()
                        saveGameResult(GameResult.Won(_elapsedTime.value ?: 0L))
                    }
                }
                
                is RevealResult.GameLost -> {
                    _gameState.value = GameState.Lost(result.explodedCell)
                    stopTimer()
                    saveGameResult(GameResult.Lost(_elapsedTime.value ?: 0L))
                }
                
                RevealResult.Invalid -> {
                    // No hacer nada si la acción es inválida
                }
            }
        }
    }
    
    fun onCellLongClick(row: Int, column: Int) {
        if (_gameState.value != GameState.Playing) return
        
        val currentBoard = _board.value ?: return
        val updatedBoard = toggleFlagUseCase(currentBoard, row, column)
        
        _board.value = updatedBoard
        updateMinesRemaining(updatedBoard)
    }
    
    private fun startTimer() {
        startTime = System.currentTimeMillis()
        gameTimer?.cancel()
        
        gameTimer = viewModelScope.launch {
            while (_gameState.value == GameState.Playing) {
                _elapsedTime.value = (System.currentTimeMillis() - startTime) / 1000
                delay(1000)
            }
        }
    }
    
    private fun stopTimer() {
        gameTimer?.cancel()
        gameTimer = null
    }
    
    private fun updateMinesRemaining(board: List&lt;List&lt;MinesweeperCell&gt;&gt;) {
        val flaggedCount = board.flatten().count { it.isFlagged }
        val currentDifficulty = _uiState.value.difficulty
        _minesRemaining.value = currentDifficulty.mineCount - flaggedCount
    }
    
    private suspend fun saveGameResult(result: GameResult) {
        try {
            repository.updateStatistics(result)
        } catch (e: Exception) {
            // Log error but don't show to user - statistics are not critical
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        stopTimer()
    }
}</code></pre>
        </div>

        <h3>👁️ 5. VIEW: La Interfaz de Usuario</h3>
        <p>Finalmente, la View observa el ViewModel y reacciona a los cambios de estado:</p>

        <div class="code-block">
          <pre><code>// MinesweeperFragment.kt - Implementación con View Binding
@AndroidEntryPoint
class MinesweeperFragment : Fragment() {
    
    private var _binding: FragmentMinesweeperBinding? = null
    private val binding get() = _binding!!
    
    private val viewModel: MinesweeperViewModel by viewModels()
    private lateinit var boardAdapter: MinesweeperBoardAdapter
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentMinesweeperBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        setupUI()
        setupObservers()
        
        // Iniciar juego por defecto
        viewModel.startNewGame(GameDifficulty.BEGINNER)
    }
    
    private fun setupUI() {
        // Configurar RecyclerView para el tablero
        boardAdapter = MinesweeperBoardAdapter(
            onCellClick = { row, column ->
                viewModel.onCellClick(row, column)
            },
            onCellLongClick = { row, column ->
                viewModel.onCellLongClick(row, column)
                true // Consumir el evento
            }
        )
        
        binding.recyclerViewBoard.apply {
            adapter = boardAdapter
            layoutManager = GridLayoutManager(context, GameDifficulty.BEGINNER.columns)
        }
        
        // Configurar botones de dificultad
        binding.buttonBeginner.setOnClickListener {
            viewModel.startNewGame(GameDifficulty.BEGINNER)
        }
        
        binding.buttonIntermediate.setOnClickListener {
            viewModel.startNewGame(GameDifficulty.INTERMEDIATE)
        }
        
        binding.buttonExpert.setOnClickListener {
            viewModel.startNewGame(GameDifficulty.EXPERT)
        }
    }
    
    private fun setupObservers() {
        // Observar estado del juego
        viewModel.gameState.observe(viewLifecycleOwner) { gameState ->
            updateGameStateUI(gameState)
        }
        
        // Observar tablero de juego
        viewModel.board.observe(viewLifecycleOwner) { board ->
            boardAdapter.updateBoard(board)
        }
        
        // Observar tiempo transcurrido
        viewModel.elapsedTime.observe(viewLifecycleOwner) { elapsedTime ->
            binding.textViewTimer.text = formatTime(elapsedTime)
        }
        
        // Observar minas restantes
        viewModel.minesRemaining.observe(viewLifecycleOwner) { minesRemaining ->
            binding.textViewMineCount.text = "💣 $minesRemaining"
        }
        
        // Observar estado de UI con StateFlow
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collect { uiState ->
                updateUiState(uiState)
            }
        }
    }
    
    private fun updateGameStateUI(gameState: GameState) {
        when (gameState) {
            GameState.Loading -> {
                binding.progressBar.isVisible = true
                binding.textViewGameStatus.text = "Generando juego..."
            }
            
            GameState.Playing -> {
                binding.progressBar.isVisible = false
                binding.textViewGameStatus.text = "🎮 Jugando"
            }
            
            GameState.Won -> {
                binding.textViewGameStatus.text = "🎉 ¡Ganaste!"
                showVictoryDialog()
            }
            
            is GameState.Lost -> {
                binding.textViewGameStatus.text = "💥 ¡Perdiste!"
                showGameOverDialog()
            }
        }
    }
    
    private fun showVictoryDialog() {
        MaterialAlertDialogBuilder(requireContext())
            .setTitle("🎉 ¡Felicitaciones!")
            .setMessage("Has ganado el juego")
            .setPositiveButton("Jugar de nuevo") { _, _ ->
                val currentDifficulty = viewModel.uiState.value.difficulty
                viewModel.startNewGame(currentDifficulty)
            }
            .show()
    }
}</code></pre>
        </div>

        <h2>🧪 Testing en Arquitectura MVVM</h2>
        <p>Una de las mayores ventajas de MVVM es la <strong>facilidad para testing</strong>. Cada capa puede probarse independientemente:</p>

        <div class="code-block">
          <pre><code>// MinesweeperViewModelTest.kt
@ExtendWith(MockitoExtension::class)
class MinesweeperViewModelTest {
    
    @Mock
    private lateinit var repository: MinesweeperRepository
    
    @Mock
    private lateinit var revealCellUseCase: RevealCellUseCase
    
    @Mock
    private lateinit var toggleFlagUseCase: ToggleFlagUseCase
    
    private lateinit var viewModel: MinesweeperViewModel
    
    @BeforeEach
    fun setup() {
        viewModel = MinesweeperViewModel(repository, revealCellUseCase, toggleFlagUseCase)
    }
    
    @Test
    fun `startNewGame should update state to playing when successful`() = runTest {
        // Given
        val difficulty = GameDifficulty.BEGINNER
        val mockBoard = createMockBoard(difficulty)
        `when`(repository.generateBoard(difficulty)).thenReturn(mockBoard)
        
        // When
        viewModel.startNewGame(difficulty)
        
        // Then
        assertEquals(GameState.Playing, viewModel.gameState.value)
        assertEquals(mockBoard, viewModel.board.value)
        assertEquals(difficulty.mineCount, viewModel.minesRemaining.value)
    }
    
    @Test
    fun `onCellClick should update game state to won when winning condition met`() = runTest {
        // Given
        val mockBoard = createMockBoard(GameDifficulty.BEGINNER)
        val winningBoard = createWinningBoard()
        
        `when`(revealCellUseCase(mockBoard, 0, 0))
            .thenReturn(RevealResult.Success(winningBoard, true))
        
        viewModel.startNewGame(GameDifficulty.BEGINNER)
        
        // When
        viewModel.onCellClick(0, 0)
        
        // Then
        assertEquals(GameState.Won, viewModel.gameState.value)
        assertEquals(winningBoard, viewModel.board.value)
    }
}</code></pre>
        </div>

        <h2>🔧 Herramientas y Tecnologías Complementarias</h2>
        <p>Para implementar MVVM efectivamente en Android, estas son las herramientas esenciales:</p>

        <div class="tools-grid">
          <div class="tool-card">
            <h4>🏗️ Architecture Components</h4>
            <p>ViewModel, LiveData, Room, Navigation Component para implementar MVVM nativamente</p>
            <div class="code-snippet">
              <code>implementation "androidx.lifecycle:lifecycle-viewmodel-ktx"</code>
            </div>
          </div>
          
          <div class="tool-card">
            <h4>💉 Hilt Dependency Injection</h4>
            <p>Para gestionar dependencias automáticamente y facilitar testing</p>
            <div class="code-snippet">
              <code>@HiltViewModel<br>class MyViewModel @Inject constructor()</code>
            </div>
          </div>
          
          <div class="tool-card">
            <h4>🌊 Kotlin Coroutines + Flow</h4>
            <p>Para manejo asíncrono moderno y programación reactiva</p>
            <div class="code-snippet">
              <code>StateFlow<br>suspend fun<br>viewModelScope</code>
            </div>
          </div>
          
          <div class="tool-card">
            <h4>🧪 Testing Libraries</h4>
            <p>JUnit, Mockito, y Testing coroutines para unit tests efectivos</p>
            <div class="code-snippet">
              <code>runTest { }<br>MockitoExtension<br>InstantTaskExecutorRule</code>
            </div>
          </div>
        </div>

        <h2>⚠️ Errores Comunes en MVVM y Cómo Evitarlos</h2>

        <div class="warning-box">
          <h3>🚫 Antipatrones frecuentes</h3>
          <div class="antipattern-grid">
            <div class="antipattern-item">
              <h4>❌ ViewModel con Context</h4>
              <p>Nunca pases Context al ViewModel - rompe la separación de capas y causa memory leaks</p>
              <div class="code-snippet error">
                <code>// ❌ MAL
class MyViewModel(private val context: Context)</code>
              </div>
              <div class="code-snippet success">
                <code>// ✅ BIEN
class MyViewModel @Inject constructor(
    private val repository: Repository
)</code>
              </div>
            </div>
            
            <div class="antipattern-item">
              <h4>❌ Lógica de negocio en el View</h4>
              <p>La View debe ser pasiva, toda la lógica debe estar en ViewModel o UseCase</p>
              <div class="code-snippet error">
                <code>// ❌ MAL - lógica en Fragment
if (user.age >= 18 && user.hasLicense) {
    showDriveButton()
}</code>
              </div>
              <div class="code-snippet success">
                <code>// ✅ BIEN - lógica en ViewModel
viewModel.canUserDrive.observe { canDrive ->
    driveButton.isVisible = canDrive
}</code>
              </div>
            </div>
          </div>
        </div>

        <h2>🎯 Mejores Prácticas para MVVM en Android</h2>

        <div class="best-practices-box">
          <h3>💡 Recomendaciones clave</h3>
          <ul>
            <li><strong>Un ViewModel por pantalla:</strong> Mantén ViewModels focalizados en una responsabilidad específica</li>
            <li><strong>USA StateFlow sobre LiveData:</strong> Para nuevos proyectos, StateFlow ofrece mejor integración con Compose</li>
            <li><strong>Encapsula el estado:</strong> Expón solo observables inmutables desde el ViewModel</li>
            <li><strong>Naming consistency:</strong> Usa convenciones claras para tus propiedades (_private, public)</li>
            <li><strong>Handle loading states:</strong> Siempre maneja estados de carga, error y éxito</li>
            <li><strong>Test your ViewModels:</strong> Son fáciles de testear, aprovéchalo</li>
          </ul>
        </div>

        <h2>🚀 Próximos Pasos y Conclusiones</h2>
        <p>MVVM no es solo un patrón arquitectónico, es una <strong>filosofía de desarrollo</strong> que promueve código limpio, testeable y mantenible. En nuestro ejemplo del Buscaminas hemos visto cómo:</p>

        <ul>
          <li>🎯 <strong>Separar responsabilidades</strong> hace el código más predecible</li>
          <li>🧪 <strong>Testing se simplifica</strong> enormemente con capas bien definidas</li>
          <li>🔄 <strong>Data binding automático</strong> reduce bugs de sincronización</li>
          <li>⚡ <strong>Estado sobrevive rotaciones</strong> sin esfuerzo adicional</li>
          <li>👥 <strong>Equipos pueden trabajar en paralelo</strong> en diferentes capas</li>
        </ul>

        <div class="next-steps-box">
          <h3>🚀 Próximos pasos recomendados</h3>
          <ol>
            <li>Implementa un proyecto pequeño siguiendo el ejemplo del Buscaminas</li>
            <li>Añade Hilt para inyección de dependencias automática</li>
            <li>Integra Room Database para persistencia local</li>
            <li>Experimenta con Jetpack Compose + ViewModel</li>
            <li>Escribe tests unitarios para tus ViewModels</li>
            <li>Explora patrones avanzados como Clean Architecture</li>
          </ol>
        </div>

        <p>Recuerda: <strong>MVVM no es una solución mágica</strong>, pero aplicado correctamente puede transformar radicalmente la calidad y mantenibilidad de tus aplicaciones Android. ¡Empieza pequeño, aprende los fundamentos, y construye hacia arriba! 🚀</p>

        <div class="article-footer">
          <div class="tags">
            <span class="tag">Android</span>
            <span class="tag">Kotlin</span>
            <span class="tag">MVVM</span>
            <span class="tag">Architecture</span>
            <span class="tag">ViewModel</span>
            <span class="tag">LiveData</span>
            <span class="tag">Repository Pattern</span>
            <span class="tag">Use Cases</span>
            <span class="tag">Clean Code</span>
            <span class="tag">Testing</span>
          </div>
          
          <div class="article-navigation">
            <a href="blog-solid-principles.html" class="prev-article">
              ← Principios SOLID en Android
            </a>
            <a href="blog-kotlin-coroutines.html" class="next-article">
              Kotlin Coroutines →
            </a>
          </div>
        </div>
      </div>
    </div>
  </article>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-text">
          <p>&copy; 2025 ArceApps. Desarrollado con HTML, CSS y JavaScript.</p>
        </div>
        <div class="footer-links">
          <a href="#" class="footer-link">GitHub</a>
          <a href="#" class="footer-link">LinkedIn</a>
          <a href="#" class="footer-link">Contacto</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>