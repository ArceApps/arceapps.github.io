<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Arquitectura MVVM en Android: Gu√≠a Completa desde Cero - ArceApps Blog</title>
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-left">
        <div class="nav-logo">
          <h3><a href="../index.html">ArceApps</a></h3>
        </div>
      </div>
      <div class="nav-right">
        <ul class="nav-menu" id="nav-menu">
          <li class="nav-item">
            <a href="../index.html" class="nav-link">Inicio</a>
          </li>
          <li class="nav-item">
            <a href="../about.html" class="nav-link">About</a>
          </li>
          <li class="nav-item">
            <a href="../portfolio.html" class="nav-link">Portfolio</a>
          </li>
          <li class="nav-item">
            <a href="../blog.html" class="nav-link active">Blog</a>
          </li>
        </ul>
        <button class="theme-toggle" id="theme-toggle" aria-label="Toggle dark mode">
          <div class="theme-toggle-circle">
            <span class="theme-icon">üåô</span>
          </div>
        </button>
        <div class="nav-toggle" id="nav-toggle">
          <span class="bar"></span>
          <span class="bar"></span>
          <span class="bar"></span>
        </div>
      </div>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">1 de octubre de 2025</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>Arquitectura MVVM en Android: Gu√≠a Completa desde Cero</h1>
        <p class="article-subtitle">Domina el patr√≥n Model-View-ViewModel desde los conceptos b√°sicos hasta implementaciones avanzadas con ejemplos pr√°cticos de un juego de Buscaminas para Android</p>
        <div class="article-image">
          <img src="../images/placeholder-article-mvvm.svg" alt="Arquitectura MVVM Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>üèóÔ∏è ¬øPor qu√© necesitamos arquitecturas en nuestras apps?</h2>
        <p>Imagina que est√°s construyendo una casa. Podr√≠as simplemente apilar ladrillos sin un plano, pero el resultado ser√≠a un <strong>desastre ca√≥tico</strong>. Lo mismo sucede con nuestras aplicaciones Android. Sin una arquitectura s√≥lida, nuestro c√≥digo se convierte en lo que llamamos "spaghetti code" üçù - imposible de mantener, testear y escalar.</p>

        <div class="architecture-benefits-overview">
          <h3>üéØ Beneficios clave de usar arquitecturas</h3>
          <div class="benefits-grid">
            <div class="benefit-card">
              <div class="benefit-icon">üß™</div>
              <h4>Testabilidad</h4>
              <p>C√≥digo separado en capas permite tests unitarios efectivos</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üîß</div>
              <h4>Mantenibilidad</h4>
              <p>Cambios en una capa no afectan a las dem√°s</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üìà</div>
              <h4>Escalabilidad</h4>
              <p>F√°cil a√±adir nuevas funcionalidades sin romper c√≥digo existente</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üë•</div>
              <h4>Colaboraci√≥n</h4>
              <p>Equipos pueden trabajar en paralelo en diferentes capas</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üêõ</div>
              <h4>Debugging</h4>
              <p>Problemas localizados m√°s f√°cilmente por responsabilidad</p>
            </div>
            <div class="benefit-card">
              <div class="benefit-icon">üîÑ</div>
              <h4>Reutilizaci√≥n</h4>
              <p>Componentes reutilizables entre diferentes partes de la app</p>
            </div>
          </div>
        </div>

        <h2>üì± ¬øCu√°ndo usar arquitecturas en tu proyecto Android?</h2>
        <p>La pregunta no es "¬ødeber√≠a usar arquitecturas?" sino "¬øcu√°l arquitectura es la adecuada para mi proyecto?". Analicemos diferentes escenarios:</p>

        <div class="project-scenarios">
          <div class="scenario-card green">
            <h4>‚úÖ Proyectos donde S√ç necesitas arquitectura</h4>
            <ul>
              <li><strong>Apps con m√∫ltiples pantallas</strong> y navegaci√≥n compleja</li>
              <li><strong>Equipos de m√°s de 2 desarrolladores</strong> trabajando simultaneamente</li>
              <li><strong>Apps que consumen APIs</strong> y manejan estados complejos</li>
              <li><strong>Proyectos con ciclo de vida largo</strong> (m√°s de 6 meses de desarrollo)</li>
              <li><strong>Apps comerciales</strong> que requieren mantenimiento continuo</li>
              <li><strong>Proyectos con testing requirements</strong> estrictos</li>
            </ul>
          </div>
          
          <div class="scenario-card yellow">
            <h4>‚ö†Ô∏è Proyectos donde podr√≠a ser overkill</h4>
            <ul>
              <li><strong>Prototipos r√°pidos</strong> o proof of concepts</li>
              <li><strong>Apps de una sola pantalla</strong> muy simples</li>
              <li><strong>Proyectos educativos</strong> para aprender conceptos b√°sicos</li>
              <li><strong>Apps con deadline muy agresivo</strong> (menos de 2 semanas)</li>
            </ul>
            <p class="scenario-note">üí° <strong>Nota:</strong> Incluso en estos casos, aplicar principios b√°sicos de separaci√≥n nunca est√° de m√°s.</p>
          </div>
        </div>

        <h2>üîç Comparativa de Arquitecturas en Desarrollo Mobile</h2>
        <p>Antes de profundizar en MVVM, es importante entender el panorama de arquitecturas disponibles para desarrollo m√≥vil:</p>

        <div class="architecture-comparison">
          <div class="arch-card">
            <h4>üèöÔ∏è No Architecture (God Activity/Fragment)</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>‚úÖ Pros:</h5>
                <ul>
                  <li>Desarrollo muy r√°pido inicialmente</li>
                  <li>Curva de aprendizaje m√≠nima</li>
                  <li>Ideal para prototipos</li>
                </ul>
              </div>
              <div class="cons">
                <h5>‚ùå Contras:</h5>
                <ul>
                  <li>Imposible de testear eficientemente</li>
                  <li>C√≥digo acoplado y fr√°gil</li>
                  <li>Pesadilla de mantenimiento</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="arch-card">
            <h4>üèóÔ∏è MVC (Model-View-Controller)</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>‚úÖ Pros:</h5>
                <ul>
                  <li>Separaci√≥n b√°sica de responsabilidades</li>
                  <li>Patr√≥n bien conocido</li>
                  <li>Relativamente simple de implementar</li>
                </ul>
              </div>
              <div class="cons">
                <h5>‚ùå Contras:</h5>
                <ul>
                  <li>Controller tiende a crecer descontroladamente</li>
                  <li>Acoplamiento entre View y Controller</li>
                  <li>Dif√≠cil testing del Controller</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="arch-card">
            <h4>üìä MVP (Model-View-Presenter)</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>‚úÖ Pros:</h5>
                <ul>
                  <li>View completamente pasiva y testeable</li>
                  <li>L√≥gica de presentaci√≥n en Presenter</li>
                  <li>Separaci√≥n clara de responsabilidades</li>
                </ul>
              </div>
              <div class="cons">
                <h5>‚ùå Contras:</h5>
                <ul>
                  <li>Boilerplate code considerable</li>
                  <li>Memory leaks por referencias View-Presenter</li>
                  <li>Presenter puede volverse complejo</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="arch-card highlighted">
            <h4>üéØ MVVM (Model-View-ViewModel)</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>‚úÖ Pros:</h5>
                <ul>
                  <li>Data binding autom√°tico con LiveData/StateFlow</li>
                  <li>ViewModel sobrevive cambios de configuraci√≥n</li>
                  <li>Excellent separation of concerns</li>
                  <li>Altamente testeable</li>
                  <li>Recomendado oficialmente por Google</li>
                </ul>
              </div>
              <div class="cons">
                <h5>‚ùå Contras:</h5>
                <ul>
                  <li>Curva de aprendizaje moderada</li>
                  <li>Requiere entender Lifecycle components</li>
                  <li>Puede ser overkill para apps muy simples</li>
                </ul>
              </div>
            </div>
          </div>

          <div class="arch-card">
            <h4>üßÖ Clean Architecture</h4>
            <div class="arch-pros-cons">
              <div class="pros">
                <h5>‚úÖ Pros:</h5>
                <ul>
                  <li>Separaci√≥n extrema de capas</li>
                  <li>Altamente testeable y mantenible</li>
                  <li>Independent de frameworks</li>
                </ul>
              </div>
              <div class="cons">
                <h5>‚ùå Contras:</h5>
                <ul>
                  <li>Complejidad inicial muy alta</li>
                  <li>Mucho boilerplate code</li>
                  <li>Puede ser overkill para proyectos medianos</li>
                </ul>
              </div>
            </div>
          </div>
        </div>

        <h2>üèÜ ¬øPor qu√© elegir MVVM frente a otras arquitecturas?</h2>
        <p>MVVM se ha convertido en el <strong>est√°ndar de facto</strong> para desarrollo Android por varias razones fundamentales:</p>

        <div class="mvvm-advantages">
          <div class="advantage-item">
            <div class="advantage-icon">üèóÔ∏è</div>
            <div class="advantage-content">
              <h4>Soporte Nativo de Android</h4>
              <p>Google dise√±√≥ Android Architecture Components espec√≠ficamente para MVVM. ViewModel, LiveData, Data Binding son parte del SDK oficial.</p>
            </div>
          </div>
          
          <div class="advantage-item">
            <div class="advantage-icon">üîÑ</div>
            <div class="advantage-content">
              <h4>Manejo Autom√°tico del Lifecycle</h4>
              <p>ViewModel sobrevive autom√°ticamente a rotaciones de pantalla y otros cambios de configuraci√≥n, preservando el estado sin esfuerzo adicional.</p>
            </div>
          </div>
          
          <div class="advantage-item">
            <div class="advantage-icon">üìä</div>
            <div class="advantage-content">
              <h4>Data Binding Reactivo</h4>
              <p>Con LiveData/StateFlow, la UI se actualiza autom√°ticamente cuando cambian los datos, eliminando la necesidad de actualizar vistas manualmente.</p>
            </div>
          </div>
          
          <div class="advantage-item">
            <div class="advantage-icon">üß™</div>
            <div class="advantage-content">
              <h4>Testing Simplificado</h4>
              <p>ViewModel no tiene dependencias de Android Framework, permitiendo unit tests puros y r√°pidos sin necesidad de instrumentaci√≥n.</p>
            </div>
          </div>
        </div>

        <h2>üéØ Las Capas de MVVM: Anatom√≠a de la Arquitectura</h2>
        <p>MVVM divide nuestra aplicaci√≥n en <strong>tres capas principales</strong>, cada una con responsabilidades espec√≠ficas y bien definidas:</p>

        <div class="mvvm-layers-diagram">
          <div class="layer-card model">
            <div class="layer-header">
              <h3>üìä MODEL</h3>
              <span class="layer-subtitle">Capa de Datos</span>
            </div>
            <div class="layer-content">
              <h4>Responsabilidades:</h4>
              <ul>
                <li>Gesti√≥n de datos (local y remoto)</li>
                <li>L√≥gica de negocio pura</li>
                <li>Repositorios y fuentes de datos</li>
                <li>Entidades y modelos de dominio</li>
              </ul>
              <h4>Componentes t√≠picos:</h4>
              <ul>
                <li>Room Database</li>
                <li>Retrofit para APIs</li>
                <li>Repository implementations</li>
                <li>Use Cases/Interactors</li>
              </ul>
            </div>
          </div>

          <div class="layer-card view">
            <div class="layer-header">
              <h3>üëÅÔ∏è VIEW</h3>
              <span class="layer-subtitle">Capa de Presentaci√≥n</span>
            </div>
            <div class="layer-content">
              <h4>Responsabilidades:</h4>
              <ul>
                <li>Mostrar datos al usuario</li>
                <li>Capturar interacciones de usuario</li>
                <li>Delegar l√≥gica al ViewModel</li>
                <li>Observar cambios de estado</li>
              </ul>
              <h4>Componentes t√≠picos:</h4>
              <ul>
                <li>Activities & Fragments</li>
                <li>Jetpack Compose</li>
                <li>XML Layouts</li>
                <li>Adapters</li>
              </ul>
            </div>
          </div>

          <div class="layer-card viewmodel">
            <div class="layer-header">
              <h3>üé≠ VIEWMODEL</h3>
              <span class="layer-subtitle">Capa de L√≥gica de Presentaci√≥n</span>
            </div>
            <div class="layer-content">
              <h4>Responsabilidades:</h4>
              <ul>
                <li>L√≥gica de presentaci√≥n y estado de UI</li>
                <li>Comunicaci√≥n entre View y Model</li>
                <li>Transformaci√≥n de datos para la UI</li>
                <li>Manejo de eventos de usuario</li>
              </ul>
              <h4>Componentes t√≠picos:</h4>
              <ul>
                <li>ViewModel classes</li>
                <li>LiveData/StateFlow</li>
                <li>Event handlers</li>
                <li>UI State management</li>
              </ul>
            </div>
          </div>
        </div>

        <h2>üéÆ Implementando MVVM: Ejemplo con Buscaminas Android</h2>
        <p>Para demostrar MVVM en acci√≥n, vamos a construir un <strong>juego de Buscaminas</strong> desde cero. Este ejemplo te permitir√° ver c√≥mo cada capa interact√∫a en un escenario real.</p>

        <h3>üìä 1. Capa MODEL: Entidades y L√≥gica de Negocio</h3>
        <p>Empezamos definiendo nuestras entidades de dominio y la l√≥gica del juego:</p>

        <div class="code-block">
          <pre><code>// MinesweeperCell.kt - Entidad b√°sica
data class MinesweeperCell(
    val row: Int,
    val column: Int,
    val isMine: Boolean = false,
    val isRevealed: Boolean = false,
    val isFlagged: Boolean = false,
    val neighborMineCount: Int = 0
) {
    val displayValue: String
        get() = when {
            isFlagged -> "üö©"
            !isRevealed -> "‚¨ú"
            isMine -> "üí£"
            neighborMineCount > 0 -> neighborMineCount.toString()
            else -> "‚¨ú"
        }
}

// GameState.kt - Estados del juego
sealed class GameState {
    object Loading : GameState()
    object Playing : GameState()
    object Won : GameState()
    data class Lost(val explodedCell: MinesweeperCell) : GameState()
}

// GameDifficulty.kt - Niveles de dificultad
enum class GameDifficulty(
    val rows: Int,
    val columns: Int,
    val mineCount: Int,
    val displayName: String
) {
    BEGINNER(9, 9, 10, "Principiante"),
    INTERMEDIATE(16, 16, 40, "Intermedio"),
    EXPERT(16, 30, 99, "Experto")
}</code></pre>
        </div>

        <h3>üèóÔ∏è 2. Repository Pattern: Gesti√≥n de Datos</h3>
        <p>El Repository act√∫a como una <strong>√∫nica fuente de verdad</strong> para nuestros datos, abstrayendo la l√≥gica de persistencia:</p>

        <div class="code-block">
          <pre><code>// MinesweeperRepository.kt
interface MinesweeperRepository {
    suspend fun generateBoard(difficulty: GameDifficulty): List&lt;List&lt;MinesweeperCell&gt;&gt;
    suspend fun saveGame(gameId: String, board: List&lt;List&lt;MinesweeperCell&gt;&gt;, state: GameState)
    suspend fun loadGame(gameId: String): GameData?
    suspend fun getGameStatistics(): GameStatistics
    suspend fun updateStatistics(result: GameResult)
}

class MinesweeperRepositoryImpl @Inject constructor(
    private val localDataSource: MinesweeperLocalDataSource,
    private val gameGenerator: GameGenerator
) : MinesweeperRepository {
    
    override suspend fun generateBoard(difficulty: GameDifficulty): List&lt;List&lt;MinesweeperCell&gt;&gt; {
        return gameGenerator.generateBoard(
            rows = difficulty.rows,
            columns = difficulty.columns,
            mineCount = difficulty.mineCount
        )
    }
    
    override suspend fun saveGame(
        gameId: String, 
        board: List&lt;List&lt;MinesweeperCell&gt;&gt;, 
        state: GameState
    ) {
        val gameData = GameData(
            id = gameId,
            board = board,
            state = state,
            timestamp = System.currentTimeMillis()
        )
        localDataSource.saveGame(gameData)
    }
    
    override suspend fun loadGame(gameId: String): GameData? {
        return localDataSource.getGame(gameId)
    }
    
    override suspend fun getGameStatistics(): GameStatistics {
        return localDataSource.getStatistics()
    }
    
    override suspend fun updateStatistics(result: GameResult) {
        localDataSource.updateStatistics(result)
    }
}</code></pre>
        </div>

        <h3>üéØ 3. Use Cases: L√≥gica de Negocio Espec√≠fica</h3>
        <p>Los Use Cases encapsulan la <strong>l√≥gica de negocio espec√≠fica</strong> de cada acci√≥n del usuario:</p>

        <div class="code-block">
          <pre><code>// RevealCellUseCase.kt - L√≥gica para revelar una celda
class RevealCellUseCase @Inject constructor() {
    
    operator fun invoke(
        board: List&lt;List&lt;MinesweeperCell&gt;&gt;,
        row: Int,
        column: Int
    ): RevealResult {
        val cell = board[row][column]
        
        // No se puede revelar una celda ya marcada o revelada
        if (cell.isFlagged || cell.isRevealed) {
            return RevealResult.Invalid
        }
        
        // Si es una mina, el juego termina
        if (cell.isMine) {
            return RevealResult.GameLost(cell)
        }
        
        // Revelar la celda y posiblemente celdas vecinas
        val updatedBoard = revealCell(board, row, column)
        
        // Verificar si el juego se gan√≥
        val isGameWon = checkWinCondition(updatedBoard)
        
        return RevealResult.Success(
            updatedBoard = updatedBoard,
            isGameWon = isGameWon
        )
    }
    
    private fun revealCell(
        board: List&lt;List&lt;MinesweeperCell&gt;&gt;,
        row: Int,
        column: Int
    ): List&lt;List&lt;MinesweeperCell&gt;&gt; {
        val mutableBoard = board.map { it.toMutableList() }.toMutableList()
        
        // Algoritmo de flood-fill para revelar celdas vac√≠as conectadas
        fun floodFill(r: Int, c: Int) {
            if (r !in 0 until board.size || c !in 0 until board[0].size) return
            if (mutableBoard[r][c].isRevealed || mutableBoard[r][c].isMine) return
            
            mutableBoard[r][c] = mutableBoard[r][c].copy(isRevealed = true)
            
            // Si no hay minas vecinas, revelar celdas adyacentes
            if (mutableBoard[r][c].neighborMineCount == 0) {
                for (dr in -1..1) {
                    for (dc in -1..1) {
                        if (dr != 0 || dc != 0) {
                            floodFill(r + dr, c + dc)
                        }
                    }
                }
            }
        }
        
        floodFill(row, column)
        return mutableBoard
    }
    
    private fun checkWinCondition(board: List&lt;List&lt;MinesweeperCell&gt;&gt;): Boolean {
        return board.flatten().all { cell ->
            cell.isMine || cell.isRevealed
        }
    }
}

// ToggleFlagUseCase.kt - L√≥gica para marcar/desmarcar celdas
class ToggleFlagUseCase @Inject constructor() {
    
    operator fun invoke(
        board: List&lt;List&lt;MinesweeperCell&gt;&gt;,
        row: Int,
        column: Int
    ): List&lt;List&lt;MinesweeperCell&gt;&gt; {
        return board.mapIndexed { r, rowCells ->
            rowCells.mapIndexed { c, cell ->
                if (r == row && c == column && !cell.isRevealed) {
                    cell.copy(isFlagged = !cell.isFlagged)
                } else {
                    cell
                }
            }
        }
    }
}</code></pre>
        </div>

        <h3>üé≠ 4. ViewModel: El Coraz√≥n de MVVM</h3>
        <p>El ViewModel orquesta toda la l√≥gica de presentaci√≥n y mantiene el estado de la UI:</p>

        <div class="code-block">
          <pre><code>// MinesweeperViewModel.kt
@HiltViewModel
class MinesweeperViewModel @Inject constructor(
    private val repository: MinesweeperRepository,
    private val revealCellUseCase: RevealCellUseCase,
    private val toggleFlagUseCase: ToggleFlagUseCase
) : ViewModel() {
    
    // Estado privado mutable
    private val _uiState = MutableStateFlow(MinesweeperUiState())
    val uiState: StateFlow&lt;MinesweeperUiState&gt; = _uiState.asStateFlow()
    
    private val _gameState = MutableLiveData&lt;GameState&gt;(GameState.Loading)
    val gameState: LiveData&lt;GameState&gt; = _gameState
    
    private val _board = MutableLiveData&lt;List&lt;List&lt;MinesweeperCell&gt;&gt;&gt;()
    val board: LiveData&lt;List&lt;List&lt;MinesweeperCell&gt;&gt;&gt; = _board
    
    private val _elapsedTime = MutableLiveData&lt;Long&gt;(0L)
    val elapsedTime: LiveData&lt;Long&gt; = _elapsedTime
    
    private val _minesRemaining = MutableLiveData&lt;Int&gt;()
    val minesRemaining: LiveData&lt;Int&gt; = _minesRemaining
    
    private var gameTimer: Job? = null
    private var startTime: Long = 0L
    
    fun startNewGame(difficulty: GameDifficulty) {
        viewModelScope.launch {
            try {
                _gameState.value = GameState.Loading
                
                val newBoard = repository.generateBoard(difficulty)
                _board.value = newBoard
                _gameState.value = GameState.Playing
                _minesRemaining.value = difficulty.mineCount
                
                startTimer()
                
                // Actualizar UI state
                _uiState.value = _uiState.value.copy(
                    difficulty = difficulty,
                    isLoading = false,
                    error = null
                )
                
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isLoading = false,
                    error = "Error al generar el juego: ${e.message}"
                )
            }
        }
    }
    
    fun onCellClick(row: Int, column: Int) {
        if (_gameState.value != GameState.Playing) return
        
        viewModelScope.launch {
            val currentBoard = _board.value ?: return@launch
            
            when (val result = revealCellUseCase(currentBoard, row, column)) {
                is RevealResult.Success -> {
                    _board.value = result.updatedBoard
                    
                    if (result.isGameWon) {
                        _gameState.value = GameState.Won
                        stopTimer()
                        saveGameResult(GameResult.Won(_elapsedTime.value ?: 0L))
                    }
                }
                
                is RevealResult.GameLost -> {
                    _gameState.value = GameState.Lost(result.explodedCell)
                    stopTimer()
                    saveGameResult(GameResult.Lost(_elapsedTime.value ?: 0L))
                }
                
                RevealResult.Invalid -> {
                    // No hacer nada si la acci√≥n es inv√°lida
                }
            }
        }
    }
    
    fun onCellLongClick(row: Int, column: Int) {
        if (_gameState.value != GameState.Playing) return
        
        val currentBoard = _board.value ?: return
        val updatedBoard = toggleFlagUseCase(currentBoard, row, column)
        
        _board.value = updatedBoard
        updateMinesRemaining(updatedBoard)
    }
    
    private fun startTimer() {
        startTime = System.currentTimeMillis()
        gameTimer?.cancel()
        
        gameTimer = viewModelScope.launch {
            while (_gameState.value == GameState.Playing) {
                _elapsedTime.value = (System.currentTimeMillis() - startTime) / 1000
                delay(1000)
            }
        }
    }
    
    private fun stopTimer() {
        gameTimer?.cancel()
        gameTimer = null
    }
    
    private fun updateMinesRemaining(board: List&lt;List&lt;MinesweeperCell&gt;&gt;) {
        val flaggedCount = board.flatten().count { it.isFlagged }
        val currentDifficulty = _uiState.value.difficulty
        _minesRemaining.value = currentDifficulty.mineCount - flaggedCount
    }
    
    private suspend fun saveGameResult(result: GameResult) {
        try {
            repository.updateStatistics(result)
        } catch (e: Exception) {
            // Log error but don't show to user - statistics are not critical
        }
    }
    
    override fun onCleared() {
        super.onCleared()
        stopTimer()
    }
}</code></pre>
        </div>

        <h3>üëÅÔ∏è 5. VIEW: La Interfaz de Usuario</h3>
        <p>Finalmente, la View observa el ViewModel y reacciona a los cambios de estado:</p>

        <div class="code-block">
          <pre><code>// MinesweeperFragment.kt - Implementaci√≥n con View Binding
@AndroidEntryPoint
class MinesweeperFragment : Fragment() {
    
    private var _binding: FragmentMinesweeperBinding? = null
    private val binding get() = _binding!!
    
    private val viewModel: MinesweeperViewModel by viewModels()
    private lateinit var boardAdapter: MinesweeperBoardAdapter
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentMinesweeperBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        
        setupUI()
        setupObservers()
        
        // Iniciar juego por defecto
        viewModel.startNewGame(GameDifficulty.BEGINNER)
    }
    
    private fun setupUI() {
        // Configurar RecyclerView para el tablero
        boardAdapter = MinesweeperBoardAdapter(
            onCellClick = { row, column ->
                viewModel.onCellClick(row, column)
            },
            onCellLongClick = { row, column ->
                viewModel.onCellLongClick(row, column)
                true // Consumir el evento
            }
        )
        
        binding.recyclerViewBoard.apply {
            adapter = boardAdapter
            layoutManager = GridLayoutManager(context, GameDifficulty.BEGINNER.columns)
        }
        
        // Configurar botones de dificultad
        binding.buttonBeginner.setOnClickListener {
            viewModel.startNewGame(GameDifficulty.BEGINNER)
        }
        
        binding.buttonIntermediate.setOnClickListener {
            viewModel.startNewGame(GameDifficulty.INTERMEDIATE)
        }
        
        binding.buttonExpert.setOnClickListener {
            viewModel.startNewGame(GameDifficulty.EXPERT)
        }
    }
    
    private fun setupObservers() {
        // Observar estado del juego
        viewModel.gameState.observe(viewLifecycleOwner) { gameState ->
            updateGameStateUI(gameState)
        }
        
        // Observar tablero de juego
        viewModel.board.observe(viewLifecycleOwner) { board ->
            boardAdapter.updateBoard(board)
        }
        
        // Observar tiempo transcurrido
        viewModel.elapsedTime.observe(viewLifecycleOwner) { elapsedTime ->
            binding.textViewTimer.text = formatTime(elapsedTime)
        }
        
        // Observar minas restantes
        viewModel.minesRemaining.observe(viewLifecycleOwner) { minesRemaining ->
            binding.textViewMineCount.text = "üí£ $minesRemaining"
        }
        
        // Observar estado de UI con StateFlow
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collect { uiState ->
                updateUiState(uiState)
            }
        }
    }
    
    private fun updateGameStateUI(gameState: GameState) {
        when (gameState) {
            GameState.Loading -> {
                binding.progressBar.isVisible = true
                binding.textViewGameStatus.text = "Generando juego..."
            }
            
            GameState.Playing -> {
                binding.progressBar.isVisible = false
                binding.textViewGameStatus.text = "üéÆ Jugando"
            }
            
            GameState.Won -> {
                binding.textViewGameStatus.text = "üéâ ¬°Ganaste!"
                showVictoryDialog()
            }
            
            is GameState.Lost -> {
                binding.textViewGameStatus.text = "üí• ¬°Perdiste!"
                showGameOverDialog()
            }
        }
    }
    
    private fun showVictoryDialog() {
        MaterialAlertDialogBuilder(requireContext())
            .setTitle("üéâ ¬°Felicitaciones!")
            .setMessage("Has ganado el juego")
            .setPositiveButton("Jugar de nuevo") { _, _ ->
                val currentDifficulty = viewModel.uiState.value.difficulty
                viewModel.startNewGame(currentDifficulty)
            }
            .show()
    }
}</code></pre>
        </div>

        <h2>üß™ Testing en Arquitectura MVVM</h2>
        <p>Una de las mayores ventajas de MVVM es la <strong>facilidad para testing</strong>. Cada capa puede probarse independientemente:</p>

        <div class="code-block">
          <pre><code>// MinesweeperViewModelTest.kt
@ExtendWith(MockitoExtension::class)
class MinesweeperViewModelTest {
    
    @Mock
    private lateinit var repository: MinesweeperRepository
    
    @Mock
    private lateinit var revealCellUseCase: RevealCellUseCase
    
    @Mock
    private lateinit var toggleFlagUseCase: ToggleFlagUseCase
    
    private lateinit var viewModel: MinesweeperViewModel
    
    @BeforeEach
    fun setup() {
        viewModel = MinesweeperViewModel(repository, revealCellUseCase, toggleFlagUseCase)
    }
    
    @Test
    fun `startNewGame should update state to playing when successful`() = runTest {
        // Given
        val difficulty = GameDifficulty.BEGINNER
        val mockBoard = createMockBoard(difficulty)
        `when`(repository.generateBoard(difficulty)).thenReturn(mockBoard)
        
        // When
        viewModel.startNewGame(difficulty)
        
        // Then
        assertEquals(GameState.Playing, viewModel.gameState.value)
        assertEquals(mockBoard, viewModel.board.value)
        assertEquals(difficulty.mineCount, viewModel.minesRemaining.value)
    }
    
    @Test
    fun `onCellClick should update game state to won when winning condition met`() = runTest {
        // Given
        val mockBoard = createMockBoard(GameDifficulty.BEGINNER)
        val winningBoard = createWinningBoard()
        
        `when`(revealCellUseCase(mockBoard, 0, 0))
            .thenReturn(RevealResult.Success(winningBoard, true))
        
        viewModel.startNewGame(GameDifficulty.BEGINNER)
        
        // When
        viewModel.onCellClick(0, 0)
        
        // Then
        assertEquals(GameState.Won, viewModel.gameState.value)
        assertEquals(winningBoard, viewModel.board.value)
    }
}</code></pre>
        </div>

        <h2>üîß Herramientas y Tecnolog√≠as Complementarias</h2>
        <p>Para implementar MVVM efectivamente en Android, estas son las herramientas esenciales:</p>

        <div class="tools-grid">
          <div class="tool-card">
            <h4>üèóÔ∏è Architecture Components</h4>
            <p>ViewModel, LiveData, Room, Navigation Component para implementar MVVM nativamente</p>
            <div class="code-snippet">
              <code>implementation "androidx.lifecycle:lifecycle-viewmodel-ktx"</code>
            </div>
          </div>
          
          <div class="tool-card">
            <h4>üíâ Hilt Dependency Injection</h4>
            <p>Para gestionar dependencias autom√°ticamente y facilitar testing</p>
            <div class="code-snippet">
              <code>@HiltViewModel<br>class MyViewModel @Inject constructor()</code>
            </div>
          </div>
          
          <div class="tool-card">
            <h4>üåä Kotlin Coroutines + Flow</h4>
            <p>Para manejo as√≠ncrono moderno y programaci√≥n reactiva</p>
            <div class="code-snippet">
              <code>StateFlow<br>suspend fun<br>viewModelScope</code>
            </div>
          </div>
          
          <div class="tool-card">
            <h4>üß™ Testing Libraries</h4>
            <p>JUnit, Mockito, y Testing coroutines para unit tests efectivos</p>
            <div class="code-snippet">
              <code>runTest { }<br>MockitoExtension<br>InstantTaskExecutorRule</code>
            </div>
          </div>
        </div>

        <h2>‚ö†Ô∏è Errores Comunes en MVVM y C√≥mo Evitarlos</h2>

        <div class="warning-box">
          <h3>üö´ Antipatrones frecuentes</h3>
          <div class="antipattern-grid">
            <div class="antipattern-item">
              <h4>‚ùå ViewModel con Context</h4>
              <p>Nunca pases Context al ViewModel - rompe la separaci√≥n de capas y causa memory leaks</p>
              <div class="code-snippet error">
                <code>// ‚ùå MAL
class MyViewModel(private val context: Context)</code>
              </div>
              <div class="code-snippet success">
                <code>// ‚úÖ BIEN
class MyViewModel @Inject constructor(
    private val repository: Repository
)</code>
              </div>
            </div>
            
            <div class="antipattern-item">
              <h4>‚ùå L√≥gica de negocio en el View</h4>
              <p>La View debe ser pasiva, toda la l√≥gica debe estar en ViewModel o UseCase</p>
              <div class="code-snippet error">
                <code>// ‚ùå MAL - l√≥gica en Fragment
if (user.age >= 18 && user.hasLicense) {
    showDriveButton()
}</code>
              </div>
              <div class="code-snippet success">
                <code>// ‚úÖ BIEN - l√≥gica en ViewModel
viewModel.canUserDrive.observe { canDrive ->
    driveButton.isVisible = canDrive
}</code>
              </div>
            </div>
          </div>
        </div>

        <h2>üéØ Mejores Pr√°cticas para MVVM en Android</h2>

        <div class="best-practices-box">
          <h3>üí° Recomendaciones clave</h3>
          <ul>
            <li><strong>Un ViewModel por pantalla:</strong> Mant√©n ViewModels focalizados en una responsabilidad espec√≠fica</li>
            <li><strong>USA StateFlow sobre LiveData:</strong> Para nuevos proyectos, StateFlow ofrece mejor integraci√≥n con Compose</li>
            <li><strong>Encapsula el estado:</strong> Exp√≥n solo observables inmutables desde el ViewModel</li>
            <li><strong>Naming consistency:</strong> Usa convenciones claras para tus propiedades (_private, public)</li>
            <li><strong>Handle loading states:</strong> Siempre maneja estados de carga, error y √©xito</li>
            <li><strong>Test your ViewModels:</strong> Son f√°ciles de testear, aprov√©chalo</li>
          </ul>
        </div>

        <h2>üöÄ Pr√≥ximos Pasos y Conclusiones</h2>
        <p>MVVM no es solo un patr√≥n arquitect√≥nico, es una <strong>filosof√≠a de desarrollo</strong> que promueve c√≥digo limpio, testeable y mantenible. En nuestro ejemplo del Buscaminas hemos visto c√≥mo:</p>

        <ul>
          <li>üéØ <strong>Separar responsabilidades</strong> hace el c√≥digo m√°s predecible</li>
          <li>üß™ <strong>Testing se simplifica</strong> enormemente con capas bien definidas</li>
          <li>üîÑ <strong>Data binding autom√°tico</strong> reduce bugs de sincronizaci√≥n</li>
          <li>‚ö° <strong>Estado sobrevive rotaciones</strong> sin esfuerzo adicional</li>
          <li>üë• <strong>Equipos pueden trabajar en paralelo</strong> en diferentes capas</li>
        </ul>

        <div class="next-steps-box">
          <h3>üöÄ Pr√≥ximos pasos recomendados</h3>
          <ol>
            <li>Implementa un proyecto peque√±o siguiendo el ejemplo del Buscaminas</li>
            <li>A√±ade Hilt para inyecci√≥n de dependencias autom√°tica</li>
            <li>Integra Room Database para persistencia local</li>
            <li>Experimenta con Jetpack Compose + ViewModel</li>
            <li>Escribe tests unitarios para tus ViewModels</li>
            <li>Explora patrones avanzados como Clean Architecture</li>
          </ol>
        </div>

        <p>Recuerda: <strong>MVVM no es una soluci√≥n m√°gica</strong>, pero aplicado correctamente puede transformar radicalmente la calidad y mantenibilidad de tus aplicaciones Android. ¬°Empieza peque√±o, aprende los fundamentos, y construye hacia arriba! üöÄ</p>

        <div class="article-footer">
          <div class="tags">
            <span class="tag">Android</span>
            <span class="tag">Kotlin</span>
            <span class="tag">MVVM</span>
            <span class="tag">Architecture</span>
            <span class="tag">ViewModel</span>
            <span class="tag">LiveData</span>
            <span class="tag">Repository Pattern</span>
            <span class="tag">Use Cases</span>
            <span class="tag">Clean Code</span>
            <span class="tag">Testing</span>
          </div>
          
          <div class="article-navigation">
            <a href="blog-solid-principles.html" class="prev-article">
              ‚Üê Principios SOLID en Android
            </a>
            <a href="blog-kotlin-coroutines.html" class="next-article">
              Kotlin Coroutines ‚Üí
            </a>
          </div>
        </div>
      </div>
    </div>
  </article>

  <!-- Footer -->
  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-text">
          <p>&copy; 2025 ArceApps. Desarrollado con HTML, CSS y JavaScript.</p>
        </div>
        <div class="footer-links">
          <a href="#" class="footer-link">GitHub</a>
          <a href="#" class="footer-link">LinkedIn</a>
          <a href="#" class="footer-link">Contacto</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="../script.js"></script>
</body>
</html>