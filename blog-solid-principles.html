<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Principios SOLID en Android con Kotlin - ArceApps Blog</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <!-- Navigation -->
  <nav class="navbar">
    <div class="nav-container">
      <div class="nav-logo">
        <h3><a href="index.html">ArceApps</a></h3>
      </div>
      <ul class="nav-menu">
        <li class="nav-item">
          <a href="index.html" class="nav-link">Inicio</a>
        </li>
        <li class="nav-item">
          <a href="portfolio.html" class="nav-link">Portfolio</a>
        </li>
        <li class="nav-item">
          <a href="blog.html" class="nav-link active">Blog</a>
        </li>
      </ul>
    </div>
  </nav>

  <article class="blog-article">
    <div class="container">
      <header class="article-header">
        <div class="article-meta">
          <span class="article-date">28 de agosto de 2025</span>
          <span class="article-category">Desarrollo Android</span>
        </div>
        <h1>Principios SOLID en Android: Gu√≠a Pr√°ctica con Kotlin</h1>
        <p class="article-subtitle">Domina los 5 principios fundamentales de la programaci√≥n orientada a objetos aplicados al desarrollo Android con ejemplos pr√°cticos en Kotlin</p>
        <div class="article-image">
          <img src="https://via.placeholder.com/800x400/10b981/ffffff?text=SOLID+Principles+Android" alt="Principios SOLID Android" />
        </div>
      </header>

      <div class="article-content">
        <h2>¬øQu√© son los Principios SOLID?</h2>
        <p>Los principios SOLID son cinco reglas fundamentales de la programaci√≥n orientada a objetos que nos ayudan a escribir c√≥digo m√°s mantenible, flexible y robusto. Fueron formulados por Robert C. Martin (Uncle Bob) y son especialmente valiosos en el desarrollo Android, donde la complejidad del c√≥digo puede crecer r√°pidamente.</p>

        <p>En Android, aplicar estos principios nos permite crear aplicaciones m√°s escalables, facilita las pruebas unitarias y hace que nuestro c√≥digo sea m√°s f√°cil de entender y modificar. ¬°Vamos a explorar cada uno con ejemplos pr√°cticos en Kotlin! üöÄ</p>

        <div class="solid-overview">
          <h3>Los 5 Principios SOLID</h3>
          <div class="principles-grid">
            <div class="principle-card">
              <h4><strong>S</strong> - Single Responsibility</h4>
              <p>Una clase debe tener una sola raz√≥n para cambiar</p>
            </div>
            <div class="principle-card">
              <h4><strong>O</strong> - Open/Closed</h4>
              <p>Abierto para extensi√≥n, cerrado para modificaci√≥n</p>
            </div>
            <div class="principle-card">
              <h4><strong>L</strong> - Liskov Substitution</h4>
              <p>Los objetos deben ser reemplazables por instancias de sus subtipos</p>
            </div>
            <div class="principle-card">
              <h4><strong>I</strong> - Interface Segregation</h4>
              <p>Los clientes no deben depender de interfaces que no usan</p>
            </div>
            <div class="principle-card">
              <h4><strong>D</strong> - Dependency Inversion</h4>
              <p>Depende de abstracciones, no de concreciones</p>
            </div>
          </div>
        </div>

        <h2>1. Single Responsibility Principle (SRP)</h2>
        <p>El principio de responsabilidad √∫nica establece que <strong>una clase debe tener una sola raz√≥n para cambiar</strong>. En otras palabras, cada clase debe tener una √∫nica responsabilidad o prop√≥sito bien definido.</p>

        <h3>‚ùå Ejemplo Incorrecto</h3>
        <p>Imagina una Activity que maneja tanto la UI como la l√≥gica de negocio:</p>

        <div class="code-block">
          <pre><code>// ‚ùå MALO: M√∫ltiples responsabilidades
class UserProfileActivity : AppCompatActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_user_profile)
        
        // Responsabilidad 1: Configurar UI
        setupViews()
        
        // Responsabilidad 2: Validar datos
        validateUserInput()
        
        // Responsabilidad 3: Comunicaci√≥n con API
        fetchUserData()
        
        // Responsabilidad 4: Guardar en base de datos
        saveToDatabase()
    }
    
    private fun validateUserInput() {
        // L√≥gica de validaci√≥n compleja...
    }
    
    private fun fetchUserData() {
        // Llamadas a la API...
    }
    
    private fun saveToDatabase() {
        // Operaciones de base de datos...
    }
}</code></pre>
        </div>

        <h3>‚úÖ Ejemplo Correcto</h3>
        <p>Separemos las responsabilidades en clases especializadas:</p>

        <div class="code-block">
          <pre><code>// ‚úÖ BUENO: Una sola responsabilidad por clase
class UserProfileActivity : AppCompatActivity() {
    
    private lateinit var validator: UserInputValidator
    private lateinit var apiService: UserApiService
    private lateinit var repository: UserRepository
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_user_profile)
        
        // Solo se encarga de la UI
        setupViews()
        setupClickListeners()
    }
}

// Responsabilidad √∫nica: Validaci√≥n
class UserInputValidator {
    fun validateEmail(email: String): Boolean {
        return email.contains("@") && email.length > 5
    }
    
    fun validatePassword(password: String): Boolean {
        return password.length >= 8
    }
}

// Responsabilidad √∫nica: Comunicaci√≥n con API
class UserApiService {
    suspend fun fetchUserProfile(userId: String): User {
        // L√≥gica de API
    }
}

// Responsabilidad √∫nica: Persistencia de datos
class UserRepository {
    suspend fun saveUser(user: User) {
        // Operaciones de base de datos
    }
}</code></pre>
        </div>

        <div class="best-practices-box">
          <h3>üí° Beneficios del SRP en Android</h3>
          <ul>
            <li><strong>Testing m√°s f√°cil:</strong> Cada clase tiene un prop√≥sito espec√≠fico para probar</li>
            <li><strong>Reutilizaci√≥n:</strong> Las clases especializadas se pueden usar en otras partes</li>
            <li><strong>Mantenimiento:</strong> Los cambios en validaci√≥n no afectan la UI</li>
            <li><strong>Legibilidad:</strong> El c√≥digo es m√°s f√°cil de entender</li>
          </ul>
        </div>

        <h2>2. Open/Closed Principle (OCP)</h2>
        <p>Este principio establece que las clases deben estar <strong>abiertas para extensi√≥n pero cerradas para modificaci√≥n</strong>. Podemos a√±adir nueva funcionalidad sin modificar el c√≥digo existente.</p>

        <h3>‚ùå Ejemplo Incorrecto</h3>
        <p>Un sistema de notificaciones que requiere modificar c√≥digo para cada nuevo tipo:</p>

        <div class="code-block">
          <pre><code>// ‚ùå MALO: Necesita modificaci√≥n para extensi√≥n
class NotificationManager {
    
    fun sendNotification(type: String, message: String) {
        when (type) {
            "EMAIL" -> sendEmail(message)
            "SMS" -> sendSMS(message)
            "PUSH" -> sendPushNotification(message)
            // ¬øQu√© pasa si quiero a√±adir WhatsApp? 
            // Tengo que modificar esta funci√≥n!
        }
    }
    
    private fun sendEmail(message: String) { /* ... */ }
    private fun sendSMS(message: String) { /* ... */ }
    private fun sendPushNotification(message: String) { /* ... */ }
}</code></pre>
        </div>

        <h3>‚úÖ Ejemplo Correcto</h3>
        <p>Usando interfaces y polimorfismo para permitir extensi√≥n sin modificaci√≥n:</p>

        <div class="code-block">
          <pre><code>// ‚úÖ BUENO: Abierto para extensi√≥n, cerrado para modificaci√≥n
interface NotificationSender {
    fun send(message: String)
}

class EmailNotificationSender : NotificationSender {
    override fun send(message: String) {
        // Enviar email
        println("Enviando email: $message")
    }
}

class SMSNotificationSender : NotificationSender {
    override fun send(message: String) {
        // Enviar SMS
        println("Enviando SMS: $message")
    }
}

class PushNotificationSender : NotificationSender {
    override fun send(message: String) {
        // Enviar push notification
        NotificationManagerCompat.from(context)
            .notify(1, buildNotification(message))
    }
}

// Extensi√≥n sin modificaci√≥n: Nuevo tipo de notificaci√≥n
class WhatsAppNotificationSender : NotificationSender {
    override fun send(message: String) {
        // Nueva funcionalidad sin tocar c√≥digo existente!
        println("Enviando por WhatsApp: $message")
    }
}

class NotificationManager {
    private val senders = mutableListOf&lt;NotificationSender&gt;()
    
    fun addSender(sender: NotificationSender) {
        senders.add(sender)
    }
    
    fun sendToAll(message: String) {
        senders.forEach { it.send(message) }
    }
}</code></pre>
        </div>

        <h3>Uso pr√°ctico en Android con Extension Functions</h3>
        <div class="code-block">
          <pre><code>// Extensiones de Kotlin para el OCP
fun ImageView.loadUrl(url: String) {
    Glide.with(this)
        .load(url)
        .into(this)
}

// Extensi√≥n adicional sin modificar la anterior
fun ImageView.loadUrlWithPlaceholder(url: String, placeholder: Int) {
    Glide.with(this)
        .load(url)
        .placeholder(placeholder)
        .into(this)
}

// Uso en Activities/Fragments
imageView.loadUrl("https://example.com/image.jpg")
avatarImage.loadUrlWithPlaceholder(user.avatarUrl, R.drawable.default_avatar)</code></pre>
        </div>

        <h2>3. Liskov Substitution Principle (LSP)</h2>
        <p>El principio de sustituci√≥n de Liskov dice que <strong>los objetos de una clase derivada deben poder reemplazar los objetos de la clase base sin alterar la funcionalidad del programa</strong>.</p>

        <h3>‚ùå Ejemplo Incorrecto</h3>
        <p>Una jerarqu√≠a de vistas que viola LSP:</p>

        <div class="code-block">
          <pre><code>// ‚ùå MALO: Viola el LSP
open class Button {
    open fun onClick() {
        // Comportamiento est√°ndar del bot√≥n
        performHapticFeedback()
        executeAction()
    }
    
    open fun executeAction() {
        // Acci√≥n por defecto
    }
}

class SubmitButton : Button() {
    override fun onClick() {
        // Comportamiento completamente diferente!
        if (validateForm()) {
            super.onClick()
        } else {
            // ¬°No ejecuta la acci√≥n base! Viola LSP
            showError()
            return // No llama a executeAction()
        }
    }
}

// Problema: No podemos sustituir Button por SubmitButton
// sin cambiar el comportamiento esperado</code></pre>
        </div>

        <h3>‚úÖ Ejemplo Correcto</h3>
        <p>Respetando el contrato de la clase base:</p>

        <div class="code-block">
          <pre><code>// ‚úÖ BUENO: Respeta el LSP
abstract class BaseButton {
    fun onClick() {
        performHapticFeedback()
        if (canExecuteAction()) {
            executeAction()
        }
    }
    
    protected abstract fun canExecuteAction(): Boolean
    protected abstract fun executeAction()
    
    private fun performHapticFeedback() {
        // Feedback h√°ptico est√°ndar
    }
}

class StandardButton : BaseButton() {
    override fun canExecuteAction(): Boolean = true
    
    override fun executeAction() {
        // Acci√≥n est√°ndar del bot√≥n
        navigateToNextScreen()
    }
}

class SubmitButton(
    private val validator: FormValidator
) : BaseButton() {
    
    override fun canExecuteAction(): Boolean {
        return validator.isFormValid()
    }
    
    override fun executeAction() {
        // Mantiene el contrato: siempre ejecuta una acci√≥n
        submitForm()
    }
}

// Ahora podemos sustituir cualquier BaseButton
// sin romper el comportamiento esperado
fun setupButtons(buttons: List&lt;BaseButton&gt;) {
    buttons.forEach { button ->
        button.onClick() // Funciona correctamente para todos
    }
}</code></pre>
        </div>

        <h3>Aplicaci√≥n en Architecture Components</h3>
        <div class="code-block">
          <pre><code>// LSP en ViewModels
abstract class BaseViewModel : ViewModel() {
    protected val _loading = MutableLiveData&lt;Boolean&gt;()
    val loading: LiveData&lt;Boolean&gt; = _loading
    
    protected val _error = MutableLiveData&lt;String&gt;()
    val error: LiveData&lt;String&gt; = _error
    
    abstract fun loadData()
}

class UserViewModel(
    private val repository: UserRepository
) : BaseViewModel() {
    
    private val _users = MutableLiveData&lt;List&lt;User&gt;&gt;()
    val users: LiveData&lt;List&lt;User&gt;&gt; = _users
    
    override fun loadData() {
        _loading.value = true
        viewModelScope.launch {
            try {
                _users.value = repository.getUsers()
            } catch (e: Exception) {
                _error.value = e.message
            } finally {
                _loading.value = false
            }
        }
    }
}

// Cualquier BaseViewModel puede ser sustituido
class MainActivity : AppCompatActivity() {
    fun setupViewModel(viewModel: BaseViewModel) {
        viewModel.loading.observe(this) { isLoading ->
            progressBar.isVisible = isLoading
        }
        
        viewModel.loadData() // Funciona para cualquier implementaci√≥n
    }
}</code></pre>
        </div>

        <h2>4. Interface Segregation Principle (ISP)</h2>
        <p>El principio de segregaci√≥n de interfaces establece que <strong>los clientes no deben ser forzados a depender de interfaces que no usan</strong>. Es mejor tener interfaces peque√±as y espec√≠ficas que una grande y monol√≠tica.</p>

        <h3>‚ùå Ejemplo Incorrecto</h3>
        <p>Una interfaz "todoterreno" que fuerza implementaciones innecesarias:</p>

        <div class="code-block">
          <pre><code>// ‚ùå MALO: Interfaz muy grande (Fat Interface)
interface MediaPlayer {
    fun play()
    fun pause()
    fun stop()
    fun next()
    fun previous()
    fun shuffle()
    fun repeat()
    fun addToPlaylist()
    fun createPlaylist()
    fun shareTrack()
    fun downloadTrack()
    fun setEqualizer()
    fun recordAudio()
}

// Problema: Un simple reproductor de sonidos de notificaci√≥n
// debe implementar m√©todos que no necesita
class NotificationSoundPlayer : MediaPlayer {
    override fun play() { /* OK, necesario */ }
    override fun pause() { /* OK, necesario */ }
    override fun stop() { /* OK, necesario */ }
    
    // ¬°M√©todos innecesarios que debe implementar!
    override fun next() { throw UnsupportedOperationException() }
    override fun previous() { throw UnsupportedOperationException() }
    override fun shuffle() { throw UnsupportedOperationException() }
    override fun repeat() { throw UnsupportedOperationException() }
    override fun addToPlaylist() { throw UnsupportedOperationException() }
    override fun createPlaylist() { throw UnsupportedOperationException() }
    override fun shareTrack() { throw UnsupportedOperationException() }
    override fun downloadTrack() { throw UnsupportedOperationException() }
    override fun setEqualizer() { throw UnsupportedOperationException() }
    override fun recordAudio() { throw UnsupportedOperationException() }
}</code></pre>
        </div>

        <h3>‚úÖ Ejemplo Correcto</h3>
        <p>Separemos la interfaz en interfaces m√°s peque√±as y espec√≠ficas:</p>

        <div class="code-block">
          <pre><code>// ‚úÖ BUENO: Interfaces segregadas y espec√≠ficas
interface BasicMediaPlayer {
    fun play()
    fun pause()
    fun stop()
}

interface PlaylistController {
    fun next()
    fun previous()
    fun shuffle()
    fun repeat()
}

interface PlaylistManager {
    fun addToPlaylist()
    fun createPlaylist()
}

interface MediaSharing {
    fun shareTrack()
    fun downloadTrack()
}

interface AudioProcessor {
    fun setEqualizer()
    fun recordAudio()
}

// Ahora cada clase implementa solo lo que necesita
class NotificationSoundPlayer : BasicMediaPlayer {
    override fun play() { /* Reproducir sonido */ }
    override fun pause() { /* Pausar sonido */ }
    override fun stop() { /* Parar sonido */ }
}

class FullMusicPlayer : BasicMediaPlayer, PlaylistController, MediaSharing {
    override fun play() { /* Implementaci√≥n completa */ }
    override fun pause() { /* Implementaci√≥n completa */ }
    override fun stop() { /* Implementaci√≥n completa */ }
    override fun next() { /* Siguiente canci√≥n */ }
    override fun previous() { /* Canci√≥n anterior */ }
    override fun shuffle() { /* Modo aleatorio */ }
    override fun repeat() { /* Modo repetici√≥n */ }
    override fun shareTrack() { /* Compartir */ }
    override fun downloadTrack() { /* Descargar */ }
}</code></pre>
        </div>

        <h3>Aplicaci√≥n pr√°ctica en Android Listeners</h3>
        <div class="code-block">
          <pre><code>// En lugar de un listener gigante
interface OnItemActionListener {
    fun onItemClick(item: Item)
    fun onItemLongClick(item: Item)
    fun onItemSwipe(item: Item)
    fun onItemDelete(item: Item)
    fun onItemEdit(item: Item)
    fun onItemShare(item: Item)
}

// Mejor: Listeners espec√≠ficos
interface OnItemClickListener {
    fun onItemClick(item: Item)
}

interface OnItemLongClickListener {
    fun onItemLongClick(item: Item)
}

interface OnItemSwipeListener {
    fun onItemSwipe(item: Item, direction: SwipeDirection)
}

// Uso en RecyclerView Adapter
class ItemAdapter(
    private val clickListener: OnItemClickListener? = null,
    private val longClickListener: OnItemLongClickListener? = null,
    private val swipeListener: OnItemSwipeListener? = null
) : RecyclerView.Adapter&lt;ItemViewHolder&gt;() {
    
    override fun onBindViewHolder(holder: ItemViewHolder, position: Int) {
        val item = items[position]
        
        holder.itemView.setOnClickListener {
            clickListener?.onItemClick(item)
        }
        
        holder.itemView.setOnLongClickListener {
            longClickListener?.onItemLongClick(item)
            true
        }
    }
}</code></pre>
        </div>

        <h2>5. Dependency Inversion Principle (DIP)</h2>
        <p>El principio de inversi√≥n de dependencias establece que:</p>
        <ul>
          <li><strong>Los m√≥dulos de alto nivel no deben depender de m√≥dulos de bajo nivel. Ambos deben depender de abstracciones.</strong></li>
          <li><strong>Las abstracciones no deben depender de detalles. Los detalles deben depender de abstracciones.</strong></li>
        </ul>

        <h3>‚ùå Ejemplo Incorrecto</h3>
        <p>Una clase que depende directamente de implementaciones concretas:</p>

        <div class="code-block">
          <pre><code>// ‚ùå MALO: Dependencias directas de clases concretas
class UserService {
    
    // Dependencia directa de clase concreta
    private val database = SQLiteUserDatabase()
    private val apiClient = RetrofitApiClient()
    private val logger = AndroidLogger()
    
    suspend fun getUser(id: String): User? {
        logger.log("Fetching user $id")
        
        // Primero intenta base de datos local
        val localUser = database.findUser(id)
        if (localUser != null) {
            return localUser
        }
        
        // Si no est√°, consulta API
        val remoteUser = apiClient.fetchUser(id)
        if (remoteUser != null) {
            database.saveUser(remoteUser)
        }
        
        return remoteUser
    }
}

// Problemas:
// - Dif√≠cil de testear (dependencias hardcodeadas)
// - Imposible cambiar implementaciones
// - Alto acoplamiento</code></pre>
        </div>

        <h3>‚úÖ Ejemplo Correcto</h3>
        <p>Inversi√≥n de dependencias usando interfaces y inyecci√≥n:</p>

        <div class="code-block">
          <pre><code>// ‚úÖ BUENO: Depende de abstracciones
interface UserDatabase {
    suspend fun findUser(id: String): User?
    suspend fun saveUser(user: User)
}

interface ApiClient {
    suspend fun fetchUser(id: String): User?
}

interface Logger {
    fun log(message: String)
}

// Implementaciones concretas
class SQLiteUserDatabase : UserDatabase {
    override suspend fun findUser(id: String): User? {
        // Implementaci√≥n SQLite
    }
    
    override suspend fun saveUser(user: User) {
        // Guardar en SQLite
    }
}

class RetrofitApiClient : ApiClient {
    override suspend fun fetchUser(id: String): User? {
        // Implementaci√≥n con Retrofit
    }
}

class AndroidLogger : Logger {
    override fun log(message: String) {
        Log.d("UserService", message)
    }
}

// Clase de alto nivel que depende de abstracciones
class UserService(
    private val database: UserDatabase,
    private val apiClient: ApiClient,
    private val logger: Logger
) {
    
    suspend fun getUser(id: String): User? {
        logger.log("Fetching user $id")
        
        val localUser = database.findUser(id)
        if (localUser != null) {
            return localUser
        }
        
        val remoteUser = apiClient.fetchUser(id)
        if (remoteUser != null) {
            database.saveUser(remoteUser)
        }
        
        return remoteUser
    }
}</code></pre>
        </div>

        <h3>Aplicaci√≥n con Hilt (Dependency Injection)</h3>
        <div class="code-block">
          <pre><code>// Configuraci√≥n de DI con Hilt
@Module
@InstallIn(SingletonComponent::class)
abstract class DatabaseModule {
    
    @Binds
    abstract fun bindUserDatabase(
        sqliteDatabase: SQLiteUserDatabase
    ): UserDatabase
    
    @Binds
    abstract fun bindApiClient(
        retrofitClient: RetrofitApiClient
    ): ApiClient
    
    @Binds
    abstract fun bindLogger(
        androidLogger: AndroidLogger
    ): Logger
}

// ViewModel con dependencias inyectadas
@HiltViewModel
class UserViewModel @Inject constructor(
    private val userService: UserService // Se inyectan autom√°ticamente sus dependencias
) : ViewModel() {
    
    private val _user = MutableLiveData&lt;User?&gt;()
    val user: LiveData&lt;User?&gt; = _user
    
    fun loadUser(id: String) {
        viewModelScope.launch {
            _user.value = userService.getUser(id)
        }
    }
}

// Testing con facilidad
class UserServiceTest {
    
    @Test
    fun `should return cached user when available`() = runTest {
        // Mocks f√°ciles gracias a las interfaces
        val mockDatabase = mockk&lt;UserDatabase&gt;()
        val mockApiClient = mockk&lt;ApiClient&gt;()
        val mockLogger = mockk&lt;Logger&gt;()
        
        val cachedUser = User("123", "John Doe")
        coEvery { mockDatabase.findUser("123") } returns cachedUser
        
        val userService = UserService(mockDatabase, mockApiClient, mockLogger)
        
        val result = userService.getUser("123")
        
        assertEquals(cachedUser, result)
        coVerify(exactly = 0) { mockApiClient.fetchUser(any()) }
    }
}</code></pre>
        </div>

        <div class="best-practices-box">
          <h3>üí° Ventajas del DIP en Android</h3>
          <ul>
            <li><strong>Testabilidad:</strong> F√°cil usar mocks y stubs en tests</li>
            <li><strong>Flexibilidad:</strong> Cambiar implementaciones sin tocar c√≥digo de alto nivel</li>
            <li><strong>Reutilizaci√≥n:</strong> Misma l√≥gica de negocio con diferentes implementaciones</li>
            <li><strong>Mantenibilidad:</strong> Cambios en implementaciones no afectan la l√≥gica de negocio</li>
          </ul>
        </div>

        <h2>Implementando SOLID en tu Proyecto Android</h2>
        
        <h3>üèóÔ∏è Arquitectura Recomendada</h3>
        <p>Para aplicar correctamente los principios SOLID en Android, te recomiendo seguir esta estructura:</p>

        <div class="code-block">
          <pre><code>// Estructura de paquetes siguiendo SOLID
com.tuapp.
‚îú‚îÄ‚îÄ di/                 // Dependency Injection (DIP)
‚îú‚îÄ‚îÄ data/
‚îÇ   ‚îú‚îÄ‚îÄ local/         // Implementaciones de persistencia local
‚îÇ   ‚îú‚îÄ‚îÄ remote/        // Implementaciones de APIs
‚îÇ   ‚îî‚îÄ‚îÄ repository/    // Repository pattern (SRP, DIP)
‚îú‚îÄ‚îÄ domain/
‚îÇ   ‚îú‚îÄ‚îÄ model/         // Entidades de dominio
‚îÇ   ‚îú‚îÄ‚îÄ repository/    // Interfaces de repository (DIP)
‚îÇ   ‚îî‚îÄ‚îÄ usecase/       // Casos de uso espec√≠ficos (SRP)
‚îú‚îÄ‚îÄ presentation/
‚îÇ   ‚îú‚îÄ‚îÄ ui/           // Activities, Fragments, Composables
‚îÇ   ‚îú‚îÄ‚îÄ viewmodel/    // ViewModels (SRP)
‚îÇ   ‚îî‚îÄ‚îÄ adapter/      // RecyclerView Adapters (SRP, ISP)
‚îî‚îÄ‚îÄ util/             // Utilidades reutilizables (SRP)</code></pre>
        </div>

        <h3>üîß Herramientas y Bibliotecas</h3>
        <div class="tools-grid">
          <div class="tool-card">
            <h4>Hilt / Dagger</h4>
            <p>Para Dependency Injection (DIP)</p>
          </div>
          <div class="tool-card">
            <h4>Room Database</h4>
            <p>Abstracci√≥n sobre SQLite (SRP, ISP)</p>
          </div>
          <div class="tool-card">
            <h4>Retrofit + OkHttp</h4>
            <p>Cliente HTTP con interfaces (OCP, DIP)</p>
          </div>
          <div class="tool-card">
            <h4>Repository Pattern</h4>
            <p>Abstracci√≥n de fuentes de datos (SRP, DIP)</p>
          </div>
        </div>

        <h3>‚ö†Ô∏è Errores Comunes a Evitar</h3>
        <div class="warning-box">
          <h4>Cuidado con estos anti-patrones:</h4>
          <ul>
            <li><strong>God Activities:</strong> Activities que hacen demasiado (viola SRP)</li>
            <li><strong>Tight Coupling:</strong> Clases que dependen de implementaciones concretas (viola DIP)</li>
            <li><strong>Fat Interfaces:</strong> Interfaces con demasiados m√©todos (viola ISP)</li>
            <li><strong>Hardcoded Dependencies:</strong> new SomeClass() en lugar de inyecci√≥n (viola DIP)</li>
            <li><strong>Monolithic Classes:</strong> Clases que cambian por m√∫ltiples razones (viola SRP)</li>
          </ul>
        </div>

        <h3>üß™ Testing con SOLID</h3>
        <p>Los principios SOLID facilitan enormemente el testing. Aqu√≠ un ejemplo de c√≥mo testear f√°cilmente cuando aplicamos estos principios:</p>

        <div class="code-block">
          <pre><code>@RunWith(MockitoJUnitRunner::class)
class UserViewModelTest {
    
    @Mock
    private lateinit var getUserUseCase: GetUserUseCase
    
    @Mock
    private lateinit var updateUserUseCase: UpdateUserUseCase
    
    private lateinit var viewModel: UserViewModel
    
    @Before
    fun setup() {
        viewModel = UserViewModel(getUserUseCase, updateUserUseCase)
    }
    
    @Test
    fun `should show loading when fetching user`() {
        // Given
        val userId = "123"
        whenever(getUserUseCase.execute(userId))
            .thenReturn(flowOf(Resource.Loading()))
        
        // When
        viewModel.loadUser(userId)
        
        // Then
        assertTrue(viewModel.isLoading.value)
    }
    
    @Test
    fun `should display user when fetch succeeds`() {
        // Given
        val user = User("123", "John Doe")
        whenever(getUserUseCase.execute("123"))
            .thenReturn(flowOf(Resource.Success(user)))
        
        // When
        viewModel.loadUser("123")
        
        // Then
        assertEquals(user, viewModel.user.value)
        assertFalse(viewModel.isLoading.value)
    }
}</code></pre>
        </div>

        <h2>Conclusi√≥n</h2>
        <p>Los principios SOLID no son solo teor√≠a acad√©mica, sino herramientas pr√°cticas que transformar√°n la calidad de tu c√≥digo Android. Al aplicarlos consistentemente, conseguir√°s:</p>

        <ul>
          <li><strong>C√≥digo m√°s limpio y mantenible</strong> que evoluciona sin romperse</li>
          <li><strong>Tests m√°s f√°ciles de escribir</strong> gracias a las dependencias inyectadas</li>
          <li><strong>Desarrollo m√°s r√°pido</strong> porque puedes reutilizar componentes</li>
          <li><strong>Menos bugs</strong> porque cada clase tiene una responsabilidad clara</li>
          <li><strong>Equipos m√°s productivos</strong> porque el c√≥digo es predecible y comprensible</li>
        </ul>

        <p>Recuerda: <strong>no trates de aplicar todos los principios de una vez</strong>. Empieza por SRP (una responsabilidad por clase) y ve incorporando gradualmente los dem√°s. Con pr√°ctica y paciencia, escribir c√≥digo SOLID se volver√° natural.</p>

        <p>¬°Tu yo del futuro (y tus compa√±eros de equipo) te lo agradecer√°n! üôå</p>

        <div class="call-to-action-box">
          <h3>üöÄ Pr√≥ximos Pasos</h3>
          <p>¬øTe ha gustado este art√≠culo? Te recomiendo estos pr√≥ximos temas para profundizar:</p>
          <ul>
            <li>Clean Architecture en Android</li>
            <li>Dependency Injection con Hilt</li>
            <li>Testing Strategy para aplicaciones Android</li>
            <li>Repository Pattern avanzado</li>
          </ul>
        </div>

        <div class="article-footer">
          <div class="tags">
            <span class="tag">Android</span>
            <span class="tag">Kotlin</span>
            <span class="tag">SOLID</span>
            <span class="tag">Clean Code</span>
            <span class="tag">Architecture</span>
            <span class="tag">Best Practices</span>
          </div>
          <div class="share-buttons">
            <a href="#" class="share-btn">Compartir en Twitter</a>
            <a href="#" class="share-btn">Compartir en LinkedIn</a>
          </div>
        </div>
      </div>
    </div>
  </article>

  <footer class="footer">
    <div class="container">
      <div class="footer-content">
        <div class="footer-text">
          <p>&copy; 2025 ArceApps. Desarrollado con HTML, CSS y JavaScript.</p>
        </div>
        <div class="footer-links">
          <a href="#" class="footer-link">GitHub</a>
          <a href="#" class="footer-link">LinkedIn</a>
          <a href="#" class="footer-link">Contacto</a>
        </div>
      </div>
    </div>
  </footer>

  <script src="script.js"></script>
</body>
</html>